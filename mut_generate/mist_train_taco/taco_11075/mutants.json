{
  "task_id": "taco_11075",
  "entry_point": "divide_segments",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n <= 2:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n <= 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n >= 2:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n >= 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n != 2:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n != 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "index = -1",
      "mutated_line": "index = +1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = +1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if index == -1:",
      "mutated_line": "return -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index != -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result = [0] * n",
      "mutated_line": "result = [0] / n",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] / n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result = [0] * n",
      "mutated_line": "result = [0] + n",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] + n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result = [0] * n",
      "mutated_line": "result = [0] ** n",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] ** n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 3:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 3:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 1:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 0:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 0:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 1:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < -2:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < -2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "return -1  # There must be at least two segments to form two non-empty groups",
      "mutated_line": "return +1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return +1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[-1][1]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][1]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[-1][-1]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][-1]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[-1][1]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][1]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "index = -1",
      "mutated_line": "index = -2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -2\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "index = -1",
      "mutated_line": "index = -0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -0\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "index = -1",
      "mutated_line": "index = -0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -0\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "index = -1",
      "mutated_line": "index = --1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = --1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n + 2, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n + 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n * 2, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n * 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, +1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, +1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, +1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, +1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][1] > mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] > mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][1] < mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] < mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][1] == mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] == mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if index == -1:",
      "mutated_line": "return -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == +1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1  # No valid division point found",
      "mutated_line": "return +1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return +1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i <= index:",
      "mutated_line": "if i < index:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i < index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i <= index:",
      "mutated_line": "if i > index:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i > index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i <= index:",
      "mutated_line": "if i == index:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i == index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1  # There must be at least two segments to form two non-empty groups",
      "mutated_line": "return -2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -2\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1  # There must be at least two segments to form two non-empty groups",
      "mutated_line": "return -0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -0\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1  # There must be at least two segments to form two non-empty groups",
      "mutated_line": "return -0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -0\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1  # There must be at least two segments to form two non-empty groups",
      "mutated_line": "return --1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return --1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[+1][0]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[+1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 3, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 3, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 1, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 0, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 1, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - -2, -1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - -2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -2, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -2, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -0, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -0, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -0, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -0, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, --1, -1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, --1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -2):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -2):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -0):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -0):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -0):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -0):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 2, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, --1):",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, --1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index == -1:",
      "mutated_line": "return -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -2:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index == -1:",
      "mutated_line": "return -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -0:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index == -1:",
      "mutated_line": "return -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -0:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if index == -1:",
      "mutated_line": "return -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == --1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1  # No valid division point found",
      "mutated_line": "return -2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -2\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1  # No valid division point found",
      "mutated_line": "return -0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -0\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1  # No valid division point found",
      "mutated_line": "return -0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -0\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1  # No valid division point found",
      "mutated_line": "return --1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return --1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result = [0] * n",
      "mutated_line": "result = [1] * n",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [1] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result = [0] * n",
      "mutated_line": "result = [-1] * n",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [-1] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result = [0] * n",
      "mutated_line": "result = [1] * n",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [1] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][2]] = 2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 2\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][2]] = 0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 0\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][2]] = 0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 0\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][2]] = -1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = -1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][2]] = 3",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][2]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 1\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][2]] = 0",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 0\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][2]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 1\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][2]] = -2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = -2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[-2][0]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-2][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[-0][0]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-0][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[-0][0]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-0][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mn = indexed_segments[-1][0]",
      "mutated_line": "mn = indexed_segments[--1][0]",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[--1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][2] >= mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][2] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][0] >= mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][0] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][0] >= mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][0] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if indexed_segments[i][1] >= mn:",
      "mutated_line": "if indexed_segments[i][-1] >= mn:",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][-1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "indexed_segments.sort(key=lambda x: x[1])",
      "mutated_line": "indexed_segments.sort(key=lambda x: x[2])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[2])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "indexed_segments.sort(key=lambda x: x[1])",
      "mutated_line": "indexed_segments.sort(key=lambda x: x[0])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[0])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "indexed_segments.sort(key=lambda x: x[1])",
      "mutated_line": "indexed_segments.sort(key=lambda x: x[0])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[0])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "indexed_segments.sort(key=lambda x: x[1])",
      "mutated_line": "indexed_segments.sort(key=lambda x: x[-1])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[-1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn = min(mn, indexed_segments[i][0])",
      "mutated_line": "mn = min(mn, indexed_segments[i][1])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][1])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn = min(mn, indexed_segments[i][0])",
      "mutated_line": "mn = min(mn, indexed_segments[i][-1])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][-1])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn = min(mn, indexed_segments[i][0])",
      "mutated_line": "mn = min(mn, indexed_segments[i][1])",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][1])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][3]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][3]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][1]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][1]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][0]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][0]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][1]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][1]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result[indexed_segments[i][2]] = 1",
      "mutated_line": "result[indexed_segments[i][-2]] = 1",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][-2]] = 1\n        else:\n            result[indexed_segments[i][2]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][3]] = 2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][3]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][1]] = 2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][1]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][0]] = 2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][0]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][1]] = 2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][1]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result[indexed_segments[i][2]] = 2",
      "mutated_line": "result[indexed_segments[i][-2]] = 2",
      "code": "def divide_segments(segments):\n    n = len(segments)\n    if n < 2:\n        return -1\n    indexed_segments = [(l, r, i) for (i, (l, r)) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: x[1])\n    mn = indexed_segments[-1][0]\n    index = -1\n    for i in range(n - 2, -1, -1):\n        if indexed_segments[i][1] >= mn:\n            mn = min(mn, indexed_segments[i][0])\n        else:\n            index = i\n            break\n    if index == -1:\n        return -1\n    result = [0] * n\n    for i in range(n):\n        if i <= index:\n            result[indexed_segments[i][2]] = 1\n        else:\n            result[indexed_segments[i][-2]] = 2\n    return result"
    }
  ]
}