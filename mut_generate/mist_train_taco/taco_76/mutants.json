{
  "task_id": "taco_76",
  "entry_point": "can_defeat_boss",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "scroll_damage = 0",
      "mutated_line": "scroll_damage = 1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 1\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "scroll_damage = 0",
      "mutated_line": "scroll_damage = -1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = -1\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "scroll_damage = 0",
      "mutated_line": "scroll_damage = 1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 1\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tick = 0",
      "mutated_line": "tick = 1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 1\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tick = 0",
      "mutated_line": "tick = -1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = -1\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tick = 0",
      "mutated_line": "tick = 1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 1\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while False:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "boss_curr -= scroll_damage",
      "mutated_line": "boss_curr += scroll_damage",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr += scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "tick += 1",
      "mutated_line": "tick -= 1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick -= 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if boss_curr <= 0:",
      "mutated_line": "if boss_curr < 0:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr < 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if boss_curr <= 0:",
      "mutated_line": "if boss_curr > 0:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr > 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if boss_curr <= 0:",
      "mutated_line": "if boss_curr == 0:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr == 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = True\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if not found and boss_curr >= boss_prev:",
      "mutated_line": "return 'NO'",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found or boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tick += 1",
      "mutated_line": "tick += 2",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tick += 1",
      "mutated_line": "tick += 0",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tick += 1",
      "mutated_line": "tick += 0",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tick += 1",
      "mutated_line": "tick += -1",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.active = False",
      "mutated_line": "self.active = True",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = True\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "scrolls = [Scroll(i + 1, powi, dmgi) for i, (powi, dmgi) in enumerate(scrolls)]",
      "mutated_line": "scrolls = [Scroll(i - 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i - 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "scrolls = [Scroll(i + 1, powi, dmgi) for i, (powi, dmgi) in enumerate(scrolls)]",
      "mutated_line": "scrolls = [Scroll(i * 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i * 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "boss_curr = min(boss_max, boss_curr + regenerate)",
      "mutated_line": "boss_curr = min(boss_max, boss_curr - regenerate)",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr - regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "boss_curr = min(boss_max, boss_curr + regenerate)",
      "mutated_line": "boss_curr = min(boss_max, boss_curr * regenerate)",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr * regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if boss_curr <= 0:",
      "mutated_line": "if boss_curr <= 1:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 1:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if boss_curr <= 0:",
      "mutated_line": "if boss_curr <= -1:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= -1:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if boss_curr <= 0:",
      "mutated_line": "if boss_curr <= 1:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 1:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active or 100 * boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active or 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "scroll_damage += scroll.damage",
      "mutated_line": "scroll_damage -= scroll.damage",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage -= scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if not found and boss_curr >= boss_prev:",
      "mutated_line": "return 'NO'",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr > boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if not found and boss_curr >= boss_prev:",
      "mutated_line": "return 'NO'",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr < boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if not found and boss_curr >= boss_prev:",
      "mutated_line": "return 'NO'",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr == boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return ''\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "scrolls = [Scroll(i + 1, powi, dmgi) for i, (powi, dmgi) in enumerate(scrolls)]",
      "mutated_line": "scrolls = [Scroll(i + 2, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 2, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "scrolls = [Scroll(i + 1, powi, dmgi) for i, (powi, dmgi) in enumerate(scrolls)]",
      "mutated_line": "scrolls = [Scroll(i + 0, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 0, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "scrolls = [Scroll(i + 1, powi, dmgi) for i, (powi, dmgi) in enumerate(scrolls)]",
      "mutated_line": "scrolls = [Scroll(i + 0, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 0, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "scrolls = [Scroll(i + 1, powi, dmgi) for i, (powi, dmgi) in enumerate(scrolls)]",
      "mutated_line": "scrolls = [Scroll(i + -1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + -1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "scrolls.sort(key=lambda scroll: -scroll.damage)",
      "mutated_line": "scrolls.sort(key=lambda scroll: +scroll.damage)",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: +scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return \"YES\", tick, len(active_scrolls), used_scrolls",
      "mutated_line": "return ('', tick, len(active_scrolls), used_scrolls)",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 * boss_curr < scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr < scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 * boss_curr > scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr > scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 * boss_curr == scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr == scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "scroll.active = True",
      "mutated_line": "scroll.active = False",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = False\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = False\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 / boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 / boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 + boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 + boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 ** boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 ** boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 * boss_curr <= scroll.power / boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power / boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 * boss_curr <= scroll.power + boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power + boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 100 * boss_curr <= scroll.power ** boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 100 * boss_curr <= scroll.power ** boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 101 * boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 101 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 99 * boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 99 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 0 * boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 0 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and 1 * boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and 1 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not scroll.active and 100 * boss_curr <= scroll.power * boss_max:",
      "mutated_line": "if not scroll.active and -100 * boss_curr <= scroll.power * boss_max:",
      "code": "def can_defeat_boss(num_scrolls, boss_max, regenerate, scrolls):\n\n    class Scroll:\n\n        def __init__(self, id, power, damage):\n            self.id = id\n            self.power = power\n            self.damage = damage\n            self.active = False\n            self.start = None\n    scrolls = [Scroll(i + 1, powi, dmgi) for (i, (powi, dmgi)) in enumerate(scrolls)]\n    scrolls.sort(key=lambda scroll: -scroll.damage)\n    boss_curr = boss_max\n    scroll_damage = 0\n    active_scrolls = []\n    tick = 0\n    while True:\n        boss_prev = boss_curr\n        boss_curr -= scroll_damage\n        boss_curr = min(boss_max, boss_curr + regenerate)\n        if boss_curr <= 0:\n            used_scrolls = [(scroll.start, scroll.id) for scroll in active_scrolls]\n            return ('YES', tick, len(active_scrolls), used_scrolls)\n        found = False\n        for scroll in scrolls:\n            if not scroll.active and -100 * boss_curr <= scroll.power * boss_max:\n                scroll.start = tick\n                scroll.active = True\n                active_scrolls.append(scroll)\n                scroll_damage += scroll.damage\n                found = True\n                break\n        if not found and boss_curr >= boss_prev:\n            return 'NO'\n        tick += 1"
    }
  ]
}