{
  "task_id": "taco_16354",
  "entry_point": "maximize_talks",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le >= 1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le >= 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le <= 1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le <= 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le != 1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le != 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le > 2:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 2:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le > 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 0:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le > 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 0:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while le > 1:",
      "mutated_line": "while le > -1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > -1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 and curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 and curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] != 0 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] != 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[0] != 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] != 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([+sociability_list[i], i + 1])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([+sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([-sociability_list[i], i - 1])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i - 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([-sociability_list[i], i * 1])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i * 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 1 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 1 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == -1 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == -1 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 1 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 1 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[0] == 1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 1:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[0] == -1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == -1:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[0] == 1:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 1:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([-sociability_list[i], i + 2])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 2])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([-sociability_list[i], i + 0])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 0])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([-sociability_list[i], i + 0])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 0])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l.append([-sociability_list[i], i + 1])",
      "mutated_line": "l.append([-sociability_list[i], i + -1])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + -1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[1] == 0 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[1] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[-1] == 0 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[-1] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[1] == 0 or curr1[0] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[1] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[1] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[1] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[-1] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[-1] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if curr2[0] == 0 or curr1[0] == 0:",
      "mutated_line": "if curr2[0] == 0 or curr1[1] == 0:",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[1] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [+(-curr1[0] - 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [+(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [+(-curr2[0] - 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [+(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] + 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] + 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] * 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] * 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[2]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[2]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[0]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[0]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[0]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[0]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[-1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[-1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] + 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] + 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] * 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] * 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[2]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[2]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[0]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[0]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[0]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[0]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[-1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[-1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[2], curr2[1]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[2], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[0], curr2[1]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[0], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[0], curr2[1]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[0], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[-1], curr2[1]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[-1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[1], curr2[2]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[2]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[1], curr2[0]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[0]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[1], curr2[0]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[0]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans.append((curr1[1], curr2[1]))",
      "mutated_line": "ans.append((curr1[1], curr2[-1]))",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[-1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(+curr1[0] - 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(+curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 2), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 2), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 0), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 0), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - 0), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 0), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[0] - -1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - -1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(+curr2[0] - 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(+curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 2), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 2), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 0), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 0), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - 0), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 0), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[0] - -1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - -1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[1] - 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[1] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[-1] - 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[-1] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr1[1] - 1), curr1[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[1] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[1] - 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[1] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[-1] - 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[-1] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(l, [-(-curr2[0] - 1), curr2[1]])",
      "mutated_line": "heapq.heappush(l, [-(-curr2[1] - 1), curr2[1]])",
      "code": "import heapq\n\ndef maximize_talks(sociability_list):\n    n = len(sociability_list)\n    l = []\n    for i in range(n):\n        l.append([-sociability_list[i], i + 1])\n    ans = []\n    heapq.heapify(l)\n    le = n\n    while le > 1:\n        curr1 = heapq.heappop(l)\n        curr2 = heapq.heappop(l)\n        if curr2[0] == 0 or curr1[0] == 0:\n            break\n        else:\n            heapq.heappush(l, [-(-curr1[0] - 1), curr1[1]])\n            heapq.heappush(l, [-(-curr2[1] - 1), curr2[1]])\n            ans.append((curr1[1], curr2[1]))\n    max_talks = len(ans)\n    return (max_talks, ans)"
    }
  ]
}