{
  "task_id": "taco_12670",
  "entry_point": "calculate_minimum_cost",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] / ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] / ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] + ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] + ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] ** ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] ** ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] / ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] / ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] + ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] + ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] ** ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] ** ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp2[0] = 0",
      "mutated_line": "dp2[0] = 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 1\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp2[0] = 0",
      "mutated_line": "dp2[0] = -1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = -1\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp2[0] = 0",
      "mutated_line": "dp2[0] = 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 1\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((1 << N) - 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) - 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((1 << N) * 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) * 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) + 1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) + 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) * 1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) * 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mask = 0",
      "mutated_line": "mask = 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 1\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mask = 0",
      "mutated_line": "mask = -1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = -1\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mask = 0",
      "mutated_line": "mask = 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 1\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) + 1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) + 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) * 1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) * 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, +1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, +1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -1, +1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, +1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((1 << N) - 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) - 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((1 << N) * 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) * 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp2[0] = 0",
      "mutated_line": "dp2[1] = 0",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[1] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp2[0] = 0",
      "mutated_line": "dp2[-1] = 0",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[-1] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp2[0] = 0",
      "mutated_line": "dp2[1] = 0",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[1] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while submask > 0:",
      "mutated_line": "while submask >= 0:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask >= 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while submask > 0:",
      "mutated_line": "while submask <= 0:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask <= 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while submask > 0:",
      "mutated_line": "while submask != 0:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask != 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000001.0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000001.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [999999999.0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [999999999.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [-1000000000.0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [-1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((1 << N) + 2)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 2)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((1 << N) + 0)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 0)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((1 << N) + 0)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 0)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((1 << N) + -1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + -1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 2] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 2] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 0] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 0] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 0] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 0] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - -1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - -1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) + 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) + 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) * 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) * 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask & 1 << j - 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask & 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask ^ 1 << j - 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask ^ 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 2, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 2, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 0, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 0, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 0, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 0, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - -1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - -1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -2, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -2, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -0, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -0, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -0, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -0, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, --1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, --1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -1, -2):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -2):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -1, -0):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -0):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -1, -0):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -0):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((1 << N) - 1, -1, --1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, --1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i | 1 << j:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i | 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000001.0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000001.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [999999999.0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [999999999.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [-1000000000.0] * ((1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [-1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((1 << N) + 2)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 2)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((1 << N) + 0)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 0)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((1 << N) + 0)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 0)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((1 << N) + -1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + -1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1 << N):",
      "mutated_line": "for i in range(2 << N):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(2 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1 << N):",
      "mutated_line": "for i in range(0 << N):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(0 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1 << N):",
      "mutated_line": "for i in range(0 << N):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(0 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1 << N):",
      "mutated_line": "for i in range(-1 << N):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(-1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while submask > 0:",
      "mutated_line": "while submask > 1:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 1:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while submask > 0:",
      "mutated_line": "while submask > -1:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > -1:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while submask > 0:",
      "mutated_line": "while submask > 1:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 1:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask - 1 | i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 | i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(1 << N) + 1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) + 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(1 << N) * 1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) * 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((2 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((2 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((0 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((0 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((0 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((0 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp1 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp1 = [1000000000.0] * ((-1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((-1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp1[1 << i] = C[i]",
      "mutated_line": "dp1[2 << i] = C[i]",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[2 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp1[1 << i] = C[i]",
      "mutated_line": "dp1[0 << i] = C[i]",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[0 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp1[1 << i] = C[i]",
      "mutated_line": "dp1[0 << i] = C[i]",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[0 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp1[1 << i] = C[i]",
      "mutated_line": "dp1[-1 << i] = C[i]",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[-1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(2 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(2 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(0 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(0 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(0 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(0 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(-1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(-1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 2], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 2], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 0], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 0], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 0], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 0], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - -1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - -1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((2 << N) - 1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((2 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((0 << N) - 1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((0 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((0 << N) - 1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((0 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range((1 << N) - 1, -1, -1):",
      "mutated_line": "for i in range((-1 << N) - 1, -1, -1):",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((-1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((2 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((2 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((0 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((0 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((0 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((0 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2 = [1000000000.0] * ((1 << N) + 1)",
      "mutated_line": "dp2 = [1000000000.0] * ((-1 << N) + 1)",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((-1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])",
      "mutated_line": "dp2[i] = min(dp2[i], dp2[i ^ submask] - dp1[submask])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] - dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])",
      "mutated_line": "dp2[i] = min(dp2[i], dp2[i ^ submask] * dp1[submask])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] * dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask + 1 & i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask + 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask * 1 & i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask * 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(1 << N) - 2])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(1 << N) - 0])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(1 << N) - 0])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(1 << N) - -1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - -1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(2 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(2 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(0 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(0 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(0 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(0 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))",
      "mutated_line": "dp1[(1 << N) - 1] = min(dp1[(-1 << N) - 1], sum(C))",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(-1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 2 << j - 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 2 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 0 << j - 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 0 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 0 << j - 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 0 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | -1 << j - 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | -1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 1 << j + 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j + 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 1 << j * 1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j * 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 2 << j:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 2 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 0 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 0 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & -1 << j:",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & -1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i | 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i | 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask - 2 & i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 2 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask - 0 & i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 0 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask - 0 & i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 0 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "submask = submask - 1 & i",
      "mutated_line": "submask = submask - -1 & i",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - -1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(2 << N) - 1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(2 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(0 << N) - 1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(0 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(0 << N) - 1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(0 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "results.append(dp2[(1 << N) - 1])",
      "mutated_line": "results.append(dp2[(-1 << N) - 1])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(-1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 1 << j - 2",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 2\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 1 << j - 0",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 0\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 1 << j - 0",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 0\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mask = mask | 1 << (j - 1)",
      "mutated_line": "mask = mask | 1 << j - -1",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - -1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 1 << j] = min(dp1[i | 1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i | 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])",
      "mutated_line": "dp2[i] = min(dp2[i], dp2[i | submask] + dp1[submask])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i | submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 2 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 2 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 0 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 0 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 0 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 0 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ -1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ -1 << j] = min(dp1[i ^ 1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 2 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 2 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 0 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 0 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 0 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ 0 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp1[i ^ 1 << j] = min(dp1[i ^ 1 << j], dp1[i])",
      "mutated_line": "dp1[i ^ 1 << j] = min(dp1[i ^ -1 << j], dp1[i])",
      "code": "def calculate_minimum_cost(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, M, C, meal_sets) = test_cases[t]\n        dp1 = [1000000000.0] * ((1 << N) + 1)\n        for i in range(N):\n            dp1[1 << i] = C[i]\n        dp1[(1 << N) - 1] = min(dp1[(1 << N) - 1], sum(C))\n        for i in range(M):\n            (P, Q, A) = meal_sets[i]\n            mask = 0\n            for j in A:\n                mask = mask | 1 << j - 1\n            dp1[mask] = min(dp1[mask], P)\n        for i in range((1 << N) - 1, -1, -1):\n            for j in range(N):\n                if i & 1 << j:\n                    dp1[i ^ 1 << j] = min(dp1[i ^ -1 << j], dp1[i])\n        dp2 = [1000000000.0] * ((1 << N) + 1)\n        dp2[0] = 0\n        for i in range(1 << N):\n            submask = i\n            while submask > 0:\n                dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n                submask = submask - 1 & i\n        results.append(dp2[(1 << N) - 1])\n    return results"
    }
  ]
}