{
  "task_id": "taco_7827",
  "entry_point": "calculate_maximum_complexity",
  "mutant_count": 167,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) - abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) - abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) * abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) * abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] / (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] / (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] + (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] + (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] ** (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] ** (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(2, k + 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(2, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(0, k + 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(0, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(0, k + 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(0, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(-1, k + 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(-1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(1, k - 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k - 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(1, k * 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k * 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(1, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(1, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(-1, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(-1, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(1, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(1, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 1), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 1), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, -1), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, -1), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 1), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 1), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (1, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (1, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (-1, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (-1, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (1, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (1, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m + 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m + 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m * 1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m * 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n + 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n + 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n * 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n * 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 1), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 1), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, -1), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, -1), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 1), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 1), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n + 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n + 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n * 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n * 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m + 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m * 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m * 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k - 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k - 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k * 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k * 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(1, 3), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(1, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(-1, 3), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(-1, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(1, 3), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(1, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 4), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 4), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 2), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 2), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 0), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 0), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 1), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 1), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, -3), (3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, -3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (4, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (4, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (2, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (2, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (0, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (0, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (1, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (1, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (-3, 0), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (-3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 1), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 1), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, -1), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, -1), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 1), (1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 1), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (2, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (2, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (0, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (0, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (0, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (0, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (-1, 2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (-1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 3), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 3), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 1), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 1), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 0), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 0), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 1), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 1), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, -2), (2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, -2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (3, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (3, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (1, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (1, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (0, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (0, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (1, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (1, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (-2, 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (-2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 2)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 2)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 0)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 0)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]",
      "mutated_line": "pairs = [(0, 3), (3, 0), (1, 2), (2, -1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, -1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(1, k + 2):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 2):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(1, k + 0):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 0):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(1, k + 0):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 0):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, k + 1):",
      "mutated_line": "for i in range(1, k + -1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + -1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(i, k + 1):",
      "mutated_line": "for j in range(i, k - 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k - 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(i, k + 1):",
      "mutated_line": "for j in range(i, k * 1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k * 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] + b[0]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] + b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] * b[0]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] * b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[1] + b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] + b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[1] * b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] * b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 2), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 2), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 0), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 0), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 0), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 0), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - -1), (n - 1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - -1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 2, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 2, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 0, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 0, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 0, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 0, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - -1, 0), (n - 1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - -1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 2, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 2, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 0, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 0, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 0, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 0, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - -1, m - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - -1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 2)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 2)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 0)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 0)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]",
      "mutated_line": "corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - -1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - -1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, +1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, +1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (+1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (+1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (+1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (+1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, +1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, +1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k - 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k * 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k * 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[+1] * (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[+1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 2) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 2) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 0) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 0) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 0) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 0) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + -1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + -1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 1) for _ in range(k - 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k - 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 1) for _ in range(k * 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k * 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(i, k + 1):",
      "mutated_line": "for j in range(i, k + 2):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 2):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(i, k + 1):",
      "mutated_line": "for j in range(i, k + 0):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 0):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(i, k + 1):",
      "mutated_line": "for j in range(i, k + 0):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 0):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(i, k + 1):",
      "mutated_line": "for j in range(i, k + -1):",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + -1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -2), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -2), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -0), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -0), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -0), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -0), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, --1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, --1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-2, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-2, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-0, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-0, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-0, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-0, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (--1, m), (-1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (--1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-2, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-2, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-0, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-0, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-0, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-0, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (--1, -1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (--1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -2)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -2)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -0)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -0)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -0)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -0)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, --1)] for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, --1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 2)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 2)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 0)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 0)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]",
      "mutated_line": "vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + -1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + -1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]",
      "mutated_line": "vertex[note] = [(i, j) if dis((i, j), c) <= dis(v, c) else v for (v, c) in zip(vertex[note], corner)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) <= dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]",
      "mutated_line": "vertex[note] = [(i, j) if dis((i, j), c) >= dis(v, c) else v for (v, c) in zip(vertex[note], corner)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) >= dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]",
      "mutated_line": "vertex[note] = [(i, j) if dis((i, j), c) != dis(v, c) else v for (v, c) in zip(vertex[note], corner)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) != dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-2] * (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-2] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-0] * (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-0] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-0] * (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-0] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[--1] * (k + 1) for _ in range(k + 1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[--1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 2)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 2)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 0)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 0)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 0)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "maxdis = [[-1] * (k + 1) for _ in range(k + 1)]",
      "mutated_line": "maxdis = [[-1] * (k + 1) for _ in range(k + -1)]",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + -1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i - 1]] for i in range(len(song_sequence) - 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i - 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i * 1]] for i in range(len(song_sequence) - 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i * 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) + 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) + 1)))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) * 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) * 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[1] - b[0]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[1] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[-1] - b[0]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[-1] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[1] - b[0]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[1] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[1]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[1]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[-1]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[-1]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[1]) + abs(a[1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[1]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[2] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[2] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[0] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[0] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[0] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[0] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[-1] - b[1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[-1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[1] - b[2])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[2])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[1] - b[0])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[0])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[1] - b[0])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[0])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return abs(a[0] - b[0]) + abs(a[1] - b[1])",
      "mutated_line": "return abs(a[0] - b[0]) + abs(a[1] - b[-1])",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[-1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 2]] for i in range(len(song_sequence) - 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 2]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 0]] for i in range(len(song_sequence) - 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 0]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 0]] for i in range(len(song_sequence) - 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 0]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + -1]] for i in range(len(song_sequence) - 1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + -1]] for i in range(len(song_sequence) - 1)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 2)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 2)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 0)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 0)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 0)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 0)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - 1)))",
      "mutated_line": "return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - -1)))",
      "code": "def calculate_maximum_complexity(n, m, k, s, notes_matrix, song_sequence):\n\n    def dis(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    corner = [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]\n    vertex = [[(n, m), (n, -1), (-1, m), (-1, -1)] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(m):\n            note = notes_matrix[i][j]\n            vertex[note] = [(i, j) if dis((i, j), c) < dis(v, c) else v for (v, c) in zip(vertex[note], corner)]\n    maxdis = [[-1] * (k + 1) for _ in range(k + 1)]\n    pairs = [(0, 3), (3, 0), (1, 2), (2, 1)]\n    for i in range(1, k + 1):\n        for j in range(i, k + 1):\n            (vi, vj) = (vertex[i], vertex[j])\n            maxdis[i][j] = max((dis(vi[a], vj[b]) for (a, b) in pairs))\n            maxdis[j][i] = maxdis[i][j]\n    return max((maxdis[song_sequence[i]][song_sequence[i + 1]] for i in range(len(song_sequence) - -1)))"
    }
  ]
}