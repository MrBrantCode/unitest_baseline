{
  "task_id": "taco_8995",
  "entry_point": "minimize_binary_string",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "l = ['1'] * n  # Initialize the result list with '1's",
      "mutated_line": "l = ['1'] / n",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] / n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "l = ['1'] * n  # Initialize the result list with '1's",
      "mutated_line": "l = ['1'] + n",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] + n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "l = ['1'] * n  # Initialize the result list with '1's",
      "mutated_line": "l = ['1'] ** n",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] ** n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ind = 0  # Index to track the position of the next '0' to be placed",
      "mutated_line": "ind = 1",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 1\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ind = 0  # Index to track the position of the next '0' to be placed",
      "mutated_line": "ind = -1",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = -1\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ind = 0  # Index to track the position of the next '0' to be placed",
      "mutated_line": "ind = 1",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 1\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if s[i] == '0':",
      "mutated_line": "if s[i] != '0':",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] != '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "k -= val  # Decrease the number of available moves",
      "mutated_line": "k += val",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k += val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "ind += 1  # Increment the index for the next '0'",
      "mutated_line": "ind -= 1",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind -= 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "l = ['1'] * n  # Initialize the result list with '1's",
      "mutated_line": "l = [''] * n",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = [''] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[i] == '0':",
      "mutated_line": "if s[i] == '':",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "l[i - val] = '0'  # Place '0' at the new position",
      "mutated_line": "l[i - val] = ''",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = ''\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ind += 1  # Increment the index for the next '0'",
      "mutated_line": "ind += 2",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 2\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ind += 1  # Increment the index for the next '0'",
      "mutated_line": "ind += 0",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 0\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ind += 1  # Increment the index for the next '0'",
      "mutated_line": "ind += 0",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 0\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ind += 1  # Increment the index for the next '0'",
      "mutated_line": "ind += -1",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += -1\n    return ''.join(l)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return ''.join(l)  # Convert the list back to a string and return",
      "mutated_line": "return 'MUTATED'.join(l)",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return 'MUTATED'.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = min(k, i - ind)  # Calculate the number of moves we can make",
      "mutated_line": "val = min(k, i + ind)",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i + ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = min(k, i - ind)  # Calculate the number of moves we can make",
      "mutated_line": "val = min(k, i * ind)",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i * ind)\n            k -= val\n            l[i - val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "l[i - val] = '0'  # Place '0' at the new position",
      "mutated_line": "l[i + val] = '0'",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i + val] = '0'\n            ind += 1\n    return ''.join(l)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "l[i - val] = '0'  # Place '0' at the new position",
      "mutated_line": "l[i * val] = '0'",
      "code": "def minimize_binary_string(n, k, s):\n    \"\"\"\n    Given a binary string of length `n`, this function returns the lexicographically minimum possible string\n    that can be obtained by performing no more than `k` adjacent swaps.\n\n    Parameters:\n    - n (int): The length of the binary string.\n    - k (int): The maximum number of moves allowed.\n    - s (str): The binary string consisting of '0's and '1's.\n\n    Returns:\n    - str: The lexicographically minimum possible string after performing no more than `k` moves.\n    \"\"\"\n    s = list(s)\n    l = ['1'] * n\n    ind = 0\n    for i in range(n):\n        if s[i] == '0':\n            val = min(k, i - ind)\n            k -= val\n            l[i * val] = '0'\n            ind += 1\n    return ''.join(l)"
    }
  ]
}