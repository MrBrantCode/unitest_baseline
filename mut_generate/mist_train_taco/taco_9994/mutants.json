{
  "task_id": "taco_9994",
  "entry_point": "find_crying_children",
  "mutant_count": 201,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [None] * m",
      "mutated_line": "d = [None] / m",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] / m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [None] * m",
      "mutated_line": "d = [None] + m",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] + m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [None] * m",
      "mutated_line": "d = [None] ** m",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] ** m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "location = [None] * n",
      "mutated_line": "location = [None] / n",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] / n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "location = [None] * n",
      "mutated_line": "location = [None] + n",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] + n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "location = [None] * n",
      "mutated_line": "location = [None] ** n",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] ** n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x += 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y - 1] is not None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is not None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time = 1",
      "mutated_line": "time = 2",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 2\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time = 1",
      "mutated_line": "time = 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 0\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time = 1",
      "mutated_line": "time = 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 0\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time = 1",
      "mutated_line": "time = -1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = -1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "time += 1",
      "mutated_line": "time -= 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time -= 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) >= 1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) >= 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) <= 1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) <= 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) != 1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) != 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 2\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 0\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 0\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= -1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if y is None:",
      "mutated_line": "if y is not None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is not None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x + 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x + 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x * 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x * 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x + 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x + 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x * 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x * 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "time += 1",
      "mutated_line": "time += 2",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 2\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 0\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 0\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "time += 1",
      "mutated_line": "time += -1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += -1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[0]]) != 0:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) != 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) > 2:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 2:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) > 0:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 0:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) > 0:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 0:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(stack) > 1:",
      "mutated_line": "if len(stack) > -1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > -1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "y = d[y - 1]",
      "mutated_line": "y = d[y + 1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y + 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "y = d[y - 1]",
      "mutated_line": "y = d[y * 1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y * 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None or location[y] is not None or location[x][0] == location[y][0]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None or location[y] is not None or location[x][0] == location[y][0]:\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y + 1] is None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y + 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y * 1] is None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y * 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y + 1] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y + 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y * 1] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y * 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - 2",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 2\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 0\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 0\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - -1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - -1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 1]].append(x + 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x + 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 1]].append(x * 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x * 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "roots.discard(x - 1)",
      "mutated_line": "roots.discard(x + 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x + 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "roots.discard(x - 1)",
      "mutated_line": "roots.discard(x * 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x * 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y + 1] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y + 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y * 1] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y * 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - 2",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 2\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 0\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - 0",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 0\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 1] = x - -1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - -1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "j = queue[-1]",
      "mutated_line": "j = queue[+1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[+1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[0]]) == 1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 1:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[0]]) == -1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == -1:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[0]]) == 1:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 1:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) + 1, -1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) + 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) * 1, -1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) * 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, +1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, +1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -1, +1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, +1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "app = 0",
      "mutated_line": "app = 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 1\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "app = 0",
      "mutated_line": "app = -1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = -1\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "app = 0",
      "mutated_line": "app = 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 1\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app -= stack[location[u][1]][3]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app -= stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "y = d[y - 1]",
      "mutated_line": "y = d[y - 2]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 2]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "y = d[y - 1]",
      "mutated_line": "y = d[y - 0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 0]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "y = d[y - 1]",
      "mutated_line": "y = d[y - 0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 0]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "y = d[y - 1]",
      "mutated_line": "y = d[y - -1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - -1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(1)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(-1)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(1)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is None and location[y] is not None and (location[x][0] == location[y][0]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is None and (location[x][0] == location[y][0]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][0] != location[y][0]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] != location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] or comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] or comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y - 2] is None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 2] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y - 0] is None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 0] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y - 0] is None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 0] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if d[y - 1] is None:",
      "mutated_line": "if d[y - -1] is None:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - -1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 2] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 2] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 0] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 0] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 0] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 0] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - -1] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - -1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 1]].append(x - 2)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 2)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 1]].append(x - 0)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 0)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 1]].append(x - 0)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 0)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 1]].append(x - -1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - -1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roots.discard(x - 1)",
      "mutated_line": "roots.discard(x - 2)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 2)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roots.discard(x - 1)",
      "mutated_line": "roots.discard(x - 0)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 0)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roots.discard(x - 1)",
      "mutated_line": "roots.discard(x - 0)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 0)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roots.discard(x - 1)",
      "mutated_line": "roots.discard(x - -1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - -1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 2] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 2] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 0] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 0] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - 0] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 0] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[y - 1] = x - 1",
      "mutated_line": "d[y - -1] = x - 1",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - -1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j = queue[-1]",
      "mutated_line": "j = queue[-2]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-2]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j = queue[-1]",
      "mutated_line": "j = queue[-0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-0]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j = queue[-1]",
      "mutated_line": "j = queue[-0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-0]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j = queue[-1]",
      "mutated_line": "j = queue[--1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[--1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "stack.append(queue.pop() + [time])",
      "mutated_line": "stack.append(queue.pop() - [time])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() - [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "stack.append(queue.pop() + [time])",
      "mutated_line": "stack.append(queue.pop() * [time])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() * [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 2, -1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 2, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 0, -1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 0, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 0, -1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 0, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - -1, -1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - -1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -2, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -2, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -0, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -0, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -0, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -0, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, --1, -1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, --1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -1, -2):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -2):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -1, -0):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -0):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -1, -0):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -0):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(stack) - 1, -1, -1):",
      "mutated_line": "for j in range(len(stack) - 1, -1, --1):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, --1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "stack[j].append(app + 1)",
      "mutated_line": "stack[j].append(app - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app - 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "stack[j].append(app + 1)",
      "mutated_line": "stack[j].append(app * 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app * 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "c = location[x][0]",
      "mutated_line": "c = location[x][1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][1]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "c = location[x][0]",
      "mutated_line": "c = location[x][-1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][-1]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "c = location[x][0]",
      "mutated_line": "c = location[x][1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][1]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ind_x = location[x][1]",
      "mutated_line": "ind_x = location[x][2]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][2]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ind_x = location[x][1]",
      "mutated_line": "ind_x = location[x][0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][0]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ind_x = location[x][1]",
      "mutated_line": "ind_x = location[x][0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][0]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ind_x = location[x][1]",
      "mutated_line": "ind_x = location[x][-1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][-1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ind_y = location[y][1]",
      "mutated_line": "ind_y = location[y][2]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][2]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ind_y = location[y][1]",
      "mutated_line": "ind_y = location[y][0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][0]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ind_y = location[y][1]",
      "mutated_line": "ind_y = location[y][0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][0]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ind_y = location[y][1]",
      "mutated_line": "ind_y = location[y][-1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][-1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] <= comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] <= comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] >= comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] >= comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] != comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] != comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] >= comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] >= comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] <= comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] <= comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] != comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] != comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "location[stack[j][0]] = [len(comp_of_conn), j]",
      "mutated_line": "location[stack[j][1]] = [len(comp_of_conn), j]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][1]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "location[stack[j][0]] = [len(comp_of_conn), j]",
      "mutated_line": "location[stack[j][-1]] = [len(comp_of_conn), j]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][-1]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "location[stack[j][0]] = [len(comp_of_conn), j]",
      "mutated_line": "location[stack[j][1]] = [len(comp_of_conn), j]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][1]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for u in matrix[stack[j][0]]:",
      "mutated_line": "for u in matrix[stack[j][1]]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][1]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for u in matrix[stack[j][0]]:",
      "mutated_line": "for u in matrix[stack[j][-1]]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][-1]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for u in matrix[stack[j][0]]:",
      "mutated_line": "for u in matrix[stack[j][1]]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][1]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][1]][4]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][4]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][1]][2]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][2]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][1]][0]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][0]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][1]][1]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][1]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][1]][-3]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][-3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "stack[j].append(app + 1)",
      "mutated_line": "stack[j].append(app + 2)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 2)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "stack[j].append(app + 1)",
      "mutated_line": "stack[j].append(app + 0)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 0)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "stack[j].append(app + 1)",
      "mutated_line": "stack[j].append(app + 0)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 0)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "stack[j].append(app + 1)",
      "mutated_line": "stack[j].append(app + -1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + -1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][1] == location[y][0]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][1] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][-1] == location[y][0]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][-1] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][1] == location[y][0]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][1] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][1]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][1]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][-1]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][-1]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:",
      "mutated_line": "elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][1]):",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][1]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(1)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(-1)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(1)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y + 1]].append(x - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y + 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y * 1]].append(x - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y * 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[1]]) == 0:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[1]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[-1]]) == 0:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[-1]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(graph[j[0]]) == 0:",
      "mutated_line": "if len(graph[j[1]]) == 0:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[1]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][2] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][2] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][0] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][0] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][0] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][0] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][-1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][-1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][2] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][2] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][0] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][0] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][0] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][0] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][-1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][-1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][3] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][3] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][1] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][1] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][0] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][0] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][1] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][1] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][-2] > comp_of_conn[c][ind_y][2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][-2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][3]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][3]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][1]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][1]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][0]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][0]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][1]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][1]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:",
      "mutated_line": "if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][-2]:",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][-2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append(comp_of_conn[c][ind_x][3])",
      "mutated_line": "results.append(comp_of_conn[c][ind_x][4])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][4])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append(comp_of_conn[c][ind_x][3])",
      "mutated_line": "results.append(comp_of_conn[c][ind_x][2])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][2])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append(comp_of_conn[c][ind_x][3])",
      "mutated_line": "results.append(comp_of_conn[c][ind_x][0])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][0])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append(comp_of_conn[c][ind_x][3])",
      "mutated_line": "results.append(comp_of_conn[c][ind_x][1])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][1])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append(comp_of_conn[c][ind_x][3])",
      "mutated_line": "results.append(comp_of_conn[c][ind_x][-3])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][-3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 2]].append(x - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 2]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 0]].append(x - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 0]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - 0]].append(x - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 0]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "matrix[d[y - 1]].append(x - 1)",
      "mutated_line": "matrix[d[y - -1]].append(x - 1)",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - -1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][2]][3]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][2]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][0]][3]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][0]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][0]][3]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][0]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "app += stack[location[u][1]][3]",
      "mutated_line": "app += stack[location[u][-1]][3]",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[0]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][-1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "queue.append([graph[j[0]].pop(), time])",
      "mutated_line": "queue.append([graph[j[1]].pop(), time])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[1]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "queue.append([graph[j[0]].pop(), time])",
      "mutated_line": "queue.append([graph[j[-1]].pop(), time])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[-1]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "queue.append([graph[j[0]].pop(), time])",
      "mutated_line": "queue.append([graph[j[1]].pop(), time])",
      "code": "def find_crying_children(n, m, k, q, scenario_requests, queries):\n    d = [None] * m\n    roots = set(range(n))\n    matrix = [[] for _ in range(n)]\n    for (x, y) in scenario_requests:\n        if d[y - 1] is None:\n            d[y - 1] = x - 1\n        else:\n            matrix[d[y - 1]].append(x - 1)\n            roots.discard(x - 1)\n            d[y - 1] = x - 1\n    location = [None] * n\n    comp_of_conn = []\n    graph = [matrix[i][:] for i in range(n)]\n    for i in roots:\n        stack = []\n        time = 1\n        queue = [[i, time]]\n        while queue:\n            j = queue[-1]\n            time += 1\n            if len(graph[j[0]]) == 0:\n                stack.append(queue.pop() + [time])\n            else:\n                queue.append([graph[j[1]].pop(), time])\n        stack.reverse()\n        if len(stack) > 1:\n            for j in range(len(stack)):\n                location[stack[j][0]] = [len(comp_of_conn), j]\n            for j in range(len(stack) - 1, -1, -1):\n                app = 0\n                for u in matrix[stack[j][0]]:\n                    app += stack[location[u][1]][3]\n                stack[j].append(app + 1)\n            comp_of_conn.append(stack)\n    results = []\n    for (x, y) in queries:\n        x -= 1\n        y = d[y - 1]\n        if y is None:\n            results.append(0)\n        elif location[x] is not None and location[y] is not None and (location[x][0] == location[y][0]):\n            c = location[x][0]\n            ind_x = location[x][1]\n            ind_y = location[y][1]\n            if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][2]:\n                results.append(comp_of_conn[c][ind_x][3])\n            else:\n                results.append(0)\n        else:\n            results.append(0)\n    return results"
    }
  ]
}