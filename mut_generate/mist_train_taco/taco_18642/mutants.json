{
  "task_id": "taco_18642",
  "entry_point": "min_possible_frequency",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(frequency_counts) == 1:",
      "mutated_line": "if len(frequency_counts) != 1:",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) != 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(frequency_counts) == 1:",
      "mutated_line": "if len(frequency_counts) == 2:",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 2:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(frequency_counts) == 1:",
      "mutated_line": "if len(frequency_counts) == 0:",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 0:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(frequency_counts) == 1:",
      "mutated_line": "if len(frequency_counts) == 0:",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 0:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(frequency_counts) == 1:",
      "mutated_line": "if len(frequency_counts) == -1:",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == -1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] * 2)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] * 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] // 2)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] // 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] * 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] * 2), frequency_counts[-2])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] // 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] // 2), frequency_counts[-2])"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[+2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[+2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] / 3)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 3)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] / 1)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 1)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] / 0)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 0)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] / 1)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 1)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[0] / -2)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / -2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 3), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 3), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 1), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 1), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 0), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 0), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 1), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 1), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / -2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / -2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-3])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-3])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-1])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-0])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-1])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[--2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[--2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[1] / 2)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[1] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[-1] / 2)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[-1] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return ceil(frequency_counts[0] / 2)",
      "mutated_line": "return ceil(frequency_counts[1] / 2)",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[1] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[+1] / 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[+1] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-2] / 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-2] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-0] / 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-0] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[-0] / 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[-0] / 2), frequency_counts[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return max(ceil(frequency_counts[-1] / 2), frequency_counts[-2])",
      "mutated_line": "return max(ceil(frequency_counts[--1] / 2), frequency_counts[-2])",
      "code": "from collections import Counter\nfrom math import ceil\n\ndef min_possible_frequency(arr):\n    frequency_counts = list(Counter(arr).values())\n    if len(frequency_counts) == 1:\n        return ceil(frequency_counts[0] / 2)\n    frequency_counts.sort()\n    return max(ceil(frequency_counts[--1] / 2), frequency_counts[-2])"
    }
  ]
}