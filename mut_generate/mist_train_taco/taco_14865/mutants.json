{
  "task_id": "taco_14865",
  "entry_point": "bootstrap",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] / (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] / (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] + (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] + (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] ** (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] ** (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] / (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] / (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] + (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] + (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] ** (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] ** (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n - 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n - 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n * 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n * 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] * (n - 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n - 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] * (n * 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n * 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "dp[node] -= max(0, dp[nex])",
      "mutated_line": "dp[node] += max(0, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] += max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "dp[nex] += max(0, dp[node])",
      "mutated_line": "dp[nex] -= max(0, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] -= max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "dp[nex] -= max(0, dp[node])",
      "mutated_line": "dp[nex] += max(0, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] += max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "dp[node] += max(0, dp[nex])",
      "mutated_line": "dp[node] -= max(0, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] -= max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(2, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(2, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(0, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(0, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(0, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(0, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(-1, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(-1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(1, 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 1)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(1, -1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, -1)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs1(1, 0)",
      "mutated_line": "dfs1(1, 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 1)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(2, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(2, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(0, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(0, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(0, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(0, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(-1, 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(-1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(1, 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 1)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(1, -1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, -1)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "dfs2(1, 0)",
      "mutated_line": "dfs2(1, 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 1)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while False:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [1] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [-1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [-1] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [1] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 2)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 2)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 0)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 0)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + -1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + -1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [1] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [-1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [-1] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [1] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] * (n + 2)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 2)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] * (n + 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 0)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] * (n + 0)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 0)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = [0] * (n + 1)",
      "mutated_line": "ret = [0] * (n + -1)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + -1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] != 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] != 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else +1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else +1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if nex == par:",
      "mutated_line": "if nex != par:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex != par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dp[nex] > 0:",
      "mutated_line": "if dp[nex] >= 0:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] >= 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dp[nex] > 0:",
      "mutated_line": "if dp[nex] <= 0:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] <= 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dp[nex] > 0:",
      "mutated_line": "if dp[nex] != 0:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] != 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "dp[node] += dp[nex]",
      "mutated_line": "dp[node] -= dp[nex]",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] -= dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if nex == par:",
      "mutated_line": "if nex != par:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex != par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return ret[1:]",
      "mutated_line": "return ret[2:]",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return ret[1:]",
      "mutated_line": "return ret[0:]",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return ret[1:]",
      "mutated_line": "return ret[0:]",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return ret[1:]",
      "mutated_line": "return ret[-1:]",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[-1:]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if type(to) is GeneratorType:",
      "mutated_line": "if type(to) is not GeneratorType:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is not GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 2 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 2 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 0 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 0 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 0 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 0 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == -1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == -1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node + 1] if colors[node - 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node + 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node * 1] if colors[node - 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node * 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -2",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -2\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -0",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -0\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -0",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -0\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else --1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else --1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if dp[nex] > 0:",
      "mutated_line": "if dp[nex] > 1:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 1:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if dp[nex] > 0:",
      "mutated_line": "if dp[nex] > -1:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > -1:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if dp[nex] > 0:",
      "mutated_line": "if dp[nex] > 1:",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 1:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[node] -= max(0, dp[nex])",
      "mutated_line": "dp[node] -= max(1, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(1, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[node] -= max(0, dp[nex])",
      "mutated_line": "dp[node] -= max(-1, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(-1, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "dp[node] -= max(0, dp[nex])",
      "mutated_line": "dp[node] -= max(1, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(1, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[nex] += max(0, dp[node])",
      "mutated_line": "dp[nex] += max(1, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(1, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[nex] += max(0, dp[node])",
      "mutated_line": "dp[nex] += max(-1, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(-1, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[nex] += max(0, dp[node])",
      "mutated_line": "dp[nex] += max(1, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(1, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "dp[nex] -= max(0, dp[node])",
      "mutated_line": "dp[nex] -= max(1, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(1, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "dp[nex] -= max(0, dp[node])",
      "mutated_line": "dp[nex] -= max(-1, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(-1, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "dp[nex] -= max(0, dp[node])",
      "mutated_line": "dp[nex] -= max(1, dp[node])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(1, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[node] += max(0, dp[nex])",
      "mutated_line": "dp[node] += max(1, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(1, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[node] += max(0, dp[nex])",
      "mutated_line": "dp[node] += max(-1, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(-1, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dp[node] += max(0, dp[nex])",
      "mutated_line": "dp[node] += max(1, dp[nex])",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(1, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node + 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node + 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node * 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node * 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 2] if colors[node - 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 2] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 0] if colors[node - 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 0] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 0] if colors[node - 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 0] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - -1] if colors[node - 1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - -1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 2] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 2] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 0] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 0] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - 0] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 0] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1",
      "mutated_line": "dp[node] = colors[node - 1] if colors[node - -1] == 1 else -1",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - -1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "to = stack[-1].send(to)",
      "mutated_line": "to = stack[+1].send(to)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[+1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to = stack[-1].send(to)",
      "mutated_line": "to = stack[-2].send(to)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-2].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to = stack[-1].send(to)",
      "mutated_line": "to = stack[-0].send(to)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-0].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to = stack[-1].send(to)",
      "mutated_line": "to = stack[-0].send(to)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-0].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to = stack[-1].send(to)",
      "mutated_line": "to = stack[--1].send(to)",
      "code": "from collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[--1].send(to)\n            return to\n    return wrappedfunc\n\ndef max_subtree_difference(n, colors, edges):\n    gp = defaultdict(list)\n    for (u, v) in edges:\n        gp[u].append(v)\n        gp[v].append(u)\n    dp = [0] * (n + 1)\n    ret = [0] * (n + 1)\n\n    @bootstrap\n    def dfs1(node, par):\n        dp[node] = colors[node - 1] if colors[node - 1] == 1 else -1\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            yield dfs1(nex, node)\n            if dp[nex] > 0:\n                dp[node] += dp[nex]\n        yield None\n\n    @bootstrap\n    def dfs2(node, par):\n        ret[node] = dp[node]\n        for nex in gp[node]:\n            if nex == par:\n                continue\n            dp[node] -= max(0, dp[nex])\n            dp[nex] += max(0, dp[node])\n            yield dfs2(nex, node)\n            dp[nex] -= max(0, dp[node])\n            dp[node] += max(0, dp[nex])\n        yield None\n    dfs1(1, 0)\n    dfs2(1, 0)\n    return ret[1:]"
    }
  ]
}