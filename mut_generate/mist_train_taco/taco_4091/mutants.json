{
  "task_id": "taco_4091",
  "entry_point": "calculate_path_value",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n + 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n * 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s_stored[s_vertex][0] = True",
      "mutated_line": "s_stored[s_vertex][0] = False",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = False\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "s_stored[s_vertex][s_cost] = True",
      "mutated_line": "s_stored[s_vertex][s_cost] = False",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = False\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 2):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 0):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 0):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - -1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edge_set[edges[i]].append(i + 1)",
      "mutated_line": "edge_set[edges[i]].append(i - 1)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i - 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edge_set[edges[i]].append(i + 1)",
      "mutated_line": "edge_set[edges[i]].append(i * 1)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i * 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stored = np.zeros((s, n, 1001), dtype=bool)",
      "mutated_line": "stored = np.zeros((s, n, 1002), dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1002), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stored = np.zeros((s, n, 1001), dtype=bool)",
      "mutated_line": "stored = np.zeros((s, n, 1000), dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1000), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stored = np.zeros((s, n, 1001), dtype=bool)",
      "mutated_line": "stored = np.zeros((s, n, 0), dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 0), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stored = np.zeros((s, n, 1001), dtype=bool)",
      "mutated_line": "stored = np.zeros((s, n, 1), dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stored = np.zeros((s, n, 1001), dtype=bool)",
      "mutated_line": "stored = np.zeros((s, n, -1001), dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, -1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s_stored[s_vertex][0] = True",
      "mutated_line": "s_stored[s_vertex][1] = True",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][1] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s_stored[s_vertex][0] = True",
      "mutated_line": "s_stored[s_vertex][-1] = True",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][-1] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s_stored[s_vertex][0] = True",
      "mutated_line": "s_stored[s_vertex][1] = True",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][1] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(2, n):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(2, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(0, n):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(0, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(0, n):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(0, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(-1, n):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(-1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost - 2, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost - 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost * 2, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost * 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost - 1, -1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost - 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost * 1, -1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost * 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, +1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, +1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -1, +1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, +1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge_set[edges[i]].append(i + 1)",
      "mutated_line": "edge_set[edges[i]].append(i + 2)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 2)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge_set[edges[i]].append(i + 1)",
      "mutated_line": "edge_set[edges[i]].append(i + 0)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 0)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge_set[edges[i]].append(i + 1)",
      "mutated_line": "edge_set[edges[i]].append(i + 0)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 0)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge_set[edges[i]].append(i + 1)",
      "mutated_line": "edge_set[edges[i]].append(i + -1)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + -1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if edge not in s_visited:",
      "mutated_line": "if edge in s_visited:",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost + 3, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 3, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost + 1, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 1, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost + 0, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 0, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost + 1, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 1, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bool_array = np.zeros(max_cost + 2, dtype=bool)",
      "mutated_line": "bool_array = np.zeros(max_cost + -2, dtype=bool)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + -2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 2, -1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 2, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 0, -1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 0, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 0, -1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 0, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + -1, -1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + -1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -2, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -2, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -0, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -0, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -0, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -0, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, --1, -1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, --1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -1, -2):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -2):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -1, -0):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -0):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -1, -0):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -0):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(max_cost + 1, -1, -1):",
      "mutated_line": "for j in range(max_cost + 1, -1, --1):",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, --1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "edge_set[i + 1].append(edges[i])",
      "mutated_line": "edge_set[i - 1].append(edges[i])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i - 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "edge_set[i + 1].append(edges[i])",
      "mutated_line": "edge_set[i * 1].append(edges[i])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i * 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1002] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1002] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1000] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1000] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:0] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:0] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:-1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:-1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(2 / j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 / j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(2 + j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 + j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(2 ** j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 ** j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "edge_set[i + 1].append(edges[i])",
      "mutated_line": "edge_set[i + 2].append(edges[i])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 2].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "edge_set[i + 1].append(edges[i])",
      "mutated_line": "edge_set[i + 0].append(edges[i])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 0].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "edge_set[i + 1].append(edges[i])",
      "mutated_line": "edge_set[i + 0].append(edges[i])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 0].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "edge_set[i + 1].append(edges[i])",
      "mutated_line": "edge_set[i + -1].append(edges[i])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + -1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][1:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][1:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][-1:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][-1:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][1:1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][1:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 + cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 + cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 * cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 * cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1002])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1002])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1000])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1000])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:0])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:0])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:-1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:-1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(3 * j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(3 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(1 * j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(1 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(0 * j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(0 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(1 * j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(1 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(2 * j)",
      "mutated_line": "results.append(-2 * j)",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(-2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1002 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1002 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1000 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1000 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:0 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:0 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])",
      "mutated_line": "s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:-1001 - cost], s_stored[vertex][cost:1001])",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:-1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost - 2], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost - 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost * 2], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost * 2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost - 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost - 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost * 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost * 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 3], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 3], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 1], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 1], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 0], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 0], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 1], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 1], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + -2], stored[j][second][:max_cost + 2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + -2], stored[j][second][:max_cost + 2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 3]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 3]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 1]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 1]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 0]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 0]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 1]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 1]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + 2]))",
      "mutated_line": "bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + -2]))",
      "code": "import numpy as np\n\ndef calculate_path_value(n, s, q, edges, costs, special, queries):\n    edge_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        edge_set[i + 1].append(edges[i])\n        edge_set[edges[i]].append(i + 1)\n    stored = np.zeros((s, n, 1001), dtype=bool)\n    visited = [[] for _ in range(s)]\n    for i in range(s):\n        s_vertex = special[i]\n        s_cost = costs[s_vertex]\n        s_visited = visited[i]\n        s_visited.append(s_vertex)\n        s_stored = stored[i]\n        s_stored[s_vertex][0] = True\n        s_stored[s_vertex][s_cost] = True\n        for edge in edge_set[s_vertex]:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[s_vertex])\n        for j in range(1, n):\n            vertex = s_visited[j]\n            cost = costs[vertex]\n            s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001 - cost], s_stored[vertex][cost:1001])\n            for edge in edge_set[vertex]:\n                if edge not in s_visited:\n                    s_visited.append(edge)\n                    s_stored[edge] = np.array(s_stored[vertex])\n    results = []\n    for i in range(q):\n        (first, second, max_cost) = queries[i]\n        bool_array = np.zeros(max_cost + 2, dtype=bool)\n        for j in range(s):\n            bool_array = np.logical_or(bool_array, np.logical_and(stored[j][first][:max_cost + 2], stored[j][second][:max_cost + -2]))\n        for j in range(max_cost + 1, -1, -1):\n            if bool_array[j]:\n                results.append(2 * j)\n                break\n    return results"
    }
  ]
}