{
  "task_id": "taco_14994",
  "entry_point": "can_tile_hexagonal_grid",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while index[0] < n:",
      "mutated_line": "while index[0] <= n:",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] <= n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while index[0] < n:",
      "mutated_line": "while index[0] >= n:",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] >= n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while index[0] < n:",
      "mutated_line": "while index[0] != n:",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] != n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[0] <= len(board[0])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] <= len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[0] >= len(board[0])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] >= len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[0] != len(board[0])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] != len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "index = [0, 0]",
      "mutated_line": "index = [1, 0]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [1, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "index = [0, 0]",
      "mutated_line": "index = [-1, 0]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [-1, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "index = [0, 0]",
      "mutated_line": "index = [1, 0]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [1, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "index = [0, 0]",
      "mutated_line": "index = [0, 1]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 1]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "index = [0, 0]",
      "mutated_line": "index = [0, -1]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, -1]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "index = [0, 0]",
      "mutated_line": "index = [0, 1]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 1]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[1]][index[0]] != '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] != '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[1]][index1[0]] != '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] != '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[1]][index2[0]] != '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] != '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return True\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] - index[1], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] - index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] * index[1], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] * index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 1) * 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) * 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], index[1] + 1 + 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], index[1] + 1 + 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while index[0] < n:",
      "mutated_line": "while index[1] < n:",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[1] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while index[0] < n:",
      "mutated_line": "while index[-1] < n:",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[-1] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while index[0] < n:",
      "mutated_line": "while index[1] < n:",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[1] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[1]][index[0]] == '':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return True\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[1]][index1[0]] == '':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return True\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[1]][index2[0]] == '':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] - 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] - 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], index[1] * 1 % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], index[1] * 1 % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 1) % 3]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 3]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 1) % 1]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 1]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 1) % 0]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 0]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 1) % 1]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 1]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 1) % -2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % -2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[1] < len(board[0])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[1] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[-1] < len(board[0])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[-1] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[1] < len(board[0])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[1] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[1] + index[1], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[1] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[-1] + index[1], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[-1] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[1] + index[1], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[1] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[2], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[2], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[0], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[0], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[0], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[0], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[-1], (index[1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[-1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 2) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 2) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 0) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 0) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + 0) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 0) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[1] + -1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + -1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[0] < len(board[1])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[1])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[0] < len(board[-1])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[-1])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return index[0] < len(board[0])",
      "mutated_line": "return index[0] < len(board[1])",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[1])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[1]][index[1]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[1]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[1]][index[-1]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[-1]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[1]][index[1]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[1]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[1]][index1[1]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[1]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[1]][index1[-1]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[-1]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[1]][index1[1]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[1]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[1]][index2[1]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[1]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[1]][index2[-1]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[-1]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[1]][index2[1]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[1]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[2] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[2] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[0] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[0] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[0] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[0] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return [index[0] + index[1], (index[1] + 1) % 2]",
      "mutated_line": "return [index[0] + index[1], (index[-1] + 1) % 2]",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[-1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[2]][index[0]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[2]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[0]][index[0]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[0]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[0]][index[0]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[0]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if board[index[1]][index[0]] == '1':",
      "mutated_line": "if board[index[-1]][index[0]] == '1':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[-1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[2]][index1[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[2]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[0]][index1[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[0]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[0]][index1[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[0]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if board[index1[1]][index1[0]] == '0':",
      "mutated_line": "if board[index1[-1]][index1[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[-1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[2]][index2[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[2]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[0]][index2[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[0]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[0]][index2[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[0]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if board[index2[1]][index2[0]] == '0':",
      "mutated_line": "if board[index2[-1]][index2[0]] == '0':",
      "code": "def can_tile_hexagonal_grid(n, line1, line2):\n\n    def next_index(index):\n        return [index[0] + index[1], (index[1] + 1) % 2]\n\n    def on_board(index, board):\n        return index[0] < len(board[0])\n    board = [line1, line2]\n    index = [0, 0]\n    while index[0] < n:\n        if board[index[1]][index[0]] == '1':\n            index = next_index(index)\n            continue\n        index1 = next_index(index)\n        if not on_board(index1, board):\n            return False\n        if board[index1[1]][index1[0]] == '0':\n            index = next_index(index1)\n            continue\n        index2 = next_index(index1)\n        if not on_board(index2, board):\n            return False\n        if board[index2[-1]][index2[0]] == '0':\n            index = next_index(index2)\n            continue\n        return False\n    return True"
    }
  ]
}