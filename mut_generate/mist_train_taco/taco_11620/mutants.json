{
  "task_id": "taco_11620",
  "entry_point": "calculate_widest_mobile",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if key in rec:",
      "mutated_line": "if key not in rec:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key not in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "edge_set = dfs(0, stones)",
      "mutated_line": "edge_set = dfs(1, stones)",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(1, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "edge_set = dfs(0, stones)",
      "mutated_line": "edge_set = dfs(-1, stones)",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(-1, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "edge_set = dfs(0, stones)",
      "mutated_line": "edge_set = dfs(1, stones)",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(1, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(stones)):",
      "mutated_line": "for i in range(2, len(stones)):",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(2, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(stones)):",
      "mutated_line": "for i in range(0, len(stones)):",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(0, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(stones)):",
      "mutated_line": "for i in range(0, len(stones)):",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(0, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(stones)):",
      "mutated_line": "for i in range(-1, len(stones)):",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(-1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return +1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "w = w1 + w2",
      "mutated_line": "w = w1 - w2",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 - w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "w = w1 + w2",
      "mutated_line": "w = w1 * w2",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 * w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "b1 = base - w2 / w",
      "mutated_line": "b1 = base + w2 / w",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base + w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "b1 = base - w2 / w",
      "mutated_line": "b1 = base * (w2 / w)",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base * (w2 / w)\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b2 = base + w1 / w",
      "mutated_line": "b2 = base - w1 / w",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base - w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b2 = base + w1 / w",
      "mutated_line": "b2 = base * (w1 / w)",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base * (w1 / w)\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "rec[stone,] = {(0, 0)}",
      "mutated_line": "rec[stone,] = {(1, 0)}",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(1, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "rec[stone,] = {(0, 0)}",
      "mutated_line": "rec[stone,] = {(-1, 0)}",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(-1, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "rec[stone,] = {(0, 0)}",
      "mutated_line": "rec[stone,] = {(1, 0)}",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(1, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "rec[stone,] = {(0, 0)}",
      "mutated_line": "rec[stone,] = {(0, 1)}",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 1)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "rec[stone,] = {(0, 0)}",
      "mutated_line": "rec[stone,] = {(0, -1)}",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, -1)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "rec[stone,] = {(0, 0)}",
      "mutated_line": "rec[stone,] = {(0, 1)}",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 1)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b + a for (a, b) in edge_set if b - a < room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b + a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b * a for (a, b) in edge_set if b - a < room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b * a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return --1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "b1 = base - w2 / w",
      "mutated_line": "b1 = base - w2 * w",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 * w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "b1 = base - w2 / w",
      "mutated_line": "b1 = base - w2 // w",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 // w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b2 = base + w1 / w",
      "mutated_line": "b2 = base + w1 * w",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 * w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b2 = base + w1 / w",
      "mutated_line": "b2 = base + w1 // w",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 // w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b - a for (a, b) in edge_set if b - a <= room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a <= room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b - a for (a, b) in edge_set if b - a >= room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a >= room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b - a for (a, b) in edge_set if b - a != room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a != room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return set(((base + l, base + r) for (l, r) in rec[key]))",
      "mutated_line": "return set(((base - l, base + r) for (l, r) in rec[key]))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base - l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return set(((base + l, base + r) for (l, r) in rec[key]))",
      "mutated_line": "return set(((base * l, base + r) for (l, r) in rec[key]))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base * l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return set(((base + l, base + r) for (l, r) in rec[key]))",
      "mutated_line": "return set(((base + l, base - r) for (l, r) in rec[key]))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base - r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return set(((base + l, base + r) for (l, r) in rec[key]))",
      "mutated_line": "return set(((base + l, base * r) for (l, r) in rec[key]))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base * r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if ll < rl:",
      "mutated_line": "if ll <= rl:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll <= rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if ll < rl:",
      "mutated_line": "if ll >= rl:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll >= rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if ll < rl:",
      "mutated_line": "if ll != rl:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll != rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if lr < rr:",
      "mutated_line": "if lr <= rr:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr <= rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if lr < rr:",
      "mutated_line": "if lr >= rr:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr >= rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if lr < rr:",
      "mutated_line": "if lr != rr:",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr != rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b - a for (a, b) in edge_set if b + a < room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b + a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans = max((b - a for (a, b) in edge_set if b - a < room_width))",
      "mutated_line": "ans = max((b - a for (a, b) in edge_set if b * a < room_width))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b * a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "edges.add((l - base, r - base))",
      "mutated_line": "edges.add((l + base, r - base))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l + base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "edges.add((l - base, r - base))",
      "mutated_line": "edges.add((l * base, r - base))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l * base, r - base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "edges.add((l - base, r - base))",
      "mutated_line": "edges.add((l - base, r + base))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r + base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "edges.add((l - base, r - base))",
      "mutated_line": "edges.add((l - base, r * base))",
      "code": "from itertools import combinations\n\ndef calculate_widest_mobile(room_width, stone_weights):\n\n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set(((base + l, base + r) for (l, r) in rec[key]))\n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                for (ll, lr) in left_tree_ends:\n                    for (rl, rr) in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r * base))\n                        positions.add((l, r))\n        rec[key] = edges\n        return positions\n    rec = dict()\n    stones = sorted(stone_weights)\n    for stone in stones:\n        rec[stone,] = {(0, 0)}\n    edge_set = dfs(0, stones)\n    try:\n        ans = max((b - a for (a, b) in edge_set if b - a < room_width))\n        return ans\n    except ValueError:\n        return -1"
    }
  ]
}