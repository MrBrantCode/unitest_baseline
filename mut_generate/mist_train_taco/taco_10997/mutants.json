{
  "task_id": "taco_10997",
  "entry_point": "minimize_lexicographically",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k > 25:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k > 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k < 25:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k < 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k == 25:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k == 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k >= 26:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 26:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k >= 24:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 24:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k >= 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 0:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k >= 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 1:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k >= 25:",
      "mutated_line": "if k >= -25:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= -25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return 'a' * len(s)",
      "mutated_line": "return 'a' / len(s)",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' / len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return 'a' * len(s)",
      "mutated_line": "return 'a' + len(s)",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' + len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return 'a' * len(s)",
      "mutated_line": "return 'a' ** len(s)",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' ** len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "bottom = ord('a')",
      "mutated_line": "bottom = ord('')",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k != 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "distance = character_order - bottom",
      "mutated_line": "distance = character_order + bottom",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order + bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "distance = character_order - bottom",
      "mutated_line": "distance = character_order * bottom",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order * bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if distance <= 0:",
      "mutated_line": "if distance < 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance < 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if distance <= 0:",
      "mutated_line": "if distance > 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance > 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if distance <= 0:",
      "mutated_line": "if distance == 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance == 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if distance <= k:",
      "mutated_line": "if distance < k:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance < k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if distance <= k:",
      "mutated_line": "if distance > k:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance > k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if distance <= k:",
      "mutated_line": "if distance == k:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance == k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "k -= distance",
      "mutated_line": "k += distance",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k += distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "for character_order in range(bottom, ord('a'), -1):",
      "mutated_line": "for character_order in range(bottom, ord('a'), +1):",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), +1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 'a' * len(s)",
      "mutated_line": "return '' * len(s)",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return '' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 1:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == -1:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 1:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if distance <= 0:",
      "mutated_line": "if distance <= 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 1:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if distance <= 0:",
      "mutated_line": "if distance <= -1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= -1:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if distance <= 0:",
      "mutated_line": "if distance <= 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 1:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while k > 0:",
      "mutated_line": "while k >= 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k >= 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while k > 0:",
      "mutated_line": "while k <= 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k <= 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while k > 0:",
      "mutated_line": "while k != 0:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k != 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k += 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for character_order in range(bottom, ord('a'), -1):",
      "mutated_line": "for character_order in range(bottom, ord(''), -1):",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord(''), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for character_order in range(bottom, ord('a'), -1):",
      "mutated_line": "for character_order in range(bottom, ord('a'), -2):",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -2):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for character_order in range(bottom, ord('a'), -1):",
      "mutated_line": "for character_order in range(bottom, ord('a'), -0):",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -0):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for character_order in range(bottom, ord('a'), -1):",
      "mutated_line": "for character_order in range(bottom, ord('a'), -0):",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -0):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for character_order in range(bottom, ord('a'), -1):",
      "mutated_line": "for character_order in range(bottom, ord('a'), --1):",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), --1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "s = s.replace(character, 'a')",
      "mutated_line": "s = s.replace(character, '')",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, '')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 1:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while k > 0:",
      "mutated_line": "while k > -1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > -1:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 1:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "next_character_order = character_order - 1",
      "mutated_line": "next_character_order = character_order + 1",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order + 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "next_character_order = character_order - 1",
      "mutated_line": "next_character_order = character_order * 1",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order * 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 2\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 0\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 0\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= -1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_character_order = character_order - 1",
      "mutated_line": "next_character_order = character_order - 2",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 2\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_character_order = character_order - 1",
      "mutated_line": "next_character_order = character_order - 0",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 0\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_character_order = character_order - 1",
      "mutated_line": "next_character_order = character_order - 0",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - 0\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_character_order = character_order - 1",
      "mutated_line": "next_character_order = character_order - -1",
      "code": "def minimize_lexicographically(s: str, k: int) -> str:\n    \"\"\"\n    Given a string `s` of lowercase Latin letters and an integer `k`,\n    this function returns the lexicographically minimal string that can\n    be obtained by performing no more than `k` operations.\n\n    Each operation consists of selecting a character that occurs at least\n    once in the string and replacing all such characters with the previous\n    one in alphabetical order (looping around from 'a' to 'z').\n\n    Parameters:\n    - s (str): The input string of lowercase Latin letters.\n    - k (int): The maximum number of operations allowed.\n\n    Returns:\n    - str: The lexicographically minimal string after performing the operations.\n    \"\"\"\n    if k >= 25:\n        return 'a' * len(s)\n    bottom = ord('a')\n    for character in s:\n        if k == 0:\n            break\n        character_order = ord(character)\n        distance = character_order - bottom\n        if distance <= 0:\n            continue\n        if distance <= k:\n            k -= distance\n            bottom = character_order\n        else:\n            while k > 0:\n                next_character_order = character_order - -1\n                next_character = chr(next_character_order)\n                s = s.replace(character, next_character)\n                character_order = next_character_order\n                character = next_character\n                k -= 1\n    for character_order in range(bottom, ord('a'), -1):\n        character = chr(character_order)\n        s = s.replace(character, 'a')\n    return s"
    }
  ]
}