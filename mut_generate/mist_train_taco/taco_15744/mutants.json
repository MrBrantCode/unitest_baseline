{
  "task_id": "taco_15744",
  "entry_point": "calculate_remainder",
  "mutant_count": 226,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 - 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 - 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 * 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 * 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 1\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = -1\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 1\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if a != b:",
      "mutated_line": "if a == b:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a == b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "s *= pow_mod(a, n, p)",
      "mutated_line": "s /= pow_mod(a, n, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s /= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 * 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 * 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 + 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 + 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 + 10",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 10\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 + 8",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 8\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 + 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 0\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 + 1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 1\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 9 + -9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + -9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "number = 1",
      "mutated_line": "number = 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 2\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "number = 1",
      "mutated_line": "number = 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 0\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "number = 1",
      "mutated_line": "number = 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 0\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "number = 1",
      "mutated_line": "number = -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = -1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number % p",
      "mutated_line": "return number * p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number * p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return number % p",
      "mutated_line": "return number + p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number + p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if 1 <= x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 <= x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if 1 >= x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 >= x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if 1 != x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 != x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 2\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 0\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 0\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return -1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 2\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 0\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 0\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = -1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) != 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) != 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i -= 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return i - 1",
      "mutated_line": "return i + 1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i + 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return i - 1",
      "mutated_line": "return i * 1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i * 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "vp = p ** v(p, a, b, k)",
      "mutated_line": "vp = p * v(p, a, b, k)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p * v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "vp = p ** v(p, a, b, k)",
      "mutated_line": "vp = p + v(p, a, b, k)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p + v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp / inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp / inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp + inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp + inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = ((pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp) ** inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = ((pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp) ** inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pb = 1",
      "mutated_line": "pb = 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 2\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pb = 1",
      "mutated_line": "pb = 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 0\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pb = 1",
      "mutated_line": "pb = 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 0\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pb = 1",
      "mutated_line": "pb = -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = -1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s -= S[i] * pa * pb * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s -= S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s -= S[i] * (n + 1) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s -= S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 11 ** 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 11 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 9 ** 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 9 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 0 ** 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 0 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 1 ** 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 1 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = -10 ** 9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = -10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 10 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 10 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 8 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 8 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 0 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 0 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** 1 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 1 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p = 10**9 + 9",
      "mutated_line": "p = 10 ** -9 + 9",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** -9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char != '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [2 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [0 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [0 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [-1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else +1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if y & 1:",
      "mutated_line": "if y | 1:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y | 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y >>= 1",
      "mutated_line": "y >>= 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 2\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y >>= 1",
      "mutated_line": "y >>= 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 0\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y >>= 1",
      "mutated_line": "y >>= 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 0\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y >>= 1",
      "mutated_line": "y >>= -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= -1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x * x * p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x * p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x * x + p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x + p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if 2 < x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 2 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if 0 < x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 0 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if 0 < x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 0 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 1 < x:",
      "mutated_line": "if -1 < x:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if -1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p + inv(p % x, x) * p // x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p + inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p * (inv(p % x, x) * p // x)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p * (inv(p % x, x) * p // x)\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) + pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) + pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) * pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) * pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 1:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 1:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == -1:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == -1:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 1:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 1:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 2\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 0\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 0\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += -1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i - 1",
      "mutated_line": "return i - 2",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 2\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i - 1",
      "mutated_line": "return i - 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 0\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i - 1",
      "mutated_line": "return i - 0",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 0\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i - 1",
      "mutated_line": "return i - -1",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - -1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) / vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) / vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) * vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) * vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "pa = pow_mod(a, k - 1, p)",
      "mutated_line": "pa = pow_mod(a, k + 1, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k + 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "pa = pow_mod(a, k - 1, p)",
      "mutated_line": "pa = pow_mod(a, k * 1, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k * 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += S[i] * pa * pb * sum_mod * p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod * p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += S[i] * pa * pb * sum_mod + p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod + p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "pa = pa * inv_a % p",
      "mutated_line": "pa = pa * inv_a * p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a * p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "pa = pa * inv_a % p",
      "mutated_line": "pa = pa * inv_a + p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a + p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "pb = pb * b % p",
      "mutated_line": "pb = pb * b * p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b * p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "pb = pb * b % p",
      "mutated_line": "pb = pb * b + p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b + p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n + 1) / k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) / k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n + 1) * k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) * k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -2 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -0 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -0 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = [1 if char == '+' else -1 for char in sequence]",
      "mutated_line": "",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else --1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1:",
      "mutated_line": "if y & 2:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 2:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1:",
      "mutated_line": "if y & 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 0:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1:",
      "mutated_line": "if y & 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 0:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1:",
      "mutated_line": "if y & -1:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & -1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "number = number * x % p",
      "mutated_line": "number = number * x * p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x * p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "number = number * x % p",
      "mutated_line": "number = number * x + p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x + p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x / x % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x / x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = (x + x) % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = (x + x) % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x ** x % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x ** x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - inv(p % x, x) * p / x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p / x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - inv(p % x, x) * p * x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p * x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) + pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) + pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = pow_mod(a, n + 1, p * vp) * pow_mod(b, n + 1, p * vp) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = pow_mod(a, n + 1, p * vp) * pow_mod(b, n + 1, p * vp) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp * p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp * p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp + p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp + p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pa = pow_mod(a, k - 1, p)",
      "mutated_line": "pa = pow_mod(a, k - 2, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 2, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pa = pow_mod(a, k - 1, p)",
      "mutated_line": "pa = pow_mod(a, k - 0, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 0, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pa = pow_mod(a, k - 1, p)",
      "mutated_line": "pa = pow_mod(a, k - 0, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 0, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pa = pow_mod(a, k - 1, p)",
      "mutated_line": "pa = pow_mod(a, k - -1, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - -1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += S[i] * pa * pb / sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb / sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += (S[i] * pa * pb + sum_mod) % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += (S[i] * pa * pb + sum_mod) % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += (S[i] * pa * pb) ** sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += (S[i] * pa * pb) ** sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "pa = pa * inv_a % p",
      "mutated_line": "pa = pa / inv_a % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa / inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "pa = pa * inv_a % p",
      "mutated_line": "pa = (pa + inv_a) % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = (pa + inv_a) % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "pa = pa * inv_a % p",
      "mutated_line": "pa = pa ** inv_a % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa ** inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "pb = pb * b % p",
      "mutated_line": "pb = pb / b % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb / b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "pb = pb * b % p",
      "mutated_line": "pb = (pb + b) % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = (pb + b) % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "pb = pb * b % p",
      "mutated_line": "pb = pb ** b % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb ** b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] / (n + 1) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] / (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += (S[i] + (n + 1)) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += (S[i] + (n + 1)) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] ** (n + 1) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] ** (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "number = number * x % p",
      "mutated_line": "number = number / x % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number / x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "number = number * x % p",
      "mutated_line": "number = (number + x) % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = (number + x) % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "number = number * x % p",
      "mutated_line": "number = number ** x % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number ** x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - inv(p % x, x) / p // x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) / p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - (inv(p % x, x) + p) // x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - (inv(p % x, x) + p) // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - inv(p % x, x) ** p // x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) ** p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) * i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) * i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, 10 ** 9 + 9 + i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, 10 ** 9 + 9 + i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) * i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) * i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, 10 ** 9 + 9 + i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, 10 ** 9 + 9 + i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) / vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) / vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) * vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) * vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += S[i] * pa / pb * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa / pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += (S[i] * pa + pb) * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += (S[i] * pa + pb) * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += (S[i] * pa) ** pb * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += (S[i] * pa) ** pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n - 1) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n - 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n * 1) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n * 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 - 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 - 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 * 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 * 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 - 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 - 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 * 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 * 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n - 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n - 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n * 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n * 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p / vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p / vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p + vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p + vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p ** vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p ** vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n - 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n - 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n * 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n * 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p / vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p / vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p + vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p + vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p ** vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p ** vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) + pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) + pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv(pow_mod(a, k, p * vp) * pow_mod(b, k, p * vp) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv(pow_mod(a, k, p * vp) * pow_mod(b, k, p * vp) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += S[i] / pa * pb * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] / pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += (S[i] + pa) * pb * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += (S[i] + pa) * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "s += S[i] * pa * pb * sum_mod % p",
      "mutated_line": "s += S[i] ** pa * pb * sum_mod % p",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] ** pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n + 2) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 2) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n + 0) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 0) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n + 0) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 0) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += S[i] * (n + 1) // k",
      "mutated_line": "s += S[i] * (n + -1) // k",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + -1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - inv(p * x, x) * p // x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p * x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return p - inv(p % x, x) * p // x",
      "mutated_line": "return p - inv(p + x, x) * p // x",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p + x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 * 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 * 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 + 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 + 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 10) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 10) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 8) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 8) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 0) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 0) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 1) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 1) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + -9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + -9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 * 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 * 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 + 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 + 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 10) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 10) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 8) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 8) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 0) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 0) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 1) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 1) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + -9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + -9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 2, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 2, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 0, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 0, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 0, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 0, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + -1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + -1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 2, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 2, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 0, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 0, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 0, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 0, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + -1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + -1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (11 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (11 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (9 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (9 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (0 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (0 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (1 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (1 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (-10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (-10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 10 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 10 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 8 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 8 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 0 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 0 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 1 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 1 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** -9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** -9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (11 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (11 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (9 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (9 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (0 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (0 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (1 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (1 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (-10 ** 9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (-10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 10 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 10 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 8 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 8 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 0 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 0 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 1 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 1 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:",
      "mutated_line": "while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** -9 + 9) ** i) == 0:",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** -9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p / vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p / vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p + vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p + vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p ** vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p ** vp) - pow_mod(b, k, p * vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p / vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p / vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p + vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p + vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp % p, p)",
      "mutated_line": "sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p ** vp)) // vp % p, p)",
      "code": "def calculate_remainder(n, a, b, k, sequence):\n    p = 10 ** 9 + 9\n    S = [1 if char == '+' else -1 for char in sequence]\n\n    def pow_mod(x, y, p):\n        number = 1\n        while y:\n            if y & 1:\n                number = number * x % p\n            y >>= 1\n            x = x * x % p\n        return number % p\n\n    def inv(x, p):\n        if 1 < x:\n            return p - inv(p % x, x) * p // x\n        return 1\n\n    def v(p, a, b, k):\n        i = 1\n        while pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i) == 0:\n            i += 1\n        return i - 1\n    s = 0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = (pow_mod(a, n + 1, p * vp) - pow_mod(b, n + 1, p * vp)) // vp * inv((pow_mod(a, k, p * vp) - pow_mod(b, k, p ** vp)) // vp % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += S[i] * pa * pb * sum_mod % p\n            pa = pa * inv_a % p\n            pb = pb * b % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    return s"
    }
  ]
}