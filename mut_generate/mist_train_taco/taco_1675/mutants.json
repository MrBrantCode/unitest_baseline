{
  "task_id": "taco_1675",
  "entry_point": "compute_power_mod",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if B < 0:",
      "mutated_line": "if B <= 0:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B <= 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if B < 0:",
      "mutated_line": "if B >= 0:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B >= 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if B < 0:",
      "mutated_line": "if B != 0:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B != 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if g != 1:",
      "mutated_line": "if g == 1:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g == 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return x % m",
      "mutated_line": "return x * m",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x * m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return x % m",
      "mutated_line": "return x + m",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x + m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if B < 0:",
      "mutated_line": "if B < 1:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 1:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if B < 0:",
      "mutated_line": "if B < -1:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < -1:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if B < 0:",
      "mutated_line": "if B < 1:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 1:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "B = -B",
      "mutated_line": "B = +B",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = +B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (1, 1, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (1, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (-1, 1, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (-1, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (1, 1, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (1, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 2, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 2, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 0, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 0, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 0, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 0, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, -1, 1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, -1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, 2, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 2, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, 0, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 0, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, 0, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 0, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, -1, 0)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, -1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, 1, 1)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 1)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, 1, -1)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, -1)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, lastx, y, lasty) = (0, 1, 1, 0)",
      "mutated_line": "(x, lastx, y, lasty) = (0, 1, 1, 1)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 1)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx / (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx / (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx + (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx + (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx ** (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx ** (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty / (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty / (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty + (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty + (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty ** (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty ** (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if g != 1:",
      "mutated_line": "if g != 2:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 2:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if g != 1:",
      "mutated_line": "if g != 0:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 0:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if g != 1:",
      "mutated_line": "if g != 0:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 0:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if g != 1:",
      "mutated_line": "if g != -1:",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != -1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, lastx) = (lastx - quotient * x, x)",
      "mutated_line": "(x, lastx) = (lastx + quotient * x, x)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx + quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, lastx) = (lastx - quotient * x, x)",
      "mutated_line": "(x, lastx) = (lastx * (quotient * x), x)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx * (quotient * x), x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(y, lasty) = (lasty - quotient * y, y)",
      "mutated_line": "(y, lasty) = (lasty + quotient * y, y)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty + quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(y, lasty) = (lasty - quotient * y, y)",
      "mutated_line": "(y, lasty) = (lasty * (quotient * y), y)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty * (quotient * y), y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "raise ValueError(\"The modular inverse does not exist because the numbers are not coprime.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, lastx) = (lastx - quotient * x, x)",
      "mutated_line": "(x, lastx) = (lastx - quotient / x, x)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient / x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, lastx) = (lastx - quotient * x, x)",
      "mutated_line": "(x, lastx) = (lastx - (quotient + x), x)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - (quotient + x), x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, lastx) = (lastx - quotient * x, x)",
      "mutated_line": "(x, lastx) = (lastx - quotient ** x, x)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient ** x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(y, lasty) = (lasty - quotient * y, y)",
      "mutated_line": "(y, lasty) = (lasty - quotient / y, y)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient / y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(y, lasty) = (lasty - quotient * y, y)",
      "mutated_line": "(y, lasty) = (lasty - (quotient + y), y)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - (quotient + y), y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(y, lasty) = (lasty - quotient * y, y)",
      "mutated_line": "(y, lasty) = (lasty - quotient ** y, y)",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient ** y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa <= 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa <= 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa >= 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa >= 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa != 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa != 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (+1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (+1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 2), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 2), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 0), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 0), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 0), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 0), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else -1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else -1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb <= 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb <= 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb >= 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb >= 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb != 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb != 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (+1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (+1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 2))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 2))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 0))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 0))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 0))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 0))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else -1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else -1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 1 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 1 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < -1 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < -1 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 1 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 1 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-2 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-2 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-0 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-0 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-0 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-0 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (--1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (--1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 1 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 1 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < -1 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < -1 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 1 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 1 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-2 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-2 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-0 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-0 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-0 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-0 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))",
      "mutated_line": "return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (--1 if bb < 0 else 1))",
      "code": "def compute_power_mod(A: int, B: int, X: int) -> int:\n    \"\"\"\n    Computes the value of A^B mod X.\n\n    Parameters:\n    A (int): The base number.\n    B (int): The exponent.\n    X (int): The modulus.\n\n    Returns:\n    int: The result of A^B mod X.\n    \"\"\"\n\n    def extended_gcd(aa: int, bb: int) -> tuple:\n        \"\"\"\n        Computes the extended greatest common divisor (gcd) of two numbers.\n\n        Parameters:\n        aa (int): The first number.\n        bb (int): The second number.\n\n        Returns:\n        tuple: A tuple containing the gcd and the coefficients x and y such that ax + by = gcd(a, b).\n        \"\"\"\n        (lastremainder, remainder) = (abs(aa), abs(bb))\n        (x, lastx, y, lasty) = (0, 1, 1, 0)\n        while remainder:\n            (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n            (x, lastx) = (lastx - quotient * x, x)\n            (y, lasty) = (lasty - quotient * y, y)\n        return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (--1 if bb < 0 else 1))\n\n    def modinv(a: int, m: int) -> int:\n        \"\"\"\n        Computes the modular inverse of a modulo m.\n\n        Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n\n        Returns:\n        int: The modular inverse of a modulo m.\n        \"\"\"\n        (g, x, y) = extended_gcd(a, m)\n        if g != 1:\n            raise ValueError('The modular inverse does not exist because the numbers are not coprime.')\n        return x % m\n    if B < 0:\n        A = modinv(A, X)\n        B = -B\n    return pow(A, B, X)"
    }
  ]
}