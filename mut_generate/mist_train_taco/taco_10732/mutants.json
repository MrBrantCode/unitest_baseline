{
  "task_id": "taco_10732",
  "entry_point": "count_partitions_with_mex_limit",
  "mutant_count": 196,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 - 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 * 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cons = 500001  # 5 * 10^5 + 1",
      "mutated_line": "cons = 500002",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500002\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cons = 500001  # 5 * 10^5 + 1",
      "mutated_line": "cons = 500000",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500000\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cons = 500001  # 5 * 10^5 + 1",
      "mutated_line": "cons = 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 0\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cons = 500001  # 5 * 10^5 + 1",
      "mutated_line": "cons = 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 1\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cons = 500001  # 5 * 10^5 + 1",
      "mutated_line": "cons = -500001",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = -500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [1] / cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] / cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [1] + cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] + cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [1] ** cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] ** cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k > n:",
      "mutated_line": "if k >= n:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k >= n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k > n:",
      "mutated_line": "if k <= n:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k <= n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k > n:",
      "mutated_line": "if k != n:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k != n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [-1] / n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] / n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [-1] + n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] + n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [-1] ** n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] ** n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = 2",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 2\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 0\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 0\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = -1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 1",
      "mutated_line": "s = 2",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 2\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 1",
      "mutated_line": "s = 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 0\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 1",
      "mutated_line": "s = 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 0\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 1",
      "mutated_line": "s = -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = -1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] / (k + 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] / (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] + (k + 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] + (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] ** (k + 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] ** (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 1\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = -1\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 1\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while j < n:",
      "mutated_line": "while j <= n:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j <= n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while j < n:",
      "mutated_line": "while j >= n:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j >= n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while j < n:",
      "mutated_line": "while j != n:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j != n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 * 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 + 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 8\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 6\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 0\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 1\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + -7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, cons):",
      "mutated_line": "for i in range(2, cons):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(2, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, cons):",
      "mutated_line": "for i in range(0, cons):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(0, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, cons):",
      "mutated_line": "for i in range(0, cons):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(0, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, cons):",
      "mutated_line": "for i in range(-1, cons):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(-1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * 2 * mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 * mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * 2 + mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 + mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if A[i] <= k:",
      "mutated_line": "if A[i] < k:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] < k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if A[i] <= k:",
      "mutated_line": "if A[i] > k:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] > k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if A[i] <= k:",
      "mutated_line": "if A[i] == k:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] == k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k - 1):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k - 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k * 1):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k * 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(il[i]) == 0:",
      "mutated_line": "if len(il[i]) != 0:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) != 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[1] = 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[1] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[-1] = 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[-1] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[1] = 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[1] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "si = max(il, key=lambda x: x[0])[0]",
      "mutated_line": "si = max(il, key=lambda x: x[0])[1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[1]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "si = max(il, key=lambda x: x[0])[0]",
      "mutated_line": "si = max(il, key=lambda x: x[0])[-1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[-1]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "si = max(il, key=lambda x: x[0])[0]",
      "mutated_line": "si = max(il, key=lambda x: x[0])[1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[1]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, si):",
      "mutated_line": "for i in range(2, si):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(2, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, si):",
      "mutated_line": "for i in range(0, si):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(0, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, si):",
      "mutated_line": "for i in range(0, si):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(0, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, si):",
      "mutated_line": "for i in range(-1, si):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(-1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "s = (s + dp[i]) % mod",
      "mutated_line": "s = (s + dp[i]) * mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) * mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "s = (s + dp[i]) % mod",
      "mutated_line": "s = s + dp[i] + mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = s + dp[i] + mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] * (k - 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k - 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] * (k * 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k * 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if A[i] > k:",
      "mutated_line": "if A[i] >= k:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] >= k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if A[i] > k:",
      "mutated_line": "if A[i] <= k:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] <= k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if A[i] > k:",
      "mutated_line": "if A[i] != k:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] != k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i -= 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return dp[n - 1]",
      "mutated_line": "return dp[n + 1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return dp[n - 1]",
      "mutated_line": "return dp[n * 1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 11 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 9 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 0 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 1 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = -10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 10 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 8 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 0 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 1 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** -9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [2] * cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [2] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [0] * cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [0] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [0] * cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [0] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tpa = [1] * cons",
      "mutated_line": "tpa = [-1] * cons",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [-1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] / 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] / 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = (tpa[i - 1] + 2) % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = (tpa[i - 1] + 2) % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] ** 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] ** 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n + 1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n + 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n * 1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n * 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + 2):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 2):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + 0):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 0):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + 0):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 0):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k + 1):",
      "mutated_line": "for i in range(k + -1):",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + -1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(il[i]) == 0:",
      "mutated_line": "if len(il[i]) == 1:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 1:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(il[i]) == 0:",
      "mutated_line": "if len(il[i]) == -1:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == -1:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(il[i]) == 0:",
      "mutated_line": "if len(il[i]) == 1:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 1:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [+1] * n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [+1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "s = (s + dp[i]) % mod",
      "mutated_line": "s = (s - dp[i]) % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s - dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "s = (s + dp[i]) % mod",
      "mutated_line": "s = s * dp[i] % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = s * dp[i] % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [1] * (k + 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [1] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [-1] * (k + 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [-1] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [1] * (k + 1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [1] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] * (k + 2)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 2)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] * (k + 0)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 0)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] * (k + 0)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 0)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ci = [0] * (k + 1)",
      "mutated_line": "ci = [0] * (k + -1)",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + -1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = (s - dp[i]) * mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) * mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = s - dp[i] + mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = s - dp[i] + mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 2\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 0\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 0\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += -1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) or il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) or il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "ci[A[i]] += 1",
      "mutated_line": "ci[A[i]] -= 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] -= 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i -= 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j -= 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dp[n - 1]",
      "mutated_line": "return dp[n - 2]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dp[n - 1]",
      "mutated_line": "return dp[n - 0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dp[n - 1]",
      "mutated_line": "return dp[n - 0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dp[n - 1]",
      "mutated_line": "return dp[n - -1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - -1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * 3 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 3 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * 1 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 1 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * 0 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 0 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * 1 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 1 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 1] * -2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * -2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - 2]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 2]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - 0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 0]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - 0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 0]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - -1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - -1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "il = [[] for _ in range(k + 1)]",
      "mutated_line": "il = [[] for _ in range(k - 1)]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k - 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "il = [[] for _ in range(k + 1)]",
      "mutated_line": "il = [[] for _ in range(k * 1)]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k * 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n + 1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n + 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n * 1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n * 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [-2] * n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-2] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [-0] * n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-0] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [-0] * n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-0] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [-1] * n",
      "mutated_line": "dp = [--1] * n",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [--1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = (s + dp[i]) % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s + dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = s * dp[i] % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = s * dp[i] % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 <= len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 <= len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 >= len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 >= len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 != len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 != len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] < j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] < j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] > j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] > j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] == j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] == j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = (s - dp[i]) * mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) * mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = s - dp[i] + mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = s - dp[i] + mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ci[A[i]] += 1",
      "mutated_line": "ci[A[i]] += 2",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 2\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ci[A[i]] += 1",
      "mutated_line": "ci[A[i]] += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 0\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ci[A[i]] += 1",
      "mutated_line": "ci[A[i]] += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 0\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ci[A[i]] += 1",
      "mutated_line": "ci[A[i]] += -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += -1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 2\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 0\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 0\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += -1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "s = (s + dp[j]) % mod",
      "mutated_line": "s = (s + dp[j]) * mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) * mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "s = (s + dp[j]) % mod",
      "mutated_line": "s = s + dp[j] + mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = s + dp[j] + mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 2\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 0\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 0\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += -1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i + 1] * 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i + 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i * 1] * 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i * 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "il = [[] for _ in range(k + 1)]",
      "mutated_line": "il = [[] for _ in range(k + 2)]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 2)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "il = [[] for _ in range(k + 1)]",
      "mutated_line": "il = [[] for _ in range(k + 0)]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 0)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "il = [[] for _ in range(k + 1)]",
      "mutated_line": "il = [[] for _ in range(k + 0)]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 0)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "il = [[] for _ in range(k + 1)]",
      "mutated_line": "il = [[] for _ in range(k + -1)]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + -1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - 2]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 2]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - 0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 0]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - 0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 0]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return tpa[n - 1]",
      "mutated_line": "return tpa[n - -1]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - -1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] - 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] - 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] * 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] * 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = (s + dp[i]) % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s + dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "s = (s - dp[i]) % mod",
      "mutated_line": "s = s * dp[i] % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = s * dp[i] % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "s = (s + dp[j]) % mod",
      "mutated_line": "s = (s - dp[j]) % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s - dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "s = (s + dp[j]) % mod",
      "mutated_line": "s = s * dp[j] % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = s * dp[j] % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 2] * 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 2] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 0] * 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 0] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - 0] * 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 0] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tpa[i] = tpa[i - 1] * 2 % mod",
      "mutated_line": "tpa[i] = tpa[i - -1] * 2 % mod",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - -1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "si = max(il, key=lambda x: x[0])[0]",
      "mutated_line": "si = max(il, key=lambda x: x[1])[0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[1])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "si = max(il, key=lambda x: x[0])[0]",
      "mutated_line": "si = max(il, key=lambda x: x[-1])[0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[-1])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "si = max(il, key=lambda x: x[0])[0]",
      "mutated_line": "si = max(il, key=lambda x: x[1])[0]",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[1])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 2 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 2 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 0 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 0 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 0 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 0 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + -1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + -1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] - 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] - 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] * 1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] * 1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 2] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 2] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 0] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 0] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 0] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 0] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + 1] <= j:",
      "mutated_line": "elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + -1] <= j:",
      "code": "def count_partitions_with_mex_limit(n, k, A):\n    mod = 10 ** 9 + 7\n    cons = 500001\n    tpa = [1] * cons\n    for i in range(1, cons):\n        tpa[i] = tpa[i - 1] * 2 % mod\n    if k > n:\n        return tpa[n - 1]\n    il = [[] for _ in range(k + 1)]\n    for i in range(n):\n        if A[i] <= k:\n            il[A[i]].append(i)\n    for i in range(k + 1):\n        if len(il[i]) == 0:\n            return tpa[n - 1]\n    dp = [-1] * n\n    dp[0] = 1\n    si = max(il, key=lambda x: x[0])[0]\n    s = 1\n    for i in range(1, si):\n        dp[i] = tpa[i]\n        s = (s + dp[i]) % mod\n    ci = [0] * (k + 1)\n    j = si\n    i = 0\n    while j < n:\n        if A[i] > k:\n            s = (s - dp[i]) % mod\n            i += 1\n        elif ci[A[i]] + 1 < len(il[A[i]]) and il[A[i]][ci[A[i]] + -1] <= j:\n            s = (s - dp[i]) % mod\n            ci[A[i]] += 1\n            i += 1\n        else:\n            dp[j] = s\n            s = (s + dp[j]) % mod\n            j += 1\n    return dp[n - 1]"
    }
  ]
}