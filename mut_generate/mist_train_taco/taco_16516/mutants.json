{
  "task_id": "taco_16516",
  "entry_point": "minimum_unbalancedness",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) / 80",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) / 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = H + W + 80",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = H + W + 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) ** 80",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) ** 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X + X - 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X - 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = (X + X) * 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = (X + X) * 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][0][X + d] = 2",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 2\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][0][X + d] = 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 0\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][0][X + d] = 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 0\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][0][X + d] = -1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = -1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][0][X - d] = 2",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 2\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][0][X - d] = 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 0\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][0][X - d] = 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 0\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][0][X - d] = -1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = -1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "d = np.where(dp)[0] - X",
      "mutated_line": "d = np.where(dp)[0] + X",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] + X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "d = np.where(dp)[0] - X",
      "mutated_line": "d = np.where(dp)[0] * X",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] * X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H - W) * 80",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H - W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = H * W * 80",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = H * W * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) * 81",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 81\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) * 79",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 79\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) * 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 0\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) * 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 1\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "X = (H + W) * 80",
      "mutated_line": "X = (H + W) * -80",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * -80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X - X + 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X - X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X * X + 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X * X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X + X + 2",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 2\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X + X + 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 0\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X + X + 0",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 0\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "L = X + X + 1",
      "mutated_line": "L = X + X + -1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + -1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * W for _ in range(H)]",
      "mutated_line": "dp = [[0] / W for _ in range(H)]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] / W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * W for _ in range(H)]",
      "mutated_line": "dp = [[0] + W for _ in range(H)]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] + W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * W for _ in range(H)]",
      "mutated_line": "dp = [[0] ** W for _ in range(H)]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] ** W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0][0] = np.zeros(L, np.bool)",
      "mutated_line": "dp[0][1] = np.zeros(L, np.bool)",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][1] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0][0] = np.zeros(L, np.bool)",
      "mutated_line": "dp[0][-1] = np.zeros(L, np.bool)",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][-1] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0][0] = np.zeros(L, np.bool)",
      "mutated_line": "dp[0][1] = np.zeros(L, np.bool)",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][1] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = C[0][0]",
      "mutated_line": "d = C[0][1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][1]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = C[0][0]",
      "mutated_line": "d = C[0][-1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][-1]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = C[0][0]",
      "mutated_line": "d = C[0][1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][1]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X - d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][0][X * d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X * d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][0][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X + d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][0][X * d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X * d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-1][+1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][+1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0][0] = np.zeros(L, np.bool)",
      "mutated_line": "dp[1][0] = np.zeros(L, np.bool)",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[1][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0][0] = np.zeros(L, np.bool)",
      "mutated_line": "dp[-1][0] = np.zeros(L, np.bool)",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[-1][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0][0] = np.zeros(L, np.bool)",
      "mutated_line": "dp[1][0] = np.zeros(L, np.bool)",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[1][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = C[0][0]",
      "mutated_line": "d = C[1][0]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[1][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = C[0][0]",
      "mutated_line": "d = C[-1][0]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[-1][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = C[0][0]",
      "mutated_line": "d = C[1][0]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[1][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][1][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][1][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][-1][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][-1][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[0][1][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][1][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][1][X - d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][1][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][-1][X - d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][-1][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[0][1][X - d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][1][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 0 or c == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 or c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if r != 0:",
      "mutated_line": "if r == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r == 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if c != 0:",
      "mutated_line": "if c == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c == 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[+1][-1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[+1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-1][-2]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-2]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-1][-0]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-0]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-1][-0]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-0]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-1][--1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][--1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "d = np.where(dp)[0] - X",
      "mutated_line": "d = np.where(dp)[1] - X",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[1] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "d = np.where(dp)[0] - X",
      "mutated_line": "d = np.where(dp)[-1] - X",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[-1] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "d = np.where(dp)[0] - X",
      "mutated_line": "d = np.where(dp)[1] - X",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[1] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = abs(A[i][j] - B[i][j])",
      "mutated_line": "c = abs(A[i][j] + B[i][j])",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] + B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = abs(A[i][j] - B[i][j])",
      "mutated_line": "c = abs(A[i][j] * B[i][j])",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] * B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * W for _ in range(H)]",
      "mutated_line": "dp = [[1] * W for _ in range(H)]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[1] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * W for _ in range(H)]",
      "mutated_line": "dp = [[-1] * W for _ in range(H)]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[-1] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * W for _ in range(H)]",
      "mutated_line": "dp = [[1] * W for _ in range(H)]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[1] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[1][0][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[1][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[-1][0][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[-1][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[0][0][X + d] = 1",
      "mutated_line": "dp[1][0][X + d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[1][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[1][0][X - d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[1][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[-1][0][X - d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[-1][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][X - d] = 1",
      "mutated_line": "dp[1][0][X - d] = 1",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[1][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r != 0 and c == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r != 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 0 and c != 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c != 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if r != 0:",
      "mutated_line": "if r != 1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 1:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if r != 0:",
      "mutated_line": "if r != -1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != -1:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if r != 0:",
      "mutated_line": "if r != 1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 1:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if c != 0:",
      "mutated_line": "if c != 1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 1:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if c != 0:",
      "mutated_line": "if c != -1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != -1:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if c != 0:",
      "mutated_line": "if c != 1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 1:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-2][-1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-2][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-0][-1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-0][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[-0][-1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-0][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp = dp[-1][-1]",
      "mutated_line": "dp = dp[--1][-1]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[--1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 1 and c == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 1 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == -1 and c == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == -1 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 1 and c == 0:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 1 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 0 and c == 1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 1:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 0 and c == -1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == -1:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if r == 0 and c == 0:",
      "mutated_line": "if r == 0 and c == 1:",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 1:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r - 1][c][:L + d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L + d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r - 1][c][:L * d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L * d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L + d] |= dp[r - 1][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L + d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L * d] |= dp[r - 1][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L * d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c + 1][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c + 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c * 1][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c * 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c - 1][:L + d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L + d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c - 1][:L * d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L * d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L + d] |= dp[r][c - 1][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L + d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L * d] |= dp[r][c - 1][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L * d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L - d] |= dp[r][c + 1][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c + 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L - d] |= dp[r][c * 1][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c * 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r + 1][c][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r + 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r * 1][c][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r * 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L - d] |= dp[r + 1][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r + 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L - d] |= dp[r * 1][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r * 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c - 2][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 2][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c - 0][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 0][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c - 0][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 0][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[d:] |= dp[r][c - 1][:L - d]",
      "mutated_line": "l[d:] |= dp[r][c - -1][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - -1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L - d] |= dp[r][c - 2][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 2][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L - d] |= dp[r][c - 0][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 0][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L - d] |= dp[r][c - 0][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 0][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l[:L - d] |= dp[r][c - 1][d:]",
      "mutated_line": "l[:L - d] |= dp[r][c - -1][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - -1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r - 2][c][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 2][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r - 0][c][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 0][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r - 0][c][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 0][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[d:] |= dp[r - 1][c][:L - d]",
      "mutated_line": "l[d:] |= dp[r - -1][c][:L - d]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - -1][c][:L - d]\n                l[:L - d] |= dp[r - 1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L - d] |= dp[r - 2][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 2][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L - d] |= dp[r - 0][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 0][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L - d] |= dp[r - 0][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - 0][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[:L - d] |= dp[r - 1][c][d:]",
      "mutated_line": "l[:L - d] |= dp[r - -1][c][d:]",
      "code": "import numpy as np\n\ndef minimum_unbalancedness(H, W, A, B):\n    C = []\n    for i in range(H):\n        cs = []\n        for j in range(W):\n            c = abs(A[i][j] - B[i][j])\n            cs.append(c)\n        C.append(cs)\n    X = (H + W) * 80\n    L = X + X + 1\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = np.zeros(L, np.bool)\n    d = C[0][0]\n    dp[0][0][X + d] = 1\n    dp[0][0][X - d] = 1\n    for r in range(H):\n        for c in range(W):\n            if r == 0 and c == 0:\n                continue\n            l = np.zeros(L, np.bool)\n            d = C[r][c]\n            if r != 0:\n                l[d:] |= dp[r - 1][c][:L - d]\n                l[:L - d] |= dp[r - -1][c][d:]\n            if c != 0:\n                l[d:] |= dp[r][c - 1][:L - d]\n                l[:L - d] |= dp[r][c - 1][d:]\n            dp[r][c] = l\n    dp = dp[-1][-1]\n    d = np.where(dp)[0] - X\n    ans = np.abs(d).min()\n    return ans"
    }
  ]
}