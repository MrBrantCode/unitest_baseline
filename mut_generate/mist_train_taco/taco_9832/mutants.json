{
  "task_id": "taco_9832",
  "entry_point": "calculate_minimum_speed",
  "mutant_count": 113,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-08",
      "mutated_line": "EPS = 1.00000001",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1.00000001\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-08",
      "mutated_line": "EPS = -0.99999999",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = -0.99999999\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-08",
      "mutated_line": "EPS = 0",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 0\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-08",
      "mutated_line": "EPS = 1",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-08",
      "mutated_line": "EPS = -1e-08",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = -1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[0] * v[0]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] * v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[0] // v[0]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] // v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(2, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(0, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(0, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(-1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if v[i] > 0:",
      "mutated_line": "if v[i] >= 0:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] >= 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if v[i] > 0:",
      "mutated_line": "if v[i] <= 0:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] <= 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if v[i] > 0:",
      "mutated_line": "if v[i] != 0:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] != 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t - r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: (p / t / t + q / t) * r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if b == c:",
      "mutated_line": "if b != c:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b != c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while hi - lo > EPS:",
      "mutated_line": "while hi - lo >= EPS:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo >= EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while hi - lo > EPS:",
      "mutated_line": "while hi - lo <= EPS:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo <= EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while hi - lo > EPS:",
      "mutated_line": "while hi - lo != EPS:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo != EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) * 0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) * 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) + 0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) + 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[1] / v[0]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[1] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[-1] / v[0]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[-1] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[1] / v[0]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[1] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[0] / v[1]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[1]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[0] / v[-1]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[-1]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t_exit = l[0] / v[0]",
      "mutated_line": "t_exit = l[0] / v[1]",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[1]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v[i] > 0:",
      "mutated_line": "if v[i] > 1:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 1:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v[i] > 0:",
      "mutated_line": "if v[i] > -1:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > -1:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v[i] > 0:",
      "mutated_line": "if v[i] > 1:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 1:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif v[i] < 0:",
      "mutated_line": "elif v[i] <= 0:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] <= 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif v[i] < 0:",
      "mutated_line": "elif v[i] >= 0:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] >= 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif v[i] < 0:",
      "mutated_line": "elif v[i] != 0:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] != 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] - c[i]) * 2 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) * 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum((b[i] - c[i] + 2 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum((b[i] - c[i] + 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((2 * (b[i] - c[i]) / v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) / v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((2 * (b[i] - c[i]) + v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) + v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum(((2 * (b[i] - c[i])) ** v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum(((2 * (b[i] - c[i])) ** v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi * 2 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi * 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi + 2 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi + 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t - q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t * (q / t) + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 1\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return -1\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 1\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(lo, hi) = (0, t_exit)",
      "mutated_line": "(lo, hi) = (1, t_exit)",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (1, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(lo, hi) = (0, t_exit)",
      "mutated_line": "(lo, hi) = (-1, t_exit)",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (-1, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(lo, hi) = (0, t_exit)",
      "mutated_line": "(lo, hi) = (1, t_exit)",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (1, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while hi - lo > EPS:",
      "mutated_line": "while hi + lo > EPS:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi + lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while hi - lo > EPS:",
      "mutated_line": "while hi * lo > EPS:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi * lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) * 3",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) * 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) // 3",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) // 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "m1 = lo + d",
      "mutated_line": "m1 = lo - d",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo - d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "m1 = lo + d",
      "mutated_line": "m1 = lo * d",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo * d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m2 = m1 + d",
      "mutated_line": "m2 = m1 - d",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 - d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m2 = m1 + d",
      "mutated_line": "m2 = m1 * d",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 * d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if func(m1) <= func(m2):",
      "mutated_line": "if func(m1) < func(m2):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) < func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if func(m1) <= func(m2):",
      "mutated_line": "if func(m1) > func(m2):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) > func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if func(m1) <= func(m2):",
      "mutated_line": "if func(m1) == func(m2):",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) == func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) ** 1.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 1.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) ** -0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** -0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) ** 0",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) ** 1",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 1\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(0, func(lo)) ** -0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** -0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t_exit = min(t_exit, (l[i] - b[i]) / v[i])",
      "mutated_line": "t_exit = min(t_exit, (l[i] - b[i]) * v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) * v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t_exit = min(t_exit, (l[i] - b[i]) / v[i])",
      "mutated_line": "t_exit = min(t_exit, (l[i] - b[i]) // v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) // v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif v[i] < 0:",
      "mutated_line": "elif v[i] < 1:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 1:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif v[i] < 0:",
      "mutated_line": "elif v[i] < -1:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < -1:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif v[i] < 0:",
      "mutated_line": "elif v[i] < 1:",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 1:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] + c[i]) ** 2 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] + c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] * c[i]) ** 2 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] * c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] - c[i]) ** 3 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 3 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] - c[i]) ** 1 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 1 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] - c[i]) ** 0 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 0 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] - c[i]) ** 1 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 1 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = sum(((b[i] - c[i]) ** 2 for i in range(n)))",
      "mutated_line": "p = sum(((b[i] - c[i]) ** -2 for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** -2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((2 / (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 / (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum(((2 + (b[i] - c[i])) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum(((2 + (b[i] - c[i])) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((2 ** (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 ** (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi ** 3 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 3 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi ** 1 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 1 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi ** 0 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 0 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi ** 1 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 1 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "r = sum((vi ** 2 for vi in v))",
      "mutated_line": "r = sum((vi ** -2 for vi in v))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** -2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t * t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t // t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q * t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q // t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi + lo) / 3",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi + lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = hi * lo / 3",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = hi * lo / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) / 4",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 4\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) / 2",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 2\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) / 0",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 0\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) / 1",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 1\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d = (hi - lo) / 3",
      "mutated_line": "d = (hi - lo) / -3",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / -3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(1, func(lo)) ** 0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(1, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(-1, func(lo)) ** 0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(-1, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return max(0, func(lo)) ** 0.5",
      "mutated_line": "return max(1, func(lo)) ** 0.5",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(1, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t_exit = min(t_exit, (l[i] - b[i]) / v[i])",
      "mutated_line": "t_exit = min(t_exit, (l[i] + b[i]) / v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] + b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t_exit = min(t_exit, (l[i] - b[i]) / v[i])",
      "mutated_line": "t_exit = min(t_exit, l[i] * b[i] / v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, l[i] * b[i] / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t_exit = min(t_exit, -b[i] / v[i])",
      "mutated_line": "t_exit = min(t_exit, -b[i] * v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] * v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t_exit = min(t_exit, -b[i] / v[i])",
      "mutated_line": "t_exit = min(t_exit, -b[i] // v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] // v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((3 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((3 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((1 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((1 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((0 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((0 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((1 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((1 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((-2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((-2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((2 * (b[i] + c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] + c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))",
      "mutated_line": "q = sum((2 * (b[i] * c[i]) * v[i] for i in range(n)))",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] * c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p * t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "func = lambda t: p / t / t + q / t + r",
      "mutated_line": "",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, -b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p // t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "t_exit = min(t_exit, -b[i] / v[i])",
      "mutated_line": "t_exit = min(t_exit, +b[i] / v[i])",
      "code": "def calculate_minimum_speed(n, l, b, v, c):\n    EPS = 1e-08\n    t_exit = l[0] / v[0]\n    for i in range(1, n):\n        if v[i] > 0:\n            t_exit = min(t_exit, (l[i] - b[i]) / v[i])\n        elif v[i] < 0:\n            t_exit = min(t_exit, +b[i] / v[i])\n    p = sum(((b[i] - c[i]) ** 2 for i in range(n)))\n    q = sum((2 * (b[i] - c[i]) * v[i] for i in range(n)))\n    r = sum((vi ** 2 for vi in v))\n    func = lambda t: p / t / t + q / t + r\n\n    def method1():\n        if b == c:\n            return 0\n        (lo, hi) = (0, t_exit)\n        while hi - lo > EPS:\n            d = (hi - lo) / 3\n            m1 = lo + d\n            m2 = m1 + d\n            if func(m1) <= func(m2):\n                hi = m2\n            else:\n                lo = m1\n        return max(0, func(lo)) ** 0.5\n    return method1()"
    }
  ]
}