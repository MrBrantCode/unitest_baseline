{
  "task_id": "taco_18321",
  "entry_point": "find_divisible_parts",
  "mutant_count": 76,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 1\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = -1\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 1\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 1\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = -1\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 1\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 2\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 0\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 0\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = -1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, c in enumerate(public_key, 1):",
      "mutated_line": "for (i, c) in enumerate(public_key, 2):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 2):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, c in enumerate(public_key, 1):",
      "mutated_line": "for (i, c) in enumerate(public_key, 0):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 0):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, c in enumerate(public_key, 1):",
      "mutated_line": "for (i, c) in enumerate(public_key, 0):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 0):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, c in enumerate(public_key, 1):",
      "mutated_line": "for (i, c) in enumerate(public_key, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, -1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) * a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = x * 10 + int(c) + a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 0 or i < len(public_key) or public_key[i] != '0':",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 or i < len(public_key) or public_key[i] != '0':\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x == 0:",
      "mutated_line": "if x != 0:",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x != 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (\"NO\",)",
      "mutated_line": "return ('',)",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 - int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = x * 10 * int(c) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x != 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x != 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 0 and i <= len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i <= len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 0 and i >= len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i >= len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 0 and i != len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i != len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] == '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] == '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i + 1, stop - 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i + 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i * 1, stop - 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i * 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop + 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop + 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop * 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop * 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 1, +1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, +1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = (x + int(public_key[i]) * p) * b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) * b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = x + int(public_key[i]) * p + b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = x + int(public_key[i]) * p + b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * 10 * b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 * b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * 10 + b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 + b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 1:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x == 0:",
      "mutated_line": "if x == -1:",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == -1:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 1:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x / 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x + 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x ** 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 1 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 1 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == -1 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == -1 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 1 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 1 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x == 0 and i < len(public_key) and public_key[i] != '0':",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != ''):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != ''):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 2, stop - 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 2, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 0, stop - 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 0, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 0, stop - 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 0, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - -1, stop - 1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - -1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 2, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 2, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 0, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 0, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 0, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 0, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - -1, -1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - -1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 1, -2):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -2):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 1, -0):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -0):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 1, -0):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -0):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(i - 1, stop - 1, -1):",
      "mutated_line": "for i in range(i - 1, stop - 1, --1):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, --1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = (x - int(public_key[i]) * p) % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x - int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = x * (int(public_key[i]) * p) % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = x * (int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p / 10 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p / 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = (p + 10) % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = (p + 10) % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p ** 10 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p ** 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return (\"YES\", public_key[:i], public_key[i:])",
      "mutated_line": "return ('', public_key[:i], public_key[i:])",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 11 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 9 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 0 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 1 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = (x * 10 + int(c)) % a",
      "mutated_line": "if x == 0 and i < len(public_key) and (public_key[i] != '0'):",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * -10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = (x + int(public_key[i]) / p) % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) / p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = (x + (int(public_key[i]) + p)) % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + (int(public_key[i]) + p)) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = (x + int(public_key[i]) * p) % b",
      "mutated_line": "x = (x + int(public_key[i]) ** p) % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) ** p) % b\n            p = p * 10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * 11 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 11 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * 9 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 9 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * 0 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 0 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * 1 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * 1 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = p * 10 % b",
      "mutated_line": "p = p * -10 % b",
      "code": "def find_divisible_parts(public_key: str, a: int, b: int) -> tuple:\n    pfx = []\n    x = 0\n    for (i, c) in enumerate(public_key, 1):\n        x = (x * 10 + int(c)) % a\n        if x == 0 and i < len(public_key) and (public_key[i] != '0'):\n            pfx.append(i)\n    x = 0\n    p = 1\n    i = len(public_key)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + int(public_key[i]) * p) % b\n            p = p * -10 % b\n        if x == 0:\n            return ('YES', public_key[:i], public_key[i:])\n    return ('NO',)"
    }
  ]
}