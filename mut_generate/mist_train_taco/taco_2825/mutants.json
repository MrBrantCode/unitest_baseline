{
  "task_id": "taco_2825",
  "entry_point": "calculate_remaining_frames",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 5000",
      "mutated_line": "L = 5001",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5001\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 5000",
      "mutated_line": "L = 4999",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 4999\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 5000",
      "mutated_line": "L = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 0\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 5000",
      "mutated_line": "L = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 1\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 5000",
      "mutated_line": "L = -5000",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = -5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] / 5",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] / 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] + 5",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] + 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] ** 5",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] ** 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "U = [0] * L",
      "mutated_line": "U = [0] / L",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] / L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "U = [0] * L",
      "mutated_line": "U = [0] + L",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] + L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "U = [0] * L",
      "mutated_line": "U = [0] ** L",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] ** L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "q -= 1",
      "mutated_line": "q += 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q += 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 1\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = -1\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 1\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] / L for _ in range(5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] / L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] + L for _ in range(5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] + L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] ** L for _ in range(5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] ** L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] * 6",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 6\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] * 4",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 4\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] * 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 0\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] * 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 1\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cs = [L] * 5",
      "mutated_line": "cs = [L] * -5",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * -5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q -= 1",
      "mutated_line": "q -= 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 2\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q -= 1",
      "mutated_line": "q -= 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 0\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q -= 1",
      "mutated_line": "q -= 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 0\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q -= 1",
      "mutated_line": "q -= -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= -1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if d == 1:",
      "mutated_line": "if d != 1:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d != 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y += 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(6):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(6):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(4):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(4):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(0):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(0):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(1):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(-5):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(-5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "ans += MP[j][k]",
      "mutated_line": "ans -= MP[j][k]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans -= MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "U = [0] * L",
      "mutated_line": "U = [1] * L",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [1] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "U = [0] * L",
      "mutated_line": "U = [-1] * L",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [-1] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "U = [0] * L",
      "mutated_line": "U = [1] * L",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [1] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d == 1:",
      "mutated_line": "if d == 2:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 2:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d == 1:",
      "mutated_line": "if d == 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 0:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d == 1:",
      "mutated_line": "if d == 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 0:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d == 1:",
      "mutated_line": "if d == -1:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == -1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 2\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 0\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 0\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= -1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "y = cs[q] - p",
      "mutated_line": "y = cs[q] + p",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] + p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "y = cs[q] - p",
      "mutated_line": "y = cs[q] * p",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] * p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[1] * L for _ in range(5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[1] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[-1] * L for _ in range(5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[-1] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[1] * L for _ in range(5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[1] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] * L for _ in range(6)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(6)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] * L for _ in range(4)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(4)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] * L for _ in range(0)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(0)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] * L for _ in range(1)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(1)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MP = [[0] * L for _ in range(5)]",
      "mutated_line": "MP = [[0] * L for _ in range(-5)]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(-5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "MP[q + j][y] = 1",
      "mutated_line": "MP[q + j][y] = 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 2\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "MP[q + j][y] = 1",
      "mutated_line": "MP[q + j][y] = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 0\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "MP[q + j][y] = 1",
      "mutated_line": "MP[q + j][y] = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 0\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "MP[q + j][y] = 1",
      "mutated_line": "MP[q + j][y] = -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = -1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "MP[q][y + j] = 1",
      "mutated_line": "MP[q][y + j] = 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 2\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "MP[q][y + j] = 1",
      "mutated_line": "MP[q][y + j] = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 0\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "MP[q][y + j] = 1",
      "mutated_line": "MP[q][y + j] = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 0\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "MP[q][y + j] = 1",
      "mutated_line": "MP[q][y + j] = -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = -1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "y0 = us[-1]",
      "mutated_line": "y0 = us[+1]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[+1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "U[y] = 1",
      "mutated_line": "U[y] = 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 2\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "U[y] = 1",
      "mutated_line": "U[y] = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 0\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "U[y] = 1",
      "mutated_line": "U[y] = 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 0\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "U[y] = 1",
      "mutated_line": "U[y] = -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = -1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(6):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(6):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(4):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(4):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(0):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(0):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(1):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(5):",
      "mutated_line": "for j in range(-5):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(-5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cur -= 1",
      "mutated_line": "cur += 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur += 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur < L or MP[j][cur] == 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L or MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur -= 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "U[y] = 0",
      "mutated_line": "U[y] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 1\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "U[y] = 0",
      "mutated_line": "U[y] = -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = -1\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "U[y] = 0",
      "mutated_line": "U[y] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 1\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[q + j] = y",
      "mutated_line": "cs[q - j] = y",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q - j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[q + j] = y",
      "mutated_line": "cs[q * j] = y",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q * j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "MP[q][y + j] = 1",
      "mutated_line": "MP[q][y - j] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y - j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "MP[q][y + j] = 1",
      "mutated_line": "MP[q][y * j] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y * j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y0 = us[-1]",
      "mutated_line": "y0 = us[-2]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-2]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y0 = us[-1]",
      "mutated_line": "y0 = us[-0]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-0]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y0 = us[-1]",
      "mutated_line": "y0 = us[-0]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-0]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y0 = us[-1]",
      "mutated_line": "y0 = us[--1]",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[--1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] + 1, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] + 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] * 1, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] * 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 1, +1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, +1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 2\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 0\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 0\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= -1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] + 1, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] + 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] * 1, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] * 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 1, +1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, +1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "MP[j][k] = 0",
      "mutated_line": "MP[j][k] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 1\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "MP[j][k] = 0",
      "mutated_line": "MP[j][k] = -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = -1\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "MP[j][k] = 0",
      "mutated_line": "MP[j][k] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 1\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur <= L and MP[j][cur] == 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur <= L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur >= L and MP[j][cur] == 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur >= L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur != L and MP[j][cur] == 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur != L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur < L and MP[j][cur] != 0:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] != 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 2\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 0\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 0\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += -1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = min(y, cs[q + j])",
      "mutated_line": "y = min(y, cs[q - j])",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q - j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = min(y, cs[q + j])",
      "mutated_line": "y = min(y, cs[q * j])",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q * j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "MP[q + j][y] = 1",
      "mutated_line": "MP[q - j][y] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q - j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "MP[q + j][y] = 1",
      "mutated_line": "MP[q * j][y] = 1",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q * j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "us.append(y + j)",
      "mutated_line": "us.append(y - j)",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y - j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "us.append(y + j)",
      "mutated_line": "us.append(y * j)",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y * j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 2, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 2, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 0, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 0, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 0, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 0, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - -1, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - -1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 1, -2):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -2):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 1, -0):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -0):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 1, -0):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -0):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for k in range(y0, cs[j] - 1, -1):",
      "mutated_line": "for k in range(y0, cs[j] - 1, --1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, --1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 2, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 2, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 0, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 0, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 0, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 0, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - -1, -1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - -1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 1, -2):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -2):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 1, -0):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -0):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 1, -0):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -0):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for k in range(cur, cs[j] - 1, -1):",
      "mutated_line": "for k in range(cur, cs[j] - 1, --1):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, --1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur < L and MP[j][cur] == 1:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 1:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur < L and MP[j][cur] == -1:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == -1:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while cur < L and MP[j][cur] == 0:",
      "mutated_line": "while cur < L and MP[j][cur] == 1:",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 1:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if all((MP[j][y] for j in range(5))):",
      "mutated_line": "if all((MP[j][y] for j in range(6))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(6))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if all((MP[j][y] for j in range(5))):",
      "mutated_line": "if all((MP[j][y] for j in range(4))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(4))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if all((MP[j][y] for j in range(5))):",
      "mutated_line": "if all((MP[j][y] for j in range(0))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(0))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if all((MP[j][y] for j in range(5))):",
      "mutated_line": "if all((MP[j][y] for j in range(1))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(1))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if all((MP[j][y] for j in range(5))):",
      "mutated_line": "if all((MP[j][y] for j in range(-5))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(-5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y - j] for k in range(5))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y - j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y * j] for k in range(5))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y * j] for k in range(5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y + j] for k in range(6))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(6))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y + j] for k in range(4))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(4))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y + j] for k in range(0))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(0))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y + j] for k in range(1))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(1))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if all((MP[k][y + j] for k in range(5))):",
      "mutated_line": "if all((MP[k][y + j] for k in range(-5))):",
      "code": "def calculate_remaining_frames(n, blocks):\n    L = 5000\n    MP = [[0] * L for _ in range(5)]\n    cs = [L] * 5\n    us = []\n    U = [0] * L\n    for i in range(n):\n        (d, p, q) = blocks[i]\n        q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q + j])\n            y -= 1\n            for j in range(p):\n                MP[q + j][y] = 1\n                cs[q + j] = y\n            if all((MP[j][y] for j in range(5))):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y + j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all((MP[k][y + j] for k in range(-5))):\n                    us.append(y + j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j] - 1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j] - 1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    return ans"
    }
  ]
}