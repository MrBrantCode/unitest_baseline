{
  "task_id": "taco_4766",
  "entry_point": "count_ways_to_fill_grid",
  "mutant_count": 181,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 - 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 * 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 * 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 * 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 + 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 + 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] - [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] - [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] * ([0] * max_n)",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] * ([0] * max_n)\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] - [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] - [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] * ([0] * max_n)",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] * ([0] * max_n)\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 1\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = -1\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 1\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 * 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 + 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 8\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 6\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 0\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 1\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + -7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 11 ** 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 11 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 9 ** 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 9 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 0 ** 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 0 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 1 ** 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 1 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = -10 ** 4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = -10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 ** 5",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 5\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 ** 3",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 3\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 ** 0",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 0\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 ** 1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 1\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "max_n = 10**4",
      "mutated_line": "max_n = 10 ** -4",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** -4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] + [0] / max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] / max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] + ([0] + max_n)",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + ([0] + max_n)\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] + [0] ** max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] ** max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] + [0] / max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] / max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] + ([0] + max_n)",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + ([0] + max_n)\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] + [0] ** max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] ** max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(2, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(0, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(0, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(-1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n - 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n * 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] * i * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i * mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] * i + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i + mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) * mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) + mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 or r == 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 or r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r and n < 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r and n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = fac_i[n - r] * fac_i[r] * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] * mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = fac_i[n - r] * fac_i[r] + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] + mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return temp * fac[n] % mod",
      "mutated_line": "return temp * fac[n] * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] * mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return temp * fac[n] % mod",
      "mutated_line": "return temp * fac[n] + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] + mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n - 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n * 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) * mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod + mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) * mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) + mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + val) % mod",
      "mutated_line": "ans = (ans + val) * mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + val) % mod",
      "mutated_line": "ans = ans + val + mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = ans + val + mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 11 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 9 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 0 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 1 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = -10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 10 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 8 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 0 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 1 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** -9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [2] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [2] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [0] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [0] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [0] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [0] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [-1] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [-1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [2] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [2] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [0] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [0] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [0] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [0] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [-1] + [0] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [-1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 2):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 0):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 0):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + -1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] / i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] / i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = (fac[i - 1] + i) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = (fac[i - 1] + i) % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] ** i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] ** i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] / pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] / pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = (fac_i[i - 1] + pow(i, mod - 2, mod)) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = (fac_i[i - 1] + pow(i, mod - 2, mod)) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] ** pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] ** pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n != 0 and r == 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n != 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r != 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r != 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 2\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 0\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 0\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return -1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n <= r or n < 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n <= r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n >= r or n < 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n >= r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n != r or n < 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n != r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r or n <= 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n <= 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r or n >= 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n >= 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r or n != 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n != 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 1\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return -1\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 1\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = fac_i[n - r] / fac_i[r] % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] / fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = (fac_i[n - r] + fac_i[r]) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = (fac_i[n - r] + fac_i[r]) % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = fac_i[n - r] ** fac_i[r] % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] ** fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return temp * fac[n] % mod",
      "mutated_line": "return temp / fac[n] % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp / fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return temp * fac[n] % mod",
      "mutated_line": "return (temp + fac[n]) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return (temp + fac[n]) % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return temp * fac[n] % mod",
      "mutated_line": "return temp ** fac[n] % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp ** fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 2):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 0):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 0):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + -1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) - mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) - mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod)) * mod % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod)) * mod % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-1, i) * mod_nCr(n, i) / pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) / pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = (pow(-1, i) * mod_nCr(n, i) + pow(base, n, mod)) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = (pow(-1, i) * mod_nCr(n, i) + pow(base, n, mod)) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = (pow(-1, i) * mod_nCr(n, i)) ** pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = (pow(-1, i) * mod_nCr(n, i)) ** pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + val) % mod",
      "mutated_line": "ans = (ans - val) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans - val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + val) % mod",
      "mutated_line": "ans = ans * val % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = ans * val % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] + [1] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [1] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] + [-1] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [-1] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "fac = [1] + [0] * max_n",
      "mutated_line": "fac = [1] + [1] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [1] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] + [1] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [1] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] + [-1] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [-1] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac_i = [1] + [0] * max_n",
      "mutated_line": "fac_i = [1] + [1] * max_n",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [1] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 1 and r == 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 1 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == -1 and r == 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == -1 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 1 and r == 0:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 1 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r == 1:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 1:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r == -1:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == -1:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r == 1:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 1:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r or n < 1:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 1:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r or n < -1:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < -1:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < r or n < 0:",
      "mutated_line": "if n < r or n < 1:",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 1:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) + pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) + pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) * pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) * pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-1, i) / mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) / mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = (pow(-1, i) + mod_nCr(n, i)) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = (pow(-1, i) + mod_nCr(n, i)) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-1, i) ** mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) ** mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i + 1] * i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i + 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i * 1] * i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i * 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i + 1] * pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i + 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i * 1] * pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i * 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod + 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod + 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod * 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod * 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = fac_i[n + r] * fac_i[r] % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n + r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "temp = fac_i[n - r] * fac_i[r] % mod",
      "mutated_line": "temp = fac_i[n * r] * fac_i[r] % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n * r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) / pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) / pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) + pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) + pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) ** pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) ** pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 2] * i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 2] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 0] * i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 0] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 0] * i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 0] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - -1] * i % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - -1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 2] * pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 2] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 0] * pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 0] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 0] * pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 0] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - -1] * pow(i, mod - 2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - -1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 3, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 3, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 1, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 1, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 0, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 0, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 1, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 1, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod",
      "mutated_line": "fac_i[i] = fac_i[i - 1] * pow(i, mod - -2, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - -2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k + 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k + 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k * 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k * 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(+1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(+1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n + i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n + i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n * i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n * i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k + 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k + 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k * 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k * 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 2, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 2, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 0, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 0, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 0, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 0, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - -1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - -1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-2, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-2, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-0, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-0, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(-0, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-0, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "mutated_line": "val = pow(--1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(--1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 2, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 2, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 0, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 0, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - 0, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - 0, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base = (pow(k, n - i, mod) * pow(k - 1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "mutated_line": "base = (pow(k, n - i, mod) * pow(k - -1, i, mod) - pow(k - 1, n, mod) + mod) % mod",
      "code": "def count_ways_to_fill_grid(n, k):\n    mod = 10 ** 9 + 7\n    max_n = 10 ** 4\n    fac = [1] + [0] * max_n\n    fac_i = [1] + [0] * max_n\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        fac_i[i] = fac_i[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def mod_nCr(n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        temp = fac_i[n - r] * fac_i[r] % mod\n        return temp * fac[n] % mod\n    ans = 0\n    for i in range(n + 1):\n        base = (pow(k, n - i, mod) * pow(k - -1, i, mod) - pow(k - 1, n, mod) + mod) % mod\n        val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, mod) % mod\n        ans = (ans + val) % mod\n    return ans"
    }
  ]
}