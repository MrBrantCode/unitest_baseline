{
  "task_id": "taco_16718",
  "entry_point": "calculate_optimal_scores",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "somaA = 0",
      "mutated_line": "somaA = 1",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 1\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "somaA = 0",
      "mutated_line": "somaA = -1",
      "code": "def calculate_optimal_scores(piles):\n    somaA = -1\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "somaA = 0",
      "mutated_line": "somaA = 1",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 1\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "somaB = 0",
      "mutated_line": "somaB = 1",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 1\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "somaB = 0",
      "mutated_line": "somaB = -1",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = -1\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "somaB = 0",
      "mutated_line": "somaB = 1",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 1\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "somaA += aux[i]",
      "mutated_line": "somaA -= aux[i]",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA -= aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "somaB += aux[i]",
      "mutated_line": "somaB -= aux[i]",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB -= aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) >= 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) >= 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) <= 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) <= 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) != 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) != 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA -= sum(a[0:len(a) // 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA -= sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB -= sum(a[-(len(a) // 2):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB -= sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 2 != 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 != 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(1, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(-1, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(-1, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(1, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), 3):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 3):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), 1):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 1):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), 0):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 0):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), 1):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 1):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(0, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), -2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), -2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(2, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(2, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(0, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(0, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(0, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(-1, len(aux), 2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(-1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), 3):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 3):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), 1):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 1):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), 0):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 0):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), 1):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 1):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(aux), 2):",
      "mutated_line": "for i in range(1, len(aux), -2):",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), -2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) > 2:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 2:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) > 0:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 0:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) > 0:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 0:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(a) > 1:",
      "mutated_line": "if len(a) > -1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > -1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) * 2 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) * 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) + 2 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) + 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 2 == 2:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 2:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 2 == 0:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 0:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 2 == 0:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 0:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 2 == -1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == -1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "aux.sort(reverse=True)",
      "mutated_line": "aux.sort(reverse=False)",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=False)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 3 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 3 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 1 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 1 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 0 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 0 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % 1 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 1 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(a) % 2 == 1:",
      "mutated_line": "if len(a) % -2 == 1:",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % -2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) / 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) / 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) * 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) * 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[1:len(a) // 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[1:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[-1:len(a) // 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[-1:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[1:len(a) // 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[1:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) / 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) / 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) * 2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) * 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[+(len(a) // 2):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[+(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) // 3])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 3])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) // 1])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 1])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) // 0])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 0])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) // 1])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 1])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "aux.append(a[len(a) // 2])",
      "mutated_line": "aux.append(a[len(a) // -2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // -2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) // 3])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 3])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) // 1])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 1])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) // 0])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 0])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) // 1])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 1])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "somaA += sum(a[0:len(a) // 2])",
      "mutated_line": "somaA += sum(a[0:len(a) // -2])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // -2])\n            somaB += sum(a[-(len(a) // 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) / 2):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) / 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) * 2):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) * 2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) // 3):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 3):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) // 1):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 1):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) // 0):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 0):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) // 1):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // 1):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "somaB += sum(a[-(len(a) // 2):])",
      "mutated_line": "somaB += sum(a[-(len(a) // -2):])",
      "code": "def calculate_optimal_scores(piles):\n    somaA = 0\n    somaB = 0\n    aux = []\n    for a in piles:\n        if len(a) > 1:\n            somaA += sum(a[0:len(a) // 2])\n            somaB += sum(a[-(len(a) // -2):])\n        if len(a) % 2 == 1:\n            aux.append(a[len(a) // 2])\n    aux.sort(reverse=True)\n    for i in range(0, len(aux), 2):\n        somaA += aux[i]\n    for i in range(1, len(aux), 2):\n        somaB += aux[i]\n    return (somaA, somaB)"
    }
  ]
}