{
  "task_id": "taco_16125",
  "entry_point": "find_minimum_flour_delivery_cost",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k != 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F = [False] * n",
      "mutated_line": "F = [False] / n",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] / n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F = [False] * n",
      "mutated_line": "F = [False] + n",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] + n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F = [False] * n",
      "mutated_line": "F = [False] ** n",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] ** n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 1:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == -1:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 1:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return +1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage - 1] = False",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = False\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if F[u] and not F[v] or not F[u] and F[v]:",
      "mutated_line": "if (F[u] and (not F[v])) and (not F[u] and F[v]):",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if (F[u] and (not F[v])) and (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -2\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -0\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -0\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return --1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "F = [False] * n",
      "mutated_line": "F = [True] * n",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [True] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage + 1] = True",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage + 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage * 1] = True",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage * 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if F[u] and not F[v] or not F[u] and F[v]:",
      "mutated_line": "if (F[u] or not F[v]) or (not F[u] and F[v]):",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if (F[u] or not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if F[u] and not F[v] or not F[u] and F[v]:",
      "mutated_line": "if F[u] and (not F[v]) or (not F[u] or F[v]):",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] or F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage - 2] = True",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 2] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage - 0] = True",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 0] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage - 0] = True",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 0] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "F[storage - 1] = True",
      "mutated_line": "F[storage - -1] = True",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - -1] = True\n    roads.sort(key=lambda x: x[2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roads.sort(key=lambda x: x[2])",
      "mutated_line": "roads.sort(key=lambda x: x[3])",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[3])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roads.sort(key=lambda x: x[2])",
      "mutated_line": "roads.sort(key=lambda x: x[1])",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[1])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roads.sort(key=lambda x: x[2])",
      "mutated_line": "roads.sort(key=lambda x: x[0])",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[0])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roads.sort(key=lambda x: x[2])",
      "mutated_line": "roads.sort(key=lambda x: x[1])",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[1])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "roads.sort(key=lambda x: x[2])",
      "mutated_line": "roads.sort(key=lambda x: x[-2])",
      "code": "def find_minimum_flour_delivery_cost(n, m, k, roads, storages):\n    if k == 0:\n        return -1\n    F = [False] * n\n    for storage in storages:\n        F[storage - 1] = True\n    roads.sort(key=lambda x: x[-2])\n    for (u, v, l) in roads:\n        if F[u] and (not F[v]) or (not F[u] and F[v]):\n            return l\n    return -1"
    }
  ]
}