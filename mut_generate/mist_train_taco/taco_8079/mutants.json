{
  "task_id": "taco_8079",
  "entry_point": "maximize_destroyed_spaceships",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "stop = lenps - 1",
      "mutated_line": "stop = lenps + 1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps + 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "stop = lenps - 1",
      "mutated_line": "stop = lenps * 1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps * 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stop = lenps - 1",
      "mutated_line": "stop = lenps - 2",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 2\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stop = lenps - 1",
      "mutated_line": "stop = lenps - 0",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 0\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stop = lenps - 1",
      "mutated_line": "stop = lenps - 0",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 0\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stop = lenps - 1",
      "mutated_line": "stop = lenps - -1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - -1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop and lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop and lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best_second = 0",
      "mutated_line": "best_second = 1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 1\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best_second = 0",
      "mutated_line": "best_second = -1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = -1\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best_second = 0",
      "mutated_line": "best_second = 1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 1\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 != stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 != stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) < best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) < best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) > best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) > best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) == best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) == best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i2 in range(i1 + 1, lenps):",
      "mutated_line": "for i2 in range(i1 - 1, lenps):",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 - 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i2 in range(i1 + 1, lenps):",
      "mutated_line": "for i2 in range(i1 * 1, lenps):",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 * 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(dp2) < best_second:",
      "mutated_line": "if len(dp2) <= best_second:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) <= best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(dp2) < best_second:",
      "mutated_line": "if len(dp2) >= best_second:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) >= best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(dp2) < best_second:",
      "mutated_line": "if len(dp2) != best_second:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) != best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p2_addition = 0",
      "mutated_line": "p2_addition = 1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 1\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p2_addition = 0",
      "mutated_line": "p2_addition = -1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = -1\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p2_addition = 0",
      "mutated_line": "p2_addition = 1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 1\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "p2_addition += ship not in dp1",
      "mutated_line": "p2_addition -= ship not in dp1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition -= ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "new_best = lendp1 + p2_addition",
      "mutated_line": "new_best = lendp1 - p2_addition",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 - p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "new_best = lendp1 + p2_addition",
      "mutated_line": "new_best = lendp1 * p2_addition",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 * p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if new_best > best:",
      "mutated_line": "if new_best >= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best >= best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if new_best > best:",
      "mutated_line": "if new_best <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best <= best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if new_best > best:",
      "mutated_line": "if new_best != best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best != best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) * 2]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) * 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) // 2]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) // 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pd.add(j + n)  # Offset by n to distinguish between the two groups",
      "mutated_line": "pd.add(j - n)",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j - n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pd.add(j + n)  # Offset by n to distinguish between the two groups",
      "mutated_line": "pd.add(j * n)",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j * n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "ps = sorted(p2d, key=lambda p: -len(p2d[p]))",
      "mutated_line": "ps = sorted(p2d, key=lambda p: +len(p2d[p]))",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: +len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "best = len(p2d[ps[0]])",
      "mutated_line": "best = len(p2d[ps[1]])",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[1]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "best = len(p2d[ps[0]])",
      "mutated_line": "best = len(p2d[ps[-1]])",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[-1]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "best = len(p2d[ps[0]])",
      "mutated_line": "best = len(p2d[ps[1]])",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[1]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 - len(p2d[ps[i1 + 1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 - len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 * len(p2d[ps[i1 + 1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 * len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i2 in range(i1 + 1, lenps):",
      "mutated_line": "for i2 in range(i1 + 2, lenps):",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 2, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i2 in range(i1 + 1, lenps):",
      "mutated_line": "for i2 in range(i1 + 0, lenps):",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 0, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i2 in range(i1 + 1, lenps):",
      "mutated_line": "for i2 in range(i1 + 0, lenps):",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 0, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i2 in range(i1 + 1, lenps):",
      "mutated_line": "for i2 in range(i1 + -1, lenps):",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + -1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "p2_addition += ship not in dp1",
      "mutated_line": "p2_addition += ship in dp1",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll - rr) / 2]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll - rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[ll * rr / 2]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[ll * rr / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) / 3]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 3]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) / 1]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 1]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) / 0]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 0]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) / 1]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 1]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pd = p2d[(ll + rr) / 2]",
      "mutated_line": "pd = p2d[(ll + rr) / -2]",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / -2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 - 1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 - 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 * 1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 * 1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 2]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 2]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 0]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 0]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 0]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + 0]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + 1]]) <= best:",
      "mutated_line": "if i1 == stop or lendp1 + len(p2d[ps[i1 + -1]]) <= best:",
      "code": "from collections import defaultdict\n\ndef maximize_destroyed_spaceships(n, m, y1, y2):\n    p2d = defaultdict(lambda : set())\n    for (i, ll) in enumerate(y1):\n        for (j, rr) in enumerate(y2):\n            pd = p2d[(ll + rr) / 2]\n            pd.add(i)\n            pd.add(j + n)\n    ps = sorted(p2d, key=lambda p: -len(p2d[p]))\n    lenps = len(ps)\n    stop = lenps - 1\n    best = len(p2d[ps[0]])\n    for (i1, p1) in enumerate(ps):\n        dp1 = p2d[p1]\n        lendp1 = len(dp1)\n        if i1 == stop or lendp1 + len(p2d[ps[i1 + -1]]) <= best:\n            break\n        best_second = 0\n        for i2 in range(i1 + 1, lenps):\n            p2 = ps[i2]\n            dp2 = p2d[p2]\n            if len(dp2) < best_second:\n                break\n            p2_addition = 0\n            for ship in dp2:\n                p2_addition += ship not in dp1\n            new_best = lendp1 + p2_addition\n            if new_best > best:\n                best = new_best\n                best_second = p2_addition\n    return best"
    }
  ]
}