{
  "task_id": "taco_14555",
  "entry_point": "find_min_change_length",
  "mutant_count": 192,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "k = abs(target_x) + abs(target_y)",
      "mutated_line": "k = abs(target_x) - abs(target_y)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) - abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "k = abs(target_x) + abs(target_y)",
      "mutated_line": "k = abs(target_x) * abs(target_y)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) * abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n and k % 2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n and k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] / (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] / (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] + (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] + (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] ** (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] ** (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] / (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] / (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] + (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] + (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] ** (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] ** (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 1\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "left = 0",
      "mutated_line": "left = -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = -1\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 1\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while left < right:",
      "mutated_line": "while left <= right:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while left < right:",
      "mutated_line": "while left >= right:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left >= right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while left < right:",
      "mutated_line": "while left != right:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left != right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return True\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k >= n or k % 2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k >= n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k <= n or k % 2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k <= n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k != n or k % 2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k != n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 == n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 == n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return +1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] * (n - 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n - 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] * (n * 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n * 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] * (n - 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n - 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] * (n * 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n * 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if operations[i] == 'L':",
      "mutated_line": "if operations[i] != 'L':",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] != 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left - (right - left) // 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left - (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left * ((right - left) // 2)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left * ((right - left) // 2)\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n - m - 1):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m - 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range((n - m) * 1):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range((n - m) * 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i + m + 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m + 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = (i + m) * 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = (i + m) * 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] + prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] + prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = (prefixLR[i] + prefixLR[-1]) * prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = (prefixLR[i] + prefixLR[-1]) * prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] + prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] + prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = (prefixUD[i] + prefixUD[-1]) * prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = (prefixUD[i] + prefixUD[-1]) * prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) + abs(y - dy) < m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) < m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) + abs(y - dy) > m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) > m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) + abs(y - dy) == m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) == m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k * 2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k * 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k + 2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k + 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n * 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n * 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n + 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n + 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -2\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -0\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -0\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return --1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [1] * (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [1] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [-1] * (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [-1] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [1] * (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [1] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] * (n + 2)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 2)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] * (n + 0)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 0)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] * (n + 0)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 0)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "prefixLR = [0] * (n + 1)",
      "mutated_line": "prefixLR = [0] * (n + -1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + -1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [1] * (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [1] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [-1] * (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [-1] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [1] * (n + 1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [1] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] * (n + 2)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 2)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] * (n + 0)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 0)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] * (n + 0)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 0)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prefixUD = [0] * (n + 1)",
      "mutated_line": "prefixUD = [0] * (n + -1)",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + -1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prefixLR[i + 1] = prefixLR[i]",
      "mutated_line": "prefixLR[i - 1] = prefixLR[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i - 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prefixLR[i + 1] = prefixLR[i]",
      "mutated_line": "prefixLR[i * 1] = prefixLR[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i * 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prefixUD[i + 1] = prefixUD[i]",
      "mutated_line": "prefixUD[i - 1] = prefixUD[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i - 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prefixUD[i + 1] = prefixUD[i]",
      "mutated_line": "prefixUD[i * 1] = prefixUD[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i * 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if operations[i] == 'L':",
      "mutated_line": "if operations[i] == '':",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == '':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 1] -= 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 2\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 1] -= 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 0\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 1] -= 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 0\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 1] -= -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= -1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif operations[i] == 'R':",
      "mutated_line": "elif operations[i] != 'R':",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] != 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) / 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) / 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) * 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) * 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid - 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid - 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid * 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid * 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n + m + 1):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n + m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n * m + 1):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n * m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n - m + 2):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 2):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n - m + 0):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 0):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n - m + 0):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 0):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - m + 1):",
      "mutated_line": "for i in range(n - m + -1):",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + -1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i - m - 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i - m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i * m - 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i * m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i + m - 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 2\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i + m - 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 0\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i + m - 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 0\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = i + m - 1",
      "mutated_line": "j = i + m - -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - -1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] - prefixLR[-1] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] - prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] * prefixLR[-1] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] * prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] - prefixUD[-1] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] - prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] * prefixUD[-1] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] * prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) - abs(y - dy) <= m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) - abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) * abs(y - dy) <= m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) * abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return False\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 3 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 3 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 1 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 1 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 0 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 0 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 1 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 1 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % -2 != n % 2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % -2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n % 3:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 3:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n % 1:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 1:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n % 0:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 0:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n % 1:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 1:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k > n or k % 2 != n % 2:",
      "mutated_line": "if k > n or k % 2 != n % -2:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % -2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prefixLR[i + 1] = prefixLR[i]",
      "mutated_line": "prefixLR[i + 2] = prefixLR[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 2] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prefixLR[i + 1] = prefixLR[i]",
      "mutated_line": "prefixLR[i + 0] = prefixLR[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 0] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prefixLR[i + 1] = prefixLR[i]",
      "mutated_line": "prefixLR[i + 0] = prefixLR[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 0] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prefixLR[i + 1] = prefixLR[i]",
      "mutated_line": "prefixLR[i + -1] = prefixLR[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + -1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prefixUD[i + 1] = prefixUD[i]",
      "mutated_line": "prefixUD[i + 2] = prefixUD[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 2] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prefixUD[i + 1] = prefixUD[i]",
      "mutated_line": "prefixUD[i + 0] = prefixUD[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 0] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prefixUD[i + 1] = prefixUD[i]",
      "mutated_line": "prefixUD[i + 0] = prefixUD[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 0] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prefixUD[i + 1] = prefixUD[i]",
      "mutated_line": "prefixUD[i + -1] = prefixUD[i]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + -1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i - 1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i - 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i * 1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i * 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif operations[i] == 'R':",
      "mutated_line": "elif operations[i] == '':",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == '':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 1] += 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 2\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 1] += 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 0\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 1] += 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 0\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 1] += -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += -1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif operations[i] == 'D':",
      "mutated_line": "elif operations[i] != 'D':",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] != 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] += 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] -= 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right + left) // 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right + left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + right * left // 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + right * left // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 3",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 3\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 1\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 0\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 1\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // -2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // -2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 2\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 0\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 0\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + -1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j - 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j - 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j * 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j * 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j - 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j - 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j * 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j * 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 2] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 2] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 0] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 0] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + 0] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 0] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "prefixLR[i + 1] -= 1",
      "mutated_line": "prefixLR[i + -1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + -1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i - 1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i - 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i * 1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i * 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif operations[i] == 'D':",
      "mutated_line": "elif operations[i] == '':",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == '':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 1] -= 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 2\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 1] -= 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 0\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 1] -= 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 0\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 1] -= -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= -1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 1] += 2",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 2\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 1] += 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 0\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 1] += 0",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 0\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 1] += -1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += -1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[+1] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[+1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 2]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 2]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 0]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 0]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 0]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 0]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + -1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + -1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[+1] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[+1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 2]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 2]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 0]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 0]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 0]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 0]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + -1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + -1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x + dx) + abs(y - dy) <= m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x + dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x * dx) + abs(y - dy) <= m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x * dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) + abs(y + dy) <= m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y + dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if abs(x - dx) + abs(y - dy) <= m:",
      "mutated_line": "if abs(x - dx) + abs(y * dy) <= m:",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y * dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 2] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 2] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 0] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 0] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + 0] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 0] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prefixLR[i + 1] += 1",
      "mutated_line": "prefixLR[i + -1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + -1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i - 1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i - 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i * 1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i * 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i - 1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i - 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i * 1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i * 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-2] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-2] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-0] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-0] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[-0] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-0] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]",
      "mutated_line": "dx = prefixLR[i] + prefixLR[--1] - prefixLR[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[--1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-2] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-2] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-0] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-0] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[-0] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-0] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]",
      "mutated_line": "dy = prefixUD[i] + prefixUD[--1] - prefixUD[j + 1]",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[--1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 2] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 2] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 0] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 0] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + 0] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 0] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "prefixUD[i + 1] -= 1",
      "mutated_line": "prefixUD[i + -1] -= 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + -1] -= 1\n        else:\n            prefixUD[i + 1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 2] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 2] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 0] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 0] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + 0] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + 0] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prefixUD[i + 1] += 1",
      "mutated_line": "prefixUD[i + -1] += 1",
      "code": "def find_min_change_length(n, operations, target_x, target_y):\n\n    def doable(n, x, y, m, prefixLR, prefixUD):\n        for i in range(n - m + 1):\n            j = i + m - 1\n            dx = prefixLR[i] + prefixLR[-1] - prefixLR[j + 1]\n            dy = prefixUD[i] + prefixUD[-1] - prefixUD[j + 1]\n            if abs(x - dx) + abs(y - dy) <= m:\n                return True\n        return False\n    k = abs(target_x) + abs(target_y)\n    if k > n or k % 2 != n % 2:\n        return -1\n    prefixLR = [0] * (n + 1)\n    prefixUD = [0] * (n + 1)\n    for i in range(n):\n        prefixLR[i + 1] = prefixLR[i]\n        prefixUD[i + 1] = prefixUD[i]\n        if operations[i] == 'L':\n            prefixLR[i + 1] -= 1\n        elif operations[i] == 'R':\n            prefixLR[i + 1] += 1\n        elif operations[i] == 'D':\n            prefixUD[i + 1] -= 1\n        else:\n            prefixUD[i + -1] += 1\n    left = 0\n    right = n\n    while left < right:\n        mid = left + (right - left) // 2\n        if doable(n, target_x, target_y, mid, prefixLR, prefixUD):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
    }
  ]
}