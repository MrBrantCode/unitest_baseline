{
  "task_id": "taco_4138",
  "entry_point": "comp",
  "mutant_count": 174,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "output -= len(count)",
      "mutated_line": "output += len(count)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output += len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) * (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) * (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = x - y + (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = x - y + (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) / (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) / (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) * (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) * (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 - y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 - y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return (s * (t + 1) + (y + 1) * t * (t + 1) // 2) * y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return (s * (t + 1) + (y + 1) * t * (t + 1) // 2) * y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[2] -= 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] -= 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tempc = 0",
      "mutated_line": "tempc = 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 1\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tempc = 0",
      "mutated_line": "tempc = -1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = -1\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tempc = 0",
      "mutated_line": "tempc = 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 1\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if K >= eff:",
      "mutated_line": "if K > eff:",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K > eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if K >= eff:",
      "mutated_line": "if K < eff:",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K < eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if K >= eff:",
      "mutated_line": "if K == eff:",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K == eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x + y) % (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x + y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = x * y % (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = x * y % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) % (y - 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y - 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) % (y * 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y * 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x + y) // (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x + y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = x * y // (y + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = x * y // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) // (y - 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y - 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) // (y * 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y * 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) - (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) - (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) * ((y + 1) * t * (t + 1) // 2) + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) * ((y + 1) * t * (t + 1) // 2) + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[2] += 2",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 2\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[2] += 0",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 0\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[2] += 0",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 0\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[2] += -1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += -1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] + x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] + x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] * x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] * x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "temp = A[0]",
      "mutated_line": "temp = A[1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[1]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "temp = A[0]",
      "mutated_line": "temp = A[-1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[-1]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "temp = A[0]",
      "mutated_line": "temp = A[1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[1]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if val == temp:",
      "mutated_line": "if val != temp:",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val != temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "tempc += 1",
      "mutated_line": "tempc -= 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc -= 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return hfindb(count, K) + output",
      "mutated_line": "return hfindb(count, K) - output",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) - output"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return hfindb(count, K) + output",
      "mutated_line": "return hfindb(count, K) * output",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) * output"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) % (y + 2)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 2)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) % (y + 0)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 0)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) % (y + 0)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 0)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = (x - y) % (y + 1)",
      "mutated_line": "s = (x - y) % (y + -1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + -1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) // (y + 2)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 2)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) // (y + 0)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 0)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) // (y + 0)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 0)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t = (x - y) // (y + 1)",
      "mutated_line": "t = (x - y) // (y + -1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + -1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s / (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s / (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s + (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s + (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s ** (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s ** (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) / 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) / 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) * 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) * 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) + comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) + comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) * comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) * comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 1, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 1, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, -1, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, -1, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 1, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 1, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[3] += 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[3] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[1] += 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[1] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[0] += 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[0] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[1] += 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[1] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x[2] += 1",
      "mutated_line": "x[-2] += 1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[-2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[5] = x[5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[5] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[3] = x[5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[3] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[0] = x[5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[0] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[1] = x[5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[1] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[-4] = x[5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[-4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[4] = x[6]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[6]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[4] = x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[4]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[4] = x[0]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[0]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[4] = x[1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[1]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x[4] = x[5]",
      "mutated_line": "x[4] = x[-5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[-5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[6] = comp(x[1], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[6] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[4] = comp(x[1], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[4] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[0] = comp(x[1], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[0] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[1] = comp(x[1], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[1] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[-5] = comp(x[1], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[-5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[2] - 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] - 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[2] * 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] * 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[1] = x[5] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[1] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[-1] = x[5] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[-1] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[1] = x[5] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[1] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tempc += 1",
      "mutated_line": "tempc += 2",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 2\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tempc += 1",
      "mutated_line": "tempc += 0",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 0\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tempc += 1",
      "mutated_line": "tempc += 0",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 0\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tempc += 1",
      "mutated_line": "tempc += -1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += -1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tempc = 1",
      "mutated_line": "tempc = 2",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 2\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tempc = 1",
      "mutated_line": "tempc = 0",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 0\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tempc = 1",
      "mutated_line": "tempc = 0",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 0\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tempc = 1",
      "mutated_line": "tempc = -1",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = -1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count.sort(reverse=True)",
      "mutated_line": "count.sort(reverse=False)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=False)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t / 2 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t / 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t * 2 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t * 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val >= 1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val >= 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val <= 1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val <= 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val != 1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val != 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t - 1) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t - 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t * 1) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t * 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t / (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t / (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + ((y + 1) * t + (t + 1)) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + ((y + 1) * t + (t + 1)) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + ((y + 1) * t) ** (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + ((y + 1) * t) ** (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 3 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 3 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 1 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 1 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 0 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 0 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 1 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 1 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // -2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // -2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 1), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 1), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, -1), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, -1), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 1), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 1), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 2)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 2)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 0)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 0)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 0)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 0)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, -1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, -1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[2], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[2], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[0], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[0], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[0], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[0], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[-1], x[2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[-1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[2] + 2)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 2)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[2] + 0)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 0)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[2] + 0)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 0)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[2] + -1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + -1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[6] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[6] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[4] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[4] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[0] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[0] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[1] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[1] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[-5] - x[4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[-5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] - x[5]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[5]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] - x[3]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[3]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] - x[0]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[0]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] - x[1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[1]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x[0] = x[5] - x[4]",
      "mutated_line": "x[0] = x[5] - x[-4]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[-4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([x[4] for x in aa])",
      "mutated_line": "return sum([x[5] for x in aa])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[5] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([x[4] for x in aa])",
      "mutated_line": "return sum([x[3] for x in aa])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[3] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([x[4] for x in aa])",
      "mutated_line": "return sum([x[0] for x in aa])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[0] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([x[4] for x in aa])",
      "mutated_line": "return sum([x[1] for x in aa])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[1] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([x[4] for x in aa])",
      "mutated_line": "return sum([x[-4] for x in aa])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[-4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t // 3 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 3 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t // 1 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 1 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t // 0 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 0 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t // 1 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 1 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "eff = sum([t // 2 for t in count])",
      "mutated_line": "eff = sum([t // -2 for t in count])",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // -2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val > 2]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 2]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val > 0]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 0]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val > 0]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 0]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count = [val for val in count if val > 1]",
      "mutated_line": "count = [val for val in count if val > -1]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > -1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 2) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 2) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 0) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 0) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 0) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 0) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + -1) + (y + 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + -1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) / t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) / t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1 + t) * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1 + t) * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) ** t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) ** t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t - 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t - 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t * 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t * 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 2) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 2) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 0) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 0) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 0) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 0) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, -1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, -1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 1), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 1), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, -1), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, -1), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "mutated_line": "aa = [[comp(val, 1) - comp(val, 1), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 1), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[3] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[3] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[1] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[1] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[0] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[0] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[1] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[1] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[5] = comp(x[1], x[2] + 1)",
      "mutated_line": "x[5] = comp(x[1], x[-2] + 1)",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[-2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y - 1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y - 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + y * 1 * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + y * 1 * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 2) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 2) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 0) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 0) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + 0) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 0) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 1) * t * (t + -1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + -1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 2) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 2) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 0) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 0) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + 0) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 0) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y",
      "mutated_line": "return s * (t + 1) + (y + -1) * t * (t + 1) // 2 + y",
      "code": "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + -1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\n\ndef min_bad_subarrays(N, K, A):\n    temp = A[0]\n    tempc = 0\n    count = []\n    for val in A:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if K >= eff:\n        return N\n    else:\n        return hfindb(count, K) + output"
    }
  ]
}