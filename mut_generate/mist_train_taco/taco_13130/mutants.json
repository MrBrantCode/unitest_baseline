{
  "task_id": "taco_13130",
  "entry_point": "calculate_ski_base_variants",
  "mutant_count": 75,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = [0] * m",
      "mutated_line": "ans = [0] / m",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] / m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = [0] * m",
      "mutated_line": "ans = [0] + m",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] + m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = [0] * m",
      "mutated_line": "ans = [0] ** m",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] ** m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = 2",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 2\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 0\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 0\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = -1",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = -1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 - 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 - 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 * 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 * 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n - 10)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n - 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n * 10)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n * 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 * 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 * 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 + 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 + 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 + 10",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 10\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 8\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 0\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 1\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 9 + -9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + -9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = (x - 1) * mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = x - 1 + mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = x - 1 + mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "__slots__ = ['nodes']",
      "mutated_line": "__slots__ = ['']",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [-1] / n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] / n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [-1] + n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] + n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [-1] ** n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] ** n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.nodes[x] < 0:",
      "mutated_line": "if self.nodes[x] <= 0:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] <= 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.nodes[x] < 0:",
      "mutated_line": "if self.nodes[x] >= 0:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] >= 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.nodes[x] < 0:",
      "mutated_line": "if self.nodes[x] != 0:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] != 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if root_x != root_y:",
      "mutated_line": "if root_x == root_y:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x == root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "nodes[root_x] += nodes[root_y]",
      "mutated_line": "nodes[root_x] -= nodes[root_y]",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] -= nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return root_x != root_y",
      "mutated_line": "return root_x == root_y",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x == root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n + 11)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 11)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n + 9)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 9)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n + 0)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 0)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n + 1)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 1)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "uf = UnionFind(n + 10)",
      "mutated_line": "uf = UnionFind(n + -10)",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + -10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = [0] * m",
      "mutated_line": "ans = [1] * m",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [1] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = [0] * m",
      "mutated_line": "ans = [-1] * m",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [-1] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = [0] * m",
      "mutated_line": "ans = [1] * m",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [1] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 11 ** 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 11 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 9 ** 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 9 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 0 ** 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 0 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 1 ** 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 1 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = -10 ** 9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = -10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 10 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 10 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 8 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 8 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 0 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 0 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** 1 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 1 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod = 10 ** 9 + 9",
      "mutated_line": "mod = 10 ** -9 + 9",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** -9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * 2 * mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 * mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * 2 + mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 + mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = (x + 1) % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = x * 1 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = x * 1 % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.nodes[x] < 0:",
      "mutated_line": "if self.nodes[x] < 1:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 1:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.nodes[x] < 0:",
      "mutated_line": "if self.nodes[x] < -1:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < -1:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if self.nodes[x] < 0:",
      "mutated_line": "if self.nodes[x] < 1:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 1:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if nodes[root_x] > nodes[root_y]:",
      "mutated_line": "if nodes[root_x] >= nodes[root_y]:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] >= nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if nodes[root_x] > nodes[root_y]:",
      "mutated_line": "if nodes[root_x] <= nodes[root_y]:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] <= nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if nodes[root_x] > nodes[root_y]:",
      "mutated_line": "if nodes[root_x] != nodes[root_y]:",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] != nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x / 2 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x / 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = (x + 2) % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = (x + 2) % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x ** 2 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x ** 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = (x - 2) % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 2) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = (x - 0) % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 0) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = (x - 0) % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 0) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans[i] = (x - 1) % mod",
      "mutated_line": "ans[i] = (x - -1) % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - -1) % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [+1] * n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [+1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * 3 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 3 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * 1 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 1 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * 0 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 0 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * 1 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 1 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "x = x * 2 % mod",
      "mutated_line": "x = x * -2 % mod",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * -2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [-2] * n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-2] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [-0] * n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-0] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [-0] * n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [-0] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.nodes = [-1] * n",
      "mutated_line": "self.nodes = [--1] * n",
      "code": "def calculate_ski_base_variants(n: int, m: int, roads: list) -> list:\n\n    class UnionFind:\n        __slots__ = ['nodes']\n\n        def __init__(self, n: int):\n            self.nodes = [--1] * n\n\n        def find(self, x: int) -> int:\n            if self.nodes[x] < 0:\n                return x\n            else:\n                self.nodes[x] = self.find(self.nodes[x])\n                return self.nodes[x]\n\n        def unite(self, x: int, y: int) -> bool:\n            (root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n            if root_x != root_y:\n                if nodes[root_x] > nodes[root_y]:\n                    (root_x, root_y) = (root_y, root_x)\n                nodes[root_x] += nodes[root_y]\n                nodes[root_y] = root_x\n            return root_x != root_y\n    uf = UnionFind(n + 10)\n    ans = [0] * m\n    x = 1\n    mod = 10 ** 9 + 9\n    for (i, (u, v)) in enumerate(roads):\n        if not uf.unite(u, v):\n            x = x * 2 % mod\n        ans[i] = (x - 1) % mod\n    return ans"
    }
  ]
}