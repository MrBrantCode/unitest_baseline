{
  "task_id": "taco_8613",
  "entry_point": "restore_expression",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return \"\"",
      "mutated_line": "return 'MUTATED'",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return 'MUTATED'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return a + b == c",
      "mutated_line": "return a + b != c",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b != c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 - bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 - bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 * bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 * bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 2 - 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 - 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 2 * 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 * 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a + b == c",
      "mutated_line": "return a - b == c",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a - b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return a + b == c",
      "mutated_line": "return a * b == c",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a * b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l / 3 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l / 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l * 3 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l * 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l / 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l / 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l * 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 2):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 2):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 0):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 0):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 0):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 0):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + -1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + -1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc + 1, l - lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc + 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc * 1, l - lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc * 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l + lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l + lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l * (lc * 2), l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l * (lc * 2), l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 - 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 - 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, (l - lc * 2) * 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, (l - lc * 2) * 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "la = l - lc - lb",
      "mutated_line": "la = l - lc + lb",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc + lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "la = l - lc - lb",
      "mutated_line": "la = (l - lc) * lb",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = (l - lc) * lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 and lb < 1 and (lc < 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 and lb < 1 and (lc < 1):\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la > lc and lb > lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc and lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 4 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 4 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 2 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 2 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 0 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 0 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 1 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 1 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // -3 + bool(l % 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // -3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l * 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l * 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l + 3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l + 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 3 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 3 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 1 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 1 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 0 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 0 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // 1 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 1 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 3), l // -2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // -2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 2, l - lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 2, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 0, l - lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 0, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 0, l - lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 0, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - -1, l - lc * 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - -1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc / 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc / 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - (lc + 2), l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - (lc + 2), l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc ** 2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc ** 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l + lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l + lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l * (lc * 2) + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l * (lc * 2) + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 2):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 2):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 0):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 0):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 0):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 0):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + -1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + -1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "la = l - lc - lb",
      "mutated_line": "la = l + lc - lb",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l + lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "la = l - lc - lb",
      "mutated_line": "la = l * lc - lb",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l * lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la <= 1 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la <= 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la >= 1 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la >= 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la != 1 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la != 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb <= 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb <= 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb >= 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb >= 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb != 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb != 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc <= 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc <= 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc >= 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc >= 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc != 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc != 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la >= lc or lb > lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la >= lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la <= lc or lb > lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la <= lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la != lc or lb > lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la != lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la > lc or lb >= lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb >= lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la > lc or lb <= lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb <= lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if la > lc or lb > lc:",
      "mutated_line": "if la > lc or lb != lc:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb != lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return f'{a}+{b}={c}'",
      "mutated_line": "return f'{a}{b}={c}'",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return f'{a}+{b}={c}'",
      "mutated_line": "return f'{a}+{b}{c}'",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}{c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "b = int(s[la:la + lb])",
      "mutated_line": "b = int(s[la:la - lb])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la - lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "b = int(s[la:la + lb])",
      "mutated_line": "b = int(s[la:la * lb])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la * lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = int(s[la + lb:la + lb + lc])",
      "mutated_line": "c = int(s[la - lb:la + lb + lc])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la - lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = int(s[la + lb:la + lb + lc])",
      "mutated_line": "c = int(s[la * lb:la + lb + lc])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la * lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = int(s[la + lb:la + lb + lc])",
      "mutated_line": "c = int(s[la + lb:la + lb - lc])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb - lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = int(s[la + lb:la + lb + lc])",
      "mutated_line": "c = int(s[la + lb:(la + lb) * lc])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:(la + lb) * lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 4), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 4), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 2), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 2), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 0), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 0), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % 1), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 1), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for lc in range(l // 3 + bool(l % 3), l // 2 + 1):",
      "mutated_line": "for lc in range(l // 3 + bool(l % -3), l // 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % -3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 3, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 3, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 1, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 1, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 0, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 0, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 1, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 1, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * -2, l - lc * 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * -2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc / 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc / 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - (lc + 2) + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - (lc + 2) + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc ** 2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc ** 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 2 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 2 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 0 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 0 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 0 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 0 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < -1 or lb < 1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < -1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 2 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 2 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 0 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 0 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 0 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 0 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < -1 or lc < 1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < -1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc < 2:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 2:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc < 0:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 0:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc < 0:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 0:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if la < 1 or lb < 1 or lc < 1:",
      "mutated_line": "if la < 1 or lb < 1 or lc < -1:",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < -1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b = s[la:la + lb]",
      "mutated_line": "b = s[la:la - lb]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la - lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b = s[la:la + lb]",
      "mutated_line": "b = s[la:la * lb]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la * lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "c = s[la + lb:la + lb + lc]",
      "mutated_line": "c = s[la - lb:la + lb + lc]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la - lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "c = s[la + lb:la + lb + lc]",
      "mutated_line": "c = s[la * lb:la + lb + lc]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la * lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "c = s[la + lb:la + lb + lc]",
      "mutated_line": "c = s[la + lb:la + lb - lc]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb - lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "c = s[la + lb:la + lb + lc]",
      "mutated_line": "c = s[la + lb:(la + lb) * lc]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:(la + lb) * lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = int(s[la + lb:la + lb + lc])",
      "mutated_line": "c = int(s[la + lb:la - lb + lc])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la - lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "c = int(s[la + lb:la + lb + lc])",
      "mutated_line": "c = int(s[la + lb:la * lb + lc])",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la * lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 3 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 3 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 1 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 1 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 0 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 0 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 1 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 1 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):",
      "mutated_line": "for lb in (lc, lc - 1, l - lc * 2, l - lc * -2 + 1):",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * -2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la + lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "c = s[la + lb:la + lb + lc]",
      "mutated_line": "c = s[la + lb:la - lb + lc]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la - lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "c = s[la + lb:la + lb + lc]",
      "mutated_line": "c = s[la + lb:la * lb + lc]",
      "code": "def restore_expression(s: str) -> str:\n    l = len(s)\n\n    def mod_check(la, lb, lc):\n        a = int(s[:la])\n        b = int(s[la:la + lb])\n        c = int(s[la + lb:la + lb + lc])\n        return a + b == c\n    for lc in range(l // 3 + bool(l % 3), l // 2 + 1):\n        for lb in (lc, lc - 1, l - lc * 2, l - lc * 2 + 1):\n            la = l - lc - lb\n            if la < 1 or lb < 1 or lc < 1:\n                continue\n            if la > lc or lb > lc:\n                continue\n            if not mod_check(la, lb, lc):\n                continue\n            a = s[:la]\n            b = s[la:la + lb]\n            c = s[la + lb:la * lb + lc]\n            return f'{a}+{b}={c}'\n    return ''"
    }
  ]
}