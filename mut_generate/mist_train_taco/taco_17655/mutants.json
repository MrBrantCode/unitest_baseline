{
  "task_id": "taco_17655",
  "entry_point": "min_time_to_stop_attack",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "S[b] += S[a]",
      "mutated_line": "S[b] -= S[a]",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] -= S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 1\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = -1\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 1\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if P[x] == x:",
      "mutated_line": "if P[x] != x:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] != x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] != x + 10 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] != x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return leader(x) == leader(y)",
      "mutated_line": "return leader(x) != leader(y)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) != leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a > b:",
      "mutated_line": "if a >= b:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a >= b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a > b:",
      "mutated_line": "if a <= b:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a <= b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a > b:",
      "mutated_line": "if a != b:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a != b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "S = {x: 1 for x in range(n)}",
      "mutated_line": "S = {x: 2 for x in range(n)}",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 2 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "S = {x: 1 for x in range(n)}",
      "mutated_line": "S = {x: 0 for x in range(n)}",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 0 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "S = {x: 1 for x in range(n)}",
      "mutated_line": "S = {x: 0 for x in range(n)}",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 0 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "S = {x: 1 for x in range(n)}",
      "mutated_line": "S = {x: -1 for x in range(n)}",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: -1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine - 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine - 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine * 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine * 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine - 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine - 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine * 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine * 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 5] = 2",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 2\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 5] = 0",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 0\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 5] = 0",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 0\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 5] = -1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = -1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "res += z",
      "mutated_line": "res -= z",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res -= z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x - 10 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x - 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x * 10 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x * 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 or leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 or leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine - 10 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine - 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine * 10 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine * 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 10 * 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 * 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + (10 + 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + (10 + 5)\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 10 * 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 * 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + (10 + 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + (10 + 5)\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine - 10 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine - 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine * 10 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine * 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 10 * 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 * 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + (10 + 5):",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + (10 + 5):\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) > 10 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) > 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) < 10 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) < 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) == 10 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) == 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) > 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) > 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) < 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) < 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) == 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) == 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "lis = sorted(roads, key=lambda x: -x[2])",
      "mutated_line": "lis = sorted(roads, key=lambda x: +x[2])",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: +x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 * 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 * 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + (10 + 5)] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + (10 + 5)] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 11 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 11 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 9 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 9 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 0 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 0 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 1 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 1 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + -10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + -10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 10 ** 6",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 6\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 10 ** 4",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 4\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 10 ** 0",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 0\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 10 ** 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 1\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 5] = machine + 10 ** -5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** -5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 11 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 11 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 9 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 9 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 0 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 0 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 1 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 1 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + -10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + -10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 10 ** 6",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 6\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 10 ** 4",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 4\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 10 ** 0",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 0\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 10 ** 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 1\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P[machine] = machine + 10 ** 5",
      "mutated_line": "P[machine] = machine + 10 ** -5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** -5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 * 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 * 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + (10 + 5)] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + (10 + 5)] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 11 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 11 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 9 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 9 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 0 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 0 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 1 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 1 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + -10 ** 5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + -10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 10 ** 6:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 6:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 10 ** 4:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 4:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 10 ** 0:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 0:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 10 ** 1:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 1:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if P[x] == x + 10 ** 5:",
      "mutated_line": "if P[x] == x + 10 ** -5:",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** -5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 * 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 * 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 + 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 + 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 * 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 * 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 + 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 + 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 11 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 11 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 9 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 9 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 0 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 0 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 1 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 1 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + -10 ** 5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + -10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 6] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 6] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 4] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 4] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 0] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 0] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** 1] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 1] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P[machine + 10 ** 5] = machine + 10 ** 5",
      "mutated_line": "P[machine + 10 ** -5] = machine + 10 ** 5",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** -5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 11 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 11 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 9 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 9 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 0 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 0 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 1 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 1 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + -10 ** 5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + -10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 6] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 6] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 4] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 4] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 0] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 0] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** 1] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 1] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "S[machine + 10 ** 5] = 1",
      "mutated_line": "S[machine + 10 ** -5] = 1",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** -5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 11 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 11 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 9 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 9 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 0 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 0 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 1 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 1 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= -10 ** 5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= -10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 6 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 6 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 4 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 4 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 0 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 0 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 1 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 1 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** -5 and leader(y) >= 10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** -5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 11 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 11 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 9 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 9 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 0 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 0 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 1 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 1 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= -10 ** 5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= -10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 6)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 6)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 4)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 4)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 0)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 0)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 1)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 1)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)",
      "mutated_line": "return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** -5)",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** -5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lis = sorted(roads, key=lambda x: -x[2])",
      "mutated_line": "lis = sorted(roads, key=lambda x: -x[3])",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[3])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lis = sorted(roads, key=lambda x: -x[2])",
      "mutated_line": "lis = sorted(roads, key=lambda x: -x[1])",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[1])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lis = sorted(roads, key=lambda x: -x[2])",
      "mutated_line": "lis = sorted(roads, key=lambda x: -x[0])",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[0])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lis = sorted(roads, key=lambda x: -x[2])",
      "mutated_line": "lis = sorted(roads, key=lambda x: -x[1])",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[1])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "lis = sorted(roads, key=lambda x: -x[2])",
      "mutated_line": "lis = sorted(roads, key=lambda x: -x[-2])",
      "code": "def min_time_to_stop_attack(n, k, roads, machines):\n\n    def leader(x):\n        if P[x] == x:\n            return P[x]\n        if P[x] == x + 10 ** 5:\n            return P[x]\n        P[x] = leader(P[x])\n        return P[x]\n\n    def same(x, y):\n        return leader(x) == leader(y)\n\n    def canJoin(x, y):\n        return not (leader(x) >= 10 ** 5 and leader(y) >= 10 ** 5)\n\n    def union(x, y):\n        a = leader(x)\n        b = leader(y)\n        if a > b:\n            (a, b) = (b, a)\n        S[b] += S[a]\n        P[a] = b\n    lis = sorted(roads, key=lambda x: -x[-2])\n    P = {x: x for x in range(n)}\n    S = {x: 1 for x in range(n)}\n    for machine in machines:\n        P[machine + 10 ** 5] = machine + 10 ** 5\n        P[machine] = machine + 10 ** 5\n        S[machine + 10 ** 5] = 1\n    res = 0\n    for (x, y, z) in lis:\n        if canJoin(x, y):\n            union(x, y)\n        else:\n            res += z\n    return res"
    }
  ]
}