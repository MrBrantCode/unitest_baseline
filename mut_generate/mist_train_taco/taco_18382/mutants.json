{
  "task_id": "taco_18382",
  "entry_point": "calculate_luckiness",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [-1] / A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] / A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [-1] + A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] + A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [-1] ** A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] ** A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "marked = [False] * A",
      "mutated_line": "marked = [False] / A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] / A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "marked = [False] * A",
      "mutated_line": "marked = [False] + A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] + A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "marked = [False] * A",
      "mutated_line": "marked = [False] ** A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] ** A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distTo[0] = 0",
      "mutated_line": "for (x, y) in dances:",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 1\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distTo[0] = 0",
      "mutated_line": "for (x, y) in dances:",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = -1\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distTo[0] = 0",
      "mutated_line": "for (x, y) in dances:",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 1\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distTo[0] = 0",
      "mutated_line": "for (x, y) in dances:",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[1] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distTo[0] = 0",
      "mutated_line": "for (x, y) in dances:",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[-1] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distTo[0] = 0",
      "mutated_line": "for (x, y) in dances:",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[1] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[s] = True",
      "mutated_line": "marked[s] = False",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = False\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [+1] * A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [+1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "marked = [False] * A",
      "mutated_line": "marked = [True] * A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [True] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue = deque([0])",
      "mutated_line": "queue = deque([1])",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([1])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue = deque([0])",
      "mutated_line": "queue = deque([-1])",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([-1])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue = deque([0])",
      "mutated_line": "queue = deque([1])",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([1])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "marked[w] = True",
      "mutated_line": "marked[w] = False",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = False\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distTo[w] = distTo[s] + 1",
      "mutated_line": "distTo[w] = distTo[s] - 1",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] - 1\n    return distTo[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distTo[w] = distTo[s] + 1",
      "mutated_line": "distTo[w] = distTo[s] * 1",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] * 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return distTo[1:]",
      "mutated_line": "return distTo[2:]",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return distTo[1:]",
      "mutated_line": "return distTo[0:]",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return distTo[1:]",
      "mutated_line": "return distTo[0:]",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return distTo[1:]",
      "mutated_line": "return distTo[-1:]",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[-1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [-2] * A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-2] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [-0] * A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-0] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [-0] * A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-0] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distTo = [-1] * A",
      "mutated_line": "distTo = [--1] * A",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [--1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 1\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distTo[w] = distTo[s] + 1",
      "mutated_line": "distTo[w] = distTo[s] + 2",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 2\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distTo[w] = distTo[s] + 1",
      "mutated_line": "distTo[w] = distTo[s] + 0",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 0\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distTo[w] = distTo[s] + 1",
      "mutated_line": "distTo[w] = distTo[s] + 0",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + 0\n    return distTo[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distTo[w] = distTo[s] + 1",
      "mutated_line": "distTo[w] = distTo[s] + -1",
      "code": "from collections import deque\n\ndef calculate_luckiness(A, B, dances):\n    graph = [[] for _ in range(A)]\n    distTo = [-1] * A\n    marked = [False] * A\n    distTo[0] = 0\n    for (x, y) in dances:\n        graph[x].append(y)\n        graph[y].append(x)\n    queue = deque([0])\n    while queue:\n        s = queue.popleft()\n        marked[s] = True\n        for w in graph[s]:\n            if marked[w]:\n                continue\n            queue.append(w)\n            marked[w] = True\n            distTo[w] = distTo[s] + -1\n    return distTo[1:]"
    }
  ]
}