{
  "task_id": "taco_7708",
  "entry_point": "calculate_min_cost",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "total_cost = 0",
      "mutated_line": "total_cost = 1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 1\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "total_cost = 0",
      "mutated_line": "total_cost = -1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = -1\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "total_cost = 0",
      "mutated_line": "total_cost = 1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 1\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] / (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] / (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] + (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] + (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] ** (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] ** (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] / (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] / (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] + (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] + (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] ** (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] ** (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] / (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] / (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] + (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] + (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] ** (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] ** (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curr_city = 0",
      "mutated_line": "curr_city = 1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 1\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curr_city = 0",
      "mutated_line": "curr_city = -1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = -1\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curr_city = 0",
      "mutated_line": "curr_city = 1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 1\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited[curr_city] = True",
      "mutated_line": "visited[curr_city] = False",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = False\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "total_cost += min_cost",
      "mutated_line": "total_cost -= min_cost",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost -= min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if i == n:",
      "mutated_line": "if i != n:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i != n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if j == n:",
      "mutated_line": "if j != n:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j != n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) / (abs(xi - xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) / (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return k[i] + k[j] + (abs(xi - xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return k[i] + k[j] + (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) ** (abs(xi - xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) ** (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n - 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n - 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n * 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n * 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] * (n - 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n - 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] * (n * 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n * 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] * (n - 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n - 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] * (n * 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n * 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "min_city_from = -1",
      "mutated_line": "min_city_from = +1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = +1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "min_city_to = -1",
      "mutated_line": "min_city_to = +1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = +1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "assert min_city_from != -1",
      "mutated_line": "assert min_city_from == -1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from == -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "visited[min_city_to] = True",
      "mutated_line": "visited[min_city_to] = False",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = False\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if min_city_from == n:",
      "mutated_line": "if min_city_from != n:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from != n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] - k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] - k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return k[i] * k[j] * (abs(xi - xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return k[i] * k[j] * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) * (abs(xi - xj) - abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) - abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) * (abs(xi - xj) * abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) * abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [True] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [True] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 2)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 2)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 0)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 0)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + -1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + -1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] * (n + 2)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 2)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] * (n + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 0)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] * (n + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 0)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('inf')] * (n + -1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + -1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [+1] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [+1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] * (n + 2)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 2)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] * (n + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 0)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] * (n + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 0)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-1] * (n + -1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + -1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n - 1):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n - 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n * 1):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n * 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr_city == destination:",
      "mutated_line": "if curr_city != destination:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city != destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if get_cost(curr_city, destination) < cost_cheapest[destination]:",
      "mutated_line": "if get_cost(curr_city, destination) <= cost_cheapest[destination]:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) <= cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if get_cost(curr_city, destination) < cost_cheapest[destination]:",
      "mutated_line": "if get_cost(curr_city, destination) >= cost_cheapest[destination]:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) >= cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if get_cost(curr_city, destination) < cost_cheapest[destination]:",
      "mutated_line": "if get_cost(curr_city, destination) != cost_cheapest[destination]:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) != cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "min_cost = float('inf')",
      "mutated_line": "min_cost = float('')",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_city_from = -1",
      "mutated_line": "min_city_from = -2",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -2\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_city_from = -1",
      "mutated_line": "min_city_from = -0",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -0\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_city_from = -1",
      "mutated_line": "min_city_from = -0",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -0\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_city_from = -1",
      "mutated_line": "min_city_from = --1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = --1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_city_to = -1",
      "mutated_line": "min_city_to = -2",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -2\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_city_to = -1",
      "mutated_line": "min_city_to = -0",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -0\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_city_to = -1",
      "mutated_line": "min_city_to = -0",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -0\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_city_to = -1",
      "mutated_line": "min_city_to = --1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = --1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n - 1):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n - 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n * 1):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n * 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if curr_city == destination:",
      "mutated_line": "if curr_city != destination:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city != destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if cost_cheapest[destination] < min_cost:",
      "mutated_line": "if cost_cheapest[destination] <= min_cost:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] <= min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if cost_cheapest[destination] < min_cost:",
      "mutated_line": "if cost_cheapest[destination] >= min_cost:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] >= min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if cost_cheapest[destination] < min_cost:",
      "mutated_line": "if cost_cheapest[destination] != min_cost:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] != min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "assert min_city_from != -1",
      "mutated_line": "assert min_city_from != +1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != +1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "elif min_city_to == n:",
      "mutated_line": "elif min_city_to != n:",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to != n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cost_cheapest = [float('inf')] * (n + 1)",
      "mutated_line": "cost_cheapest = [float('')] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-2] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-2] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-0] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-0] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [-0] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-0] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "from_cheapest = [-1] * (n + 1)",
      "mutated_line": "from_cheapest = [--1] * (n + 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [--1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + 2):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 2):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + 0):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 0):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + 0):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 0):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + -1):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + -1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + 2):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 2):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + 0):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 0):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + 0):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 0):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for destination in range(n + 1):",
      "mutated_line": "for destination in range(n + -1):",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + -1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert min_city_from != -1",
      "mutated_line": "assert min_city_from != -2",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -2\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert min_city_from != -1",
      "mutated_line": "assert min_city_from != -0",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -0\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert min_city_from != -1",
      "mutated_line": "assert min_city_from != -0",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -0\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert min_city_from != -1",
      "mutated_line": "assert min_city_from != --1",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != --1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "powered_cities.append(min_city_to + 1)",
      "mutated_line": "powered_cities.append(min_city_to - 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to - 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "powered_cities.append(min_city_to + 1)",
      "mutated_line": "powered_cities.append(min_city_to * 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to * 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) * (abs(xi + xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi + xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) * (abs(xi * xj) + abs(yi - yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi * xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi + yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi + yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))",
      "mutated_line": "return (k[i] + k[j]) * (abs(xi - xj) + abs(yi * yj))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi * yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "powered_cities.append(min_city_to + 1)",
      "mutated_line": "powered_cities.append(min_city_to + 2)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 2)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "powered_cities.append(min_city_to + 1)",
      "mutated_line": "powered_cities.append(min_city_to + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 0)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "powered_cities.append(min_city_to + 1)",
      "mutated_line": "powered_cities.append(min_city_to + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 0)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "powered_cities.append(min_city_to + 1)",
      "mutated_line": "powered_cities.append(min_city_to + -1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + -1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "powered_cities.append(min_city_from + 1)",
      "mutated_line": "powered_cities.append(min_city_from - 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from - 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "powered_cities.append(min_city_from + 1)",
      "mutated_line": "powered_cities.append(min_city_from * 1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from * 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "powered_cities.append(min_city_from + 1)",
      "mutated_line": "powered_cities.append(min_city_from + 2)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 2)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "powered_cities.append(min_city_from + 1)",
      "mutated_line": "powered_cities.append(min_city_from + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 0)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "powered_cities.append(min_city_from + 1)",
      "mutated_line": "powered_cities.append(min_city_from + 0)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 0)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "powered_cities.append(min_city_from + 1)",
      "mutated_line": "powered_cities.append(min_city_from + -1)",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + -1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from - 1, min_city_to + 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from - 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from * 1, min_city_to + 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from * 1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 1, min_city_to - 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to - 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 1, min_city_to * 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to * 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 2, min_city_to + 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 2, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 0, min_city_to + 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 0, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 0, min_city_to + 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 0, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + -1, min_city_to + 1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + -1, min_city_to + 1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 1, min_city_to + 2))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 2))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 1, min_city_to + 0))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 0))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 1, min_city_to + 0))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + 0))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "connected_cities.append((min_city_from + 1, min_city_to + 1))",
      "mutated_line": "connected_cities.append((min_city_from + 1, min_city_to + -1))",
      "code": "def calculate_min_cost(n, xy, c, k):\n\n    def get_cost(i, j):\n        if i == n:\n            return c[j]\n        if j == n:\n            return c[i]\n        (xi, yi) = xy[i]\n        (xj, yj) = xy[j]\n        return (k[i] + k[j]) * (abs(xi - xj) + abs(yi - yj))\n    total_cost = 0\n    powered_cities = []\n    connected_cities = []\n    visited = [False] * (n + 1)\n    cost_cheapest = [float('inf')] * (n + 1)\n    from_cheapest = [-1] * (n + 1)\n    curr_city = 0\n    visited[curr_city] = True\n    for _ in range(n):\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if get_cost(curr_city, destination) < cost_cheapest[destination]:\n                cost_cheapest[destination] = get_cost(curr_city, destination)\n                from_cheapest[destination] = curr_city\n        min_cost = float('inf')\n        min_city_from = -1\n        min_city_to = -1\n        for destination in range(n + 1):\n            if curr_city == destination:\n                continue\n            if visited[destination]:\n                continue\n            if cost_cheapest[destination] < min_cost:\n                min_cost = cost_cheapest[destination]\n                min_city_from = from_cheapest[destination]\n                min_city_to = destination\n        assert min_city_from != -1\n        total_cost += min_cost\n        visited[min_city_to] = True\n        if min_city_from == n:\n            powered_cities.append(min_city_to + 1)\n        elif min_city_to == n:\n            powered_cities.append(min_city_from + 1)\n        else:\n            connected_cities.append((min_city_from + 1, min_city_to + -1))\n        curr_city = min_city_to\n    return (total_cost, powered_cities, connected_cities)"
    }
  ]
}