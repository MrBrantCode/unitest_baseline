{
  "task_id": "taco_18347",
  "entry_point": "running_median",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(H) > len(L):",
      "mutated_line": "if len(H) >= len(L):",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) >= len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(H) > len(L):",
      "mutated_line": "if len(H) <= len(L):",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) <= len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(H) > len(L):",
      "mutated_line": "if len(H) != len(L):",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) != len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif len(H) > len(L):",
      "mutated_line": "elif len(H) >= len(L):",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) >= len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif len(H) > len(L):",
      "mutated_line": "elif len(H) <= len(L):",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) <= len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif len(H) > len(L):",
      "mutated_line": "elif len(H) != len(L):",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) != len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if H[0] < num:",
      "mutated_line": "if H[0] <= num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] <= num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if H[0] < num:",
      "mutated_line": "if H[0] >= num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] >= num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if H[0] < num:",
      "mutated_line": "if H[0] != num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] != num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif -L[0] >= num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] >= num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif -L[0] <= num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] <= num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif -L[0] != num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] != num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif +L[0] > num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif +L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "b = -heapq.heappushpop(L, -num)",
      "mutated_line": "b = +heapq.heappushpop(L, -num)",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = +heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[0], 2))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 2))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[0], 0))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 0))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[0], 0))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 0))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[0], -1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], -1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) * 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) * 2, 1))\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) // 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) // 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 2, 2))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 2))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 2, 0))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 0))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 2, 0))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 0))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 2, -1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, -1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if H[0] < num:",
      "mutated_line": "if H[1] < num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[1] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if H[0] < num:",
      "mutated_line": "if H[-1] < num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[-1] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if H[0] < num:",
      "mutated_line": "if H[1] < num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[1] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "heapq.heappush(L, -b)",
      "mutated_line": "heapq.heappush(L, +b)",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, +b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "heapq.heappush(L, -num)",
      "mutated_line": "heapq.heappush(L, +num)",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, +num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[1], 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[1], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[-1], 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[-1], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "medians.append(round(H[0], 1))",
      "mutated_line": "medians.append(round(H[1], 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[1], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] + L[0]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] + L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round(H[0] * L[0] / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round(H[0] * L[0] / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 3, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 3, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 1, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 1, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 0, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 0, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / 1, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 1, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[0]) / -2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / -2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif -L[1] > num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[1] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif -L[-1] > num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[-1] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif -L[0] > num:",
      "mutated_line": "elif -L[1] > num:",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[1] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "b = -heapq.heappushpop(L, -num)",
      "mutated_line": "b = -heapq.heappushpop(L, +num)",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, +num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[1] - L[0]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[1] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[-1] - L[0]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[-1] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[1] - L[0]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[1] - L[0]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[1]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[1]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[-1]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[-1]) / 2, 1))\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "medians.append(round((H[0] - L[0]) / 2, 1))",
      "mutated_line": "medians.append(round((H[0] - L[1]) / 2, 1))",
      "code": "import heapq\n\ndef running_median(a):\n    (L, H) = ([], [])\n    medians = []\n    for num in a:\n        if not H:\n            heapq.heappush(H, num)\n        elif len(H) > len(L):\n            if H[0] < num:\n                b = heapq.heappushpop(H, num)\n                heapq.heappush(L, -b)\n            else:\n                heapq.heappush(L, -num)\n        elif -L[0] > num:\n            b = -heapq.heappushpop(L, -num)\n            heapq.heappush(H, b)\n        else:\n            heapq.heappush(H, num)\n        if len(H) > len(L):\n            medians.append(round(H[0], 1))\n        else:\n            medians.append(round((H[0] - L[1]) / 2, 1))\n    return medians"
    }
  ]
}