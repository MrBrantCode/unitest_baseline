{
  "task_id": "taco_504",
  "entry_point": "minimize_workload_difference",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 - 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 * 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 - 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 - 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 * 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 * 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 * 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 + 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 8\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 6\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 0\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 1\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + -7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 * 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 * 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 + 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 + 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 + 10",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 10\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 8\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 0\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 1\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 9 + -9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + -9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if p == 1:",
      "mutated_line": "if p != 1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p != 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n != 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cans = 0",
      "mutated_line": "cans = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 1\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cans = 0",
      "mutated_line": "cans = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = -1\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cans = 0",
      "mutated_line": "cans = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 1\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "carry = 0",
      "mutated_line": "carry = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 1\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "carry = 0",
      "mutated_line": "carry = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = -1\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "carry = 0",
      "mutated_line": "carry = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 1\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 1\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = -1\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 1\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ra = 0",
      "mutated_line": "ra = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 1\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ra = 0",
      "mutated_line": "ra = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = -1\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ra = 0",
      "mutated_line": "ra = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 1\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 11 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 9 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 0 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 1 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = -10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 10 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 8 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 0 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 1 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** -9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 11 ** 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 11 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 9 ** 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 9 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 0 ** 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 0 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 1 ** 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 1 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = -10 ** 9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = -10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 10 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 10 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 8 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 8 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 0 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 0 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** 1 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 1 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10**9 + 9",
      "mutated_line": "mod = 10 ** -9 + 9",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** -9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if p == 1:",
      "mutated_line": "if p == 2:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 2:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if p == 1:",
      "mutated_line": "if p == 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 0:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if p == 1:",
      "mutated_line": "if p == 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 0:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if p == 1:",
      "mutated_line": "if p == -1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == -1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if n & 1:",
      "mutated_line": "if n | 1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n | 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 2:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 0:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 0:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == -1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if carry == 0:",
      "mutated_line": "if carry != 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry != 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = (res + pow(p, a, mod)) % mod",
      "mutated_line": "res = (res + pow(p, a, mod)) * mod",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) * mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = (res + pow(p, a, mod)) % mod",
      "mutated_line": "res = res + pow(p, a, mod) + mod",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = res + pow(p, a, mod) + mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ra = (ra + pow(p, a, MOD)) % MOD",
      "mutated_line": "ra = (ra + pow(p, a, MOD)) * MOD",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) * MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ra = (ra + pow(p, a, MOD)) % MOD",
      "mutated_line": "ra = ra + pow(p, a, MOD) + MOD",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = ra + pow(p, a, MOD) + MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if res == carry and ra == cans:",
      "mutated_line": "if res == carry or ra == cans:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry or ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "results.append((cans - ra) % MOD)",
      "mutated_line": "results.append((cans - ra) * MOD)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) * MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "results.append((cans - ra) % MOD)",
      "mutated_line": "results.append(cans - ra + MOD)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append(cans - ra + MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 2:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 2:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 0:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 0:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 0:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n & 1:",
      "mutated_line": "if n & -1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & -1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "A.sort(reverse=True)",
      "mutated_line": "A.sort(reverse=False)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=False)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if carry == 0:",
      "mutated_line": "if carry == 1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 1:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if carry == 0:",
      "mutated_line": "if carry == -1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == -1:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if carry == 0:",
      "mutated_line": "if carry == 1:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 1:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = (res + pow(p, a, mod)) % mod",
      "mutated_line": "res = (res - pow(p, a, mod)) % mod",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res - pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = (res + pow(p, a, mod)) % mod",
      "mutated_line": "res = res * pow(p, a, mod) % mod",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = res * pow(p, a, mod) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ra = (ra + pow(p, a, MOD)) % MOD",
      "mutated_line": "ra = (ra - pow(p, a, MOD)) % MOD",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra - pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ra = (ra + pow(p, a, MOD)) % MOD",
      "mutated_line": "ra = ra * pow(p, a, MOD) % MOD",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = ra * pow(p, a, MOD) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if res == carry and ra == cans:",
      "mutated_line": "if res != carry and ra == cans:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res != carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if res == carry and ra == cans:",
      "mutated_line": "if res == carry and ra != cans:",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra != cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "carry = 0",
      "mutated_line": "carry = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 1\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "carry = 0",
      "mutated_line": "carry = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = -1\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "carry = 0",
      "mutated_line": "carry = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 1\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cans = 0",
      "mutated_line": "cans = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 1\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cans = 0",
      "mutated_line": "cans = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = -1\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cans = 0",
      "mutated_line": "cans = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 1\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ra = 0",
      "mutated_line": "ra = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 1\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ra = 0",
      "mutated_line": "ra = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = -1\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ra = 0",
      "mutated_line": "ra = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 1\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 1\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = -1\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 1\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "results.append((cans - ra) % MOD)",
      "mutated_line": "results.append((cans + ra) % MOD)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans + ra) % MOD)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "results.append((cans - ra) % MOD)",
      "mutated_line": "results.append(cans * ra % MOD)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append(cans * ra % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(2)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(2)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(0)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(0)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(0)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(0)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(1)",
      "mutated_line": "results.append(-1)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(-1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(1)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(-1)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(1)\n            continue\n        if n == 1:\n            results.append(pow(p, A[0], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "results.append(pow(p, A[0], MOD))",
      "mutated_line": "results.append(pow(p, A[1], MOD))",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[1], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "results.append(pow(p, A[0], MOD))",
      "mutated_line": "results.append(pow(p, A[-1], MOD))",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[-1], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "results.append(pow(p, A[0], MOD))",
      "mutated_line": "results.append(pow(p, A[1], MOD))",
      "code": "def minimize_workload_difference(t, test_cases):\n    MOD = 10 ** 9 + 7\n    mod = 10 ** 9 + 9\n    results = []\n    for qu in range(t):\n        (n, p, k_i) = test_cases[qu]\n        A = k_i\n        if p == 1:\n            if n & 1:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        if n == 1:\n            results.append(pow(p, A[1], MOD))\n            continue\n        A.sort(reverse=True)\n        cans = 0\n        carry = 0\n        res = 0\n        ra = 0\n        for a in A:\n            if carry == 0:\n                carry = pow(p, a, mod)\n                cans = pow(p, a, MOD)\n                continue\n            res = (res + pow(p, a, mod)) % mod\n            ra = (ra + pow(p, a, MOD)) % MOD\n            if res == carry and ra == cans:\n                carry = 0\n                cans = 0\n                ra = 0\n                res = 0\n        results.append((cans - ra) % MOD)\n    return results"
    }
  ]
}