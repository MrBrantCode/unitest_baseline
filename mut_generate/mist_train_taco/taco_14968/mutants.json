{
  "task_id": "taco_14968",
  "entry_point": "calculate_alice_score",
  "mutant_count": 151,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "mi = 0",
      "mutated_line": "mi = 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 1\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "mi = 0",
      "mutated_line": "mi = -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = -1\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "mi = 0",
      "mutated_line": "mi = 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 1\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 2 - 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 - 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 2 * 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 * 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi >= 1:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi >= 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi <= 1:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi <= 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi != 1:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi != 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if S[i] == '0':",
      "mutated_line": "if S[i] != '0':",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] != '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 2 >= min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 >= min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 2 <= min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 <= min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 2 != min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 != min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return True\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) / 2 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) / 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) * 2 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) * 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 2 + 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 2\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 2 + 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 0\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 2 + 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 0\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 2 + -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + -1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma + mi > 1:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma + mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma * mi > 1:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma * mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi > 2:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 2:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi > 0:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 0:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi > 0:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 0:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "while ma - mi > 1:",
      "mutated_line": "while ma - mi > -1:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > -1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) / 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) / 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) * 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) * 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if S[i] == '0':",
      "mutated_line": "if S[i] == '':",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif S[i] == '1':",
      "mutated_line": "elif S[i] != '1':",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] != '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns / 2 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns / 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns + 2 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns + 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns ** 2 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns ** 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return True\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for c0 in range(num_turns + 1):",
      "mutated_line": "for c0 in range(num_turns - 1):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns - 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for c0 in range(num_turns + 1):",
      "mutated_line": "for c0 in range(num_turns * 1):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns * 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c1 = num_turns - c0",
      "mutated_line": "c1 = num_turns + c0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns + c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c1 = num_turns - c0",
      "mutated_line": "c1 = num_turns * c0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns * c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns + c0 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 + 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = (num_turns + c0) * 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = (num_turns + c0) * 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cur_1 = len(pos1) - (num_turns + c1)",
      "mutated_line": "cur_1 = len(pos1) + (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) + (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cur_1 = len(pos1) - (num_turns + c1)",
      "mutated_line": "cur_1 = len(pos1) * (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) * (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - 1 + (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 + (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = (len(pos1) - 1) * (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = (len(pos1) - 1) * (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p0 = num_turns + c0",
      "mutated_line": "p0 = num_turns - c0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns - c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p0 = num_turns + c0",
      "mutated_line": "p0 = num_turns * c0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns * c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "split_good = True",
      "mutated_line": "split_good = False",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = False\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 3 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 3 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 1 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 1 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 0 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 0 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // 1 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 1 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ma = min(len(pos0), len(pos1)) // 2 + 1",
      "mutated_line": "ma = min(len(pos0), len(pos1)) // -2 + 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // -2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi - ma) // 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi - ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = mi * ma // 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = mi * ma // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) // 3",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 3\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) // 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 1\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) // 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 0\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) // 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 1\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "md = (mi + ma) // 2",
      "mutated_line": "md = (mi + ma) // -2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // -2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif S[i] == '1':",
      "mutated_line": "elif S[i] == '':",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "assert False  # This should never happen with a valid binary string",
      "mutated_line": "assert True",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert True\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 3 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 3 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 1 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 1 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 0 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 0 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * 1 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 1 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if num_turns * 2 > min(len(pos0), len(pos1)):",
      "mutated_line": "if num_turns * -2 > min(len(pos0), len(pos1)):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * -2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c0 in range(num_turns + 1):",
      "mutated_line": "for c0 in range(num_turns + 2):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 2):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c0 in range(num_turns + 1):",
      "mutated_line": "for c0 in range(num_turns + 0):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 0):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c0 in range(num_turns + 1):",
      "mutated_line": "for c0 in range(num_turns + 0):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 0):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for c0 in range(num_turns + 1):",
      "mutated_line": "for c0 in range(num_turns + -1):",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + -1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns - c0 - 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns - c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns * c0 - 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns * c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns + c0 - 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 2\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns + c0 - 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 0\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns + c0 - 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 0\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur_0 = num_turns + c0 - 1",
      "mutated_line": "cur_0 = num_turns + c0 - -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - -1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cur_1 = len(pos1) - (num_turns + c1)",
      "mutated_line": "cur_1 = len(pos1) - (num_turns - c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns - c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cur_1 = len(pos1) - (num_turns + c1)",
      "mutated_line": "cur_1 = len(pos1) - num_turns * c1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - num_turns * c1\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) + 1 - (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) + 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) * 1 - (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) * 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - 1 - (num_turns - c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns - c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - 1 - num_turns * c1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - num_turns * c1\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pos0[cur_0] < pos1[cur_1]:",
      "mutated_line": "if pos0[cur_0] <= pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] <= pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pos0[cur_0] < pos1[cur_1]:",
      "mutated_line": "if pos0[cur_0] >= pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] >= pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pos0[cur_0] < pos1[cur_1]:",
      "mutated_line": "if pos0[cur_0] != pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] != pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 += 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 += 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 -= 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 -= 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > 0 or pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 or pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "p0 += 1",
      "mutated_line": "p0 -= 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 -= 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 -= 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 -= 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "num_1 -= 1",
      "mutated_line": "num_1 += 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 += 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return False\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - 2 - (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 2 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - 0 - (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 0 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - 0 - (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 0 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1 = len(pos1) - 1 - (num_turns + c1)",
      "mutated_line": "p1 = len(pos1) - -1 - (num_turns + c1)",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - -1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 2\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 0\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 0\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= -1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 2\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 0\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 0\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += -1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "split_good = False",
      "mutated_line": "split_good = True",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = True\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 >= 0 and pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 >= 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 <= 0 and pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 <= 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 != 0 and pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 != 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > 0 and pos0[p0] <= pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] <= pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > 0 and pos0[p0] >= pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] >= pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > 0 and pos0[p0] != pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] != pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p0 += 1",
      "mutated_line": "p0 += 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 2\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p0 += 1",
      "mutated_line": "p0 += 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 0\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p0 += 1",
      "mutated_line": "p0 += 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 0\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p0 += 1",
      "mutated_line": "p0 += -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += -1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 2\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 0\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 0\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur_1 += 1",
      "mutated_line": "cur_1 += -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += -1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "num_1 -= 1",
      "mutated_line": "num_1 -= 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 2\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "num_1 -= 1",
      "mutated_line": "num_1 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 0\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "num_1 -= 1",
      "mutated_line": "num_1 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 0\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "num_1 -= 1",
      "mutated_line": "num_1 -= -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= -1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > 0 or pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 or pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 += 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 += 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "p1 -= 1",
      "mutated_line": "p1 += 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 += 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "num_0 -= 1",
      "mutated_line": "num_0 += 1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 += 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > 1 and pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 1 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > -1 and pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > -1 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num_1 > 0 and pos0[p0] < pos1[cur_1]:",
      "mutated_line": "if num_1 > 1 and pos0[p0] < pos1[cur_1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 1 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 >= 0 and pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 >= 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 <= 0 and pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 <= 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 != 0 and pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 != 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > 0 and pos0[cur_0] <= pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] <= pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > 0 and pos0[cur_0] >= pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] >= pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > 0 and pos0[cur_0] != pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] != pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 2\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 0\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 0\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cur_0 -= 1",
      "mutated_line": "cur_0 -= -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= -1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "p1 -= 1",
      "mutated_line": "p1 -= 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 2\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "p1 -= 1",
      "mutated_line": "p1 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 0\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "p1 -= 1",
      "mutated_line": "p1 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 0\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "p1 -= 1",
      "mutated_line": "p1 -= -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= -1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "num_0 -= 1",
      "mutated_line": "num_0 -= 2",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 2\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "num_0 -= 1",
      "mutated_line": "num_0 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 0\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "num_0 -= 1",
      "mutated_line": "num_0 -= 0",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 0\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "num_0 -= 1",
      "mutated_line": "num_0 -= -1",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= -1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "split_good = False",
      "mutated_line": "split_good = True",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 0 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = True\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > 1 and pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 1 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > -1 and pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > -1 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif num_0 > 0 and pos0[cur_0] < pos1[p1]:",
      "mutated_line": "elif num_0 > 1 and pos0[cur_0] < pos1[p1]:",
      "code": "def calculate_alice_score(S: str) -> int:\n    N = len(S)\n    pos0 = []\n    pos1 = []\n    for i in range(N):\n        if S[i] == '0':\n            pos0.append(i)\n        elif S[i] == '1':\n            pos1.append(i)\n        else:\n            assert False\n\n    def is_good(num_turns: int) -> bool:\n        if num_turns * 2 > min(len(pos0), len(pos1)):\n            return False\n        for c0 in range(num_turns + 1):\n            c1 = num_turns - c0\n            cur_0 = num_turns + c0 - 1\n            cur_1 = len(pos1) - (num_turns + c1)\n            p1 = len(pos1) - 1 - (num_turns + c1)\n            p0 = num_turns + c0\n            num_0 = c0\n            num_1 = c1\n            split_good = True\n            for t in range(num_turns):\n                if pos0[cur_0] < pos1[cur_1]:\n                    cur_0 -= 1\n                    cur_1 += 1\n                else:\n                    split_good = False\n                    break\n                if num_1 > 0 and pos0[p0] < pos1[cur_1]:\n                    p0 += 1\n                    cur_1 += 1\n                    num_1 -= 1\n                elif num_0 > 1 and pos0[cur_0] < pos1[p1]:\n                    cur_0 -= 1\n                    p1 -= 1\n                    num_0 -= 1\n                else:\n                    split_good = False\n                    break\n            if split_good:\n                return True\n        return False\n    mi = 0\n    ma = min(len(pos0), len(pos1)) // 2 + 1\n    while ma - mi > 1:\n        md = (mi + ma) // 2\n        if is_good(md):\n            mi = md\n        else:\n            ma = md\n    return mi"
    }
  ]
}