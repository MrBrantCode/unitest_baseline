{
  "task_id": "taco_11312",
  "entry_point": "minimum_steps_to_destroy_graph",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] / n",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] / n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] + n",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] + n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] ** n",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] ** n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 1] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] -= 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 1] += 2",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 2\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 1] += 0",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 0\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 1] += 0",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 0\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 1] += -1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += -1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if out[i] == 0:",
      "mutated_line": "if out[i] != 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] != 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] += 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [1] * n",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [1] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [-1] * n",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [-1] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [1] * n",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [1] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u + 1] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u + 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u * 1] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u * 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if out[i] == 0:",
      "mutated_line": "if out[i] == 1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 1:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if out[i] == 0:",
      "mutated_line": "if out[i] == -1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == -1:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if out[i] == 0:",
      "mutated_line": "if out[i] == 1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 1:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = q.pop(0)",
      "mutated_line": "a = q.pop(1)",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(1)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = q.pop(0)",
      "mutated_line": "a = q.pop(-1)",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(-1)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = q.pop(0)",
      "mutated_line": "a = q.pop(1)",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(1)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] += 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= 2",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 2\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= 0",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 0\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= 0",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 0\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= -1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= -1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] != 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] != 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 2] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 2] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 0] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 0] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - 0] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 0] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "out[u - 1] += 1",
      "mutated_line": "out[u - -1] += 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - -1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u + 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u + 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u * 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u * 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 1, v + 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v + 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 1, v * 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v * 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "b = q.pop(0)",
      "mutated_line": "b = q.pop(1)",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(1)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "b = q.pop(0)",
      "mutated_line": "b = q.pop(-1)",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(-1)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "b = q.pop(0)",
      "mutated_line": "b = q.pop(1)",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(1)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= 2",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 2\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= 0",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 0\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= 0",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 0\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[0]] -= -1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= -1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] != 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] != 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] == 1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 1:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] == -1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == -1:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] == 1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 1:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v + 1].append((u - 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v + 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v * 1].append((u - 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v * 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 2, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 2, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 0, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 0, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 0, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 0, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - -1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - -1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 1, v - 2))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 2))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 1, v - 0))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 0))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 1, v - 0))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 0))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 1].append((u - 1, v - -1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - -1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] == 1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 1:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] == -1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == -1:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[0]] == 1:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 1:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([3, a + 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([3, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([1, a + 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([1, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([0, a + 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([0, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([1, a + 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([1, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([-2, a + 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([-2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a - 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a - 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a * 1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a * 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 1, b - 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b - 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 1, b * 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b * 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([2, a + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([2, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([0, a + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([0, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([0, a + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([0, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([-1, a + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([-1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([1, a - 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a - 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([1, a * 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a * 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[1]] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[1]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[-1]] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[-1]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[1]] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[1]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 2].append((u - 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 2].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 0].append((u - 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 0].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - 0].append((u - 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 0].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind[v - 1].append((u - 1, v - 1))",
      "mutated_line": "ind[v - -1].append((u - 1, v - 1))",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - -1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[1]] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[1]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[-1]] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[-1]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "out[elem[0]] -= 1",
      "mutated_line": "out[elem[1]] -= 1",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[1]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 2, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 2, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 0, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 0, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 0, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 0, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + -1, b + 1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + -1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 1, b + 2])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 2])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 1, b + 0])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 0])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 1, b + 0])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 0])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans.append([2, a + 1, b + 1])",
      "mutated_line": "ans.append([2, a + 1, b + -1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + -1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([1, a + 2])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 2])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([1, a + 0])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 0])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([1, a + 0])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 0])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([1, a + 1])",
      "mutated_line": "ans.append([1, a + -1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + -1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[1]] == 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[1]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[-1]] == 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[-1]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[1]] == 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[1]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q.append(elem[0])",
      "mutated_line": "q.append(elem[1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[1])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q.append(elem[0])",
      "mutated_line": "q.append(elem[-1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[-1])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "q.append(elem[0])",
      "mutated_line": "q.append(elem[1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[1])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[1]] == 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[1]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[-1]] == 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[-1]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if out[elem[0]] == 0:",
      "mutated_line": "if out[elem[1]] == 0:",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[1]] == 0:\n                    q.append(elem[0])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q.append(elem[0])",
      "mutated_line": "q.append(elem[1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[1])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q.append(elem[0])",
      "mutated_line": "q.append(elem[-1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[-1])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q.append(elem[0])",
      "mutated_line": "q.append(elem[1])",
      "code": "def minimum_steps_to_destroy_graph(n, m, edges):\n    ind = [[] for _ in range(n)]\n    out = [0] * n\n    for (u, v) in edges:\n        out[u - 1] += 1\n        ind[v - 1].append((u - 1, v - 1))\n    q = []\n    for i in range(n):\n        if out[i] == 0:\n            q.append(i)\n    ans = []\n    while q:\n        a = q.pop(0)\n        a1 = ind[a]\n        if q:\n            b = q.pop(0)\n            b1 = ind[b]\n            for elem in b1:\n                out[elem[0]] -= 1\n            for elem in b1:\n                if out[elem[0]] == 0:\n                    q.append(elem[1])\n            ans.append([2, a + 1, b + 1])\n        else:\n            ans.append([1, a + 1])\n        for elem in a1:\n            out[elem[0]] -= 1\n        for elem in a1:\n            if out[elem[0]] == 0:\n                q.append(elem[0])\n    S = len(ans)\n    return (S, ans)"
    }
  ]
}