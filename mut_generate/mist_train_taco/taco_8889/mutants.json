{
  "task_id": "taco_8889",
  "entry_point": "find_max_n",
  "mutant_count": 147,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "A = p / q",
      "mutated_line": "A = p * q",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p * q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "A = p / q",
      "mutated_line": "A = p // q",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p // q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = 1",
      "mutated_line": "n = 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 2\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = 1",
      "mutated_line": "n = 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 0\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = 1",
      "mutated_line": "n = 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 0\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = 1",
      "mutated_line": "n = -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = -1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prime_count = 0",
      "mutated_line": "prime_count = 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 1\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prime_count = 0",
      "mutated_line": "prime_count = -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = -1\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prime_count = 0",
      "mutated_line": "prime_count = 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 1\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "palindromic_count = 1",
      "mutated_line": "palindromic_count = 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 2\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "palindromic_count = 1",
      "mutated_line": "palindromic_count = 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 0\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "palindromic_count = 1",
      "mutated_line": "palindromic_count = 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 0\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "palindromic_count = 1",
      "mutated_line": "palindromic_count = -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = -1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "check_again = False",
      "mutated_line": "check_again = True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = True\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while False:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "n += 1",
      "mutated_line": "n -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n -= 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n + 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n + 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n * 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n * 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n - 10000",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n - 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n * 10000",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n * 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "delta = 0",
      "mutated_line": "delta = 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 1\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "delta = 0",
      "mutated_line": "delta = -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = -1\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "delta = 0",
      "mutated_line": "delta = 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 1\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "last_good = False",
      "mutated_line": "last_good = True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = True\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while n < check_to:",
      "mutated_line": "while n <= check_to:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n <= check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while n < check_to:",
      "mutated_line": "while n >= check_to:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n >= check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while n < check_to:",
      "mutated_line": "while n != check_to:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n != check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "n += 1",
      "mutated_line": "n -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n -= 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "delta += 1",
      "mutated_line": "delta -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta -= 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 58,
      "original_line": "if good_n == 1:",
      "mutated_line": "return 'Palindromic tree is better than splay tree'",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n != 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n <= 2:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n <= 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n >= 2:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n >= 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n != 2:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n != 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return False\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return n_str == n_str[::-1]",
      "mutated_line": "return n_str != n_str[::-1]",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str != n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n += 1",
      "mutated_line": "n += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 2\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 0\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 0\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n += 1",
      "mutated_line": "n += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += -1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count -= 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count -= 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 2\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 0\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 0\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - -1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n + 10001",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10001\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n + 9999",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 9999\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n + 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 0\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n + 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 1\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "check_to = n + 10000",
      "mutated_line": "check_to = n + -10000",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + -10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n += 1",
      "mutated_line": "n += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 2\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 0\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 0\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n += 1",
      "mutated_line": "n += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += -1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "delta += 1",
      "mutated_line": "delta += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 2\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "delta += 1",
      "mutated_line": "delta += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 0\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "delta += 1",
      "mutated_line": "delta += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 0\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "delta += 1",
      "mutated_line": "delta += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += -1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count -= 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count -= 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count -= 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "if good_n == 1:",
      "mutated_line": "return 'Palindromic tree is better than splay tree'",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 2:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "if good_n == 1:",
      "mutated_line": "return 'Palindromic tree is better than splay tree'",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 0:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "if good_n == 1:",
      "mutated_line": "return 'Palindromic tree is better than splay tree'",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 0:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "if good_n == 1:",
      "mutated_line": "return 'Palindromic tree is better than splay tree'",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == -1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return \"Palindromic tree is better than splay tree\"",
      "mutated_line": "return ''",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return ''\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 3:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 3:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 1:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 0:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 0:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 1:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 2:",
      "mutated_line": "if n < -2:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < -2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return True\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(3, int(n ** 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(3, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(1, int(n ** 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(1, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(0, int(n ** 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(0, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(1, int(n ** 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(1, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(-2, int(n ** 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(-2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0.5) - 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) - 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0.5) * 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) * 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n % div == 0:",
      "mutated_line": "if n % div != 0:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div != 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 2\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 0\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 0\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += -1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "check_again = True",
      "mutated_line": "check_again = False",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = False\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 2\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 0\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 0\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += -1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "check_again = True",
      "mutated_line": "check_again = False",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = False\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check_again = False",
      "mutated_line": "check_again = True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = True\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if prime_count > A * palindromic_count:",
      "mutated_line": "if prime_count >= A * palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count >= A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if prime_count > A * palindromic_count:",
      "mutated_line": "if prime_count <= A * palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if prime_count > A * palindromic_count:",
      "mutated_line": "if prime_count != A * palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count != A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 2\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 0\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 0\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "prime_count += 1",
      "mutated_line": "prime_count += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += -1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "check_again = True",
      "mutated_line": "check_again = False",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = False\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 2\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 0\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 0\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "palindromic_count += 1",
      "mutated_line": "palindromic_count += -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += -1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "check_again = True",
      "mutated_line": "check_again = False",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = False\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "check_again = False",
      "mutated_line": "check_again = True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = True\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if prime_count <= A * palindromic_count:",
      "mutated_line": "if prime_count < A * palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count < A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if prime_count <= A * palindromic_count:",
      "mutated_line": "if prime_count > A * palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if prime_count <= A * palindromic_count:",
      "mutated_line": "if prime_count == A * palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count == A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "check_to += delta",
      "mutated_line": "check_to -= delta",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to -= delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0.5) + 2):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 2):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0.5) + 0):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 0):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0.5) + 0):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 0):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0.5) + -1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + -1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n % div == 0:",
      "mutated_line": "if n * div == 0:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n * div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n % div == 0:",
      "mutated_line": "if n + div == 0:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n + div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % div == 0:",
      "mutated_line": "if n % div == 1:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 1:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % div == 0:",
      "mutated_line": "if n % div == -1:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == -1:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % div == 0:",
      "mutated_line": "if n % div == 1:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 1:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return True\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if prime_count > A * palindromic_count:",
      "mutated_line": "if prime_count > A / palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A / palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if prime_count > A * palindromic_count:",
      "mutated_line": "if prime_count > A + palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A + palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if prime_count > A * palindromic_count:",
      "mutated_line": "if prime_count > A ** palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A ** palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if prime_count <= A * palindromic_count:",
      "mutated_line": "if prime_count <= A / palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A / palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if prime_count <= A * palindromic_count:",
      "mutated_line": "if prime_count <= A + palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A + palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if prime_count <= A * palindromic_count:",
      "mutated_line": "if prime_count <= A ** palindromic_count:",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A ** palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "delta = 0",
      "mutated_line": "delta = 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 1\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "delta = 0",
      "mutated_line": "delta = -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = -1\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "delta = 0",
      "mutated_line": "delta = 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 1\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "last_good = True",
      "mutated_line": "last_good = False",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = False\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n * 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n * 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n + 0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n + 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "return n_str == n_str[::-1]",
      "mutated_line": "return n_str == n_str[::+1]",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::+1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "last_good = False",
      "mutated_line": "last_good = True",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = True\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n + 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n + 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n * 1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n * 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 1.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 1.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** -0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** -0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 0) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** 1) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 1) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for div in range(2, int(n ** 0.5) + 1):",
      "mutated_line": "for div in range(2, int(n ** -0.5) + 1):",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** -0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return n_str == n_str[::-1]",
      "mutated_line": "return n_str == n_str[::-2]",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-2]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return n_str == n_str[::-1]",
      "mutated_line": "return n_str == n_str[::-0]",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-0]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return n_str == n_str[::-1]",
      "mutated_line": "return n_str == n_str[::-0]",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-0]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return n_str == n_str[::-1]",
      "mutated_line": "return n_str == n_str[::--1]",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::--1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - 2",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 2\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 0\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - 0",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - 0\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "good_n = n - 1",
      "mutated_line": "good_n = n - -1",
      "code": "def find_max_n(p, q):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for div in range(2, int(n ** 0.5) + 1):\n            if n % div == 0:\n                return False\n        return True\n\n    def is_palindromic(n):\n        n_str = str(n)\n        return n_str == n_str[::-1]\n    A = p / q\n    n = 1\n    prime_count = 0\n    palindromic_count = 1\n    check_again = False\n    while True:\n        n += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count > A * palindromic_count:\n                break\n    good_n = n - 1\n    check_to = n + 10000\n    delta = 0\n    last_good = False\n    while n < check_to:\n        n += 1\n        delta += 1\n        if is_prime(n):\n            prime_count += 1\n            check_again = True\n        if is_palindromic(n):\n            palindromic_count += 1\n            check_again = True\n        if check_again:\n            check_again = False\n            if prime_count <= A * palindromic_count:\n                good_n = n\n                check_to += delta\n                delta = 0\n                last_good = True\n            elif last_good:\n                last_good = False\n                good_n = n - -1\n    if good_n == 1:\n        return 'Palindromic tree is better than splay tree'\n    return good_n"
    }
  ]
}