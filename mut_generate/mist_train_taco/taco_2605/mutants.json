{
  "task_id": "taco_2605",
  "entry_point": "minimal_reversals",
  "mutant_count": 171,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if (len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)) and (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if (len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)) and (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[0] != w[-1]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] != w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if (len(same_1) > 0 or len(same_0) == 0 or len(zero_1) == 0 or (len(one_0) == 0)) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if (len(same_1) > 0 or len(same_0) == 0 or len(zero_1) == 0 or (len(one_0) == 0)) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 or len(same_1) == 0 or len(zero_1) == 0 or (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 or len(same_1) == 0 or len(zero_1) == 0 or (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 or len(same_1) > 0 or len(zero_1) == 0 or (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 or len(same_1) > 0 or len(zero_1) == 0 or (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if w[0] == '0':",
      "mutated_line": "if w[0] != '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] != '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' or w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' or w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) >= 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) >= 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) <= 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) <= 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) != 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) != 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) != 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) != 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) != 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) != 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) != 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) != 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) >= 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) >= 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) <= 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) <= 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) != 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) != 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) != 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) != 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) != 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) != 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) != 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) != 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) >= 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) >= 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) <= 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) <= 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) != 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) != 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) >= 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) >= 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) <= 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) <= 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) != 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) != 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) != 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) != 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) != 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) != 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) and len(one_0) == len(zero_1) - 1 and (len(one_0) == len(zero_1) + 1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) and len(one_0) == len(zero_1) - 1 and (len(one_0) == len(zero_1) + 1):\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[1] == w[-1]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[1] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[-1] == w[-1]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[-1] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[1] == w[-1]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[1] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[0] == w[+1]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[+1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if w[0] == '0':",
      "mutated_line": "if w[0] == '':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif w[0] == '1':",
      "mutated_line": "elif w[0] != '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] != '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] != '0' and w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] != '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[-1] != '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] != '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' or w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' or w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 1 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 1 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > -1 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > -1 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 1 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 1 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 1 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 1 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == -1 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == -1 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 1 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 1 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 1) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 1) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == -1) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == -1) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 1) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 1) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 1) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 1) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == -1) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == -1) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (len(same_1) > 0 and len(same_0) == 0 and len(zero_1) == 0 and len(one_0) == 0) or \\",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 1) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 1) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 1 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 1 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > -1 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > -1 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 1 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 1 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 1 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 1 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == -1 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == -1 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 1 and (len(zero_1) == 0) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 1 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 1) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 1) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == -1) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == -1) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 1) and (len(one_0) == 0)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 1) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 1)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 1)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == -1)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == -1)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(len(same_0) > 0 and len(same_1) == 0 and len(zero_1) == 0 and len(one_0) == 0):",
      "mutated_line": "if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 1)):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 1)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append((0, []))",
      "mutated_line": "results.append((1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((1, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append((0, []))",
      "mutated_line": "results.append((-1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((-1, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append((0, []))",
      "mutated_line": "results.append((1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((1, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 1 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 1 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > -1 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > -1 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 1 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 1 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 1 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 1 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > -1 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > -1 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 1 and (len(zero_1) == 0) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 1 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 1) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 1) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == -1) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == -1) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 1) and (len(one_0) == 0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 1) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 1):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == -1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == -1):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif len(same_0) > 0 and len(same_1) > 0 and len(zero_1) == 0 and len(one_0) == 0:",
      "mutated_line": "elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 1):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) != len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) != len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) != len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) != len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) != len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) != len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(zero_1) >= len(one_0):",
      "mutated_line": "if len(zero_1) > len(one_0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) > len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(zero_1) >= len(one_0):",
      "mutated_line": "if len(zero_1) < len(one_0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) < len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(zero_1) >= len(one_0):",
      "mutated_line": "if len(zero_1) == len(one_0):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) == len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[0] == w[-2]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-2]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[0] == w[-0]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-0]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[0] == w[-0]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-0]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if w[0] == w[-1]:",
      "mutated_line": "if w[0] == w[--1]:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[--1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if w[0] == '0':",
      "mutated_line": "if w[1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[1] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if w[0] == '0':",
      "mutated_line": "if w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[-1] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if w[0] == '0':",
      "mutated_line": "if w[1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[1] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif w[0] == '1':",
      "mutated_line": "elif w[0] == '':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '' and w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[-1] == '':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] != '1' and w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] != '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[-1] != '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] != '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "results.append((-1, []))",
      "mutated_line": "results.append((+1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((+1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) + 1 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) + 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) * 1 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) * 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) - 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) - 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) * 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) * 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) / 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) / 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) * 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) * 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif len(one_0) > len(zero_1):",
      "mutated_line": "elif len(one_0) >= len(zero_1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) >= len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif len(one_0) > len(zero_1):",
      "mutated_line": "elif len(one_0) <= len(zero_1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) <= len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif len(one_0) > len(zero_1):",
      "mutated_line": "elif len(one_0) != len(zero_1):",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) != len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if w[::-1] in words_set:",
      "mutated_line": "if w[::-1] not in words_set:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] not in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif w[0] == '1':",
      "mutated_line": "elif w[1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[1] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif w[0] == '1':",
      "mutated_line": "elif w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[-1] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif w[0] == '1':",
      "mutated_line": "elif w[1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[1] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[1] == '0' and w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[1] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[-1] == '0' and w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[-1] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[1] == '0' and w[-1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[1] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[+1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[+1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '' and w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[-1] == '':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((-1, []))",
      "mutated_line": "results.append((-2, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-2, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((-1, []))",
      "mutated_line": "results.append((-0, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-0, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((-1, []))",
      "mutated_line": "results.append((-0, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-0, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((-1, []))",
      "mutated_line": "results.append((--1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((--1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 2 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 2 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 0 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 0 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 0 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 0 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - -1 or len(one_0) == len(zero_1) + 1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - -1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 2:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 2:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 0:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 0:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 0:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 0:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:",
      "mutated_line": "elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + -1:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + -1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append((0, []))",
      "mutated_line": "results.append((1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((1, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append((0, []))",
      "mutated_line": "results.append((-1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((-1, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append((0, []))",
      "mutated_line": "results.append((1, []))",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((1, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) + len(one_0)) // 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) + len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = len(zero_1) * len(one_0) // 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = len(zero_1) * len(one_0) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) // 3",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 3\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) // 1",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 1\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) // 0",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 0\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) // 1",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 1\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "required = (len(zero_1) - len(one_0)) // 2",
      "mutated_line": "required = (len(zero_1) - len(one_0)) // -2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // -2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) / 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) / 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) * 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) * 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if len(indices) >= required:",
      "mutated_line": "if len(indices) > required:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) > required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if len(indices) >= required:",
      "mutated_line": "if len(indices) < required:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) < required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if len(indices) >= required:",
      "mutated_line": "if len(indices) == required:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) == required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[-2] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-2] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[-0] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-0] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[-0] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-0] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif w[0] == '0' and w[-1] == '1':",
      "mutated_line": "elif w[0] == '0' and w[--1] == '1':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[--1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[1] == '1' and w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[1] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[-1] == '1' and w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[-1] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[1] == '1' and w[-1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[1] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[+1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[+1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) + len(zero_1)) // 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) + len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = len(one_0) * len(zero_1) // 2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = len(one_0) * len(zero_1) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) // 3",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 3\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) // 1",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 1\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) // 0",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 0\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) // 1",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 1\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "required = (len(one_0) - len(zero_1)) // 2",
      "mutated_line": "required = (len(one_0) - len(zero_1)) // -2",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // -2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "indices.append(index_map[index] + 1)",
      "mutated_line": "indices.append(index_map[index] - 1)",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] - 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "indices.append(index_map[index] + 1)",
      "mutated_line": "indices.append(index_map[index] * 1)",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] * 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[-2] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-2] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[-0] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-0] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[-0] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-0] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif w[0] == '1' and w[-1] == '0':",
      "mutated_line": "elif w[0] == '1' and w[--1] == '0':",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[--1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 49,
      "original_line": "if w[::-1] in words_set:",
      "mutated_line": "if w[::+1] in words_set:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::+1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "indices.append(index_map[index] + 1)",
      "mutated_line": "indices.append(index_map[index] + 2)",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 2)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "indices.append(index_map[index] + 1)",
      "mutated_line": "indices.append(index_map[index] + 0)",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 0)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "indices.append(index_map[index] + 1)",
      "mutated_line": "indices.append(index_map[index] + 0)",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 0)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "indices.append(index_map[index] + 1)",
      "mutated_line": "indices.append(index_map[index] + -1)",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + -1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if w[::-1] in words_set:",
      "mutated_line": "if w[::-2] in words_set:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-2] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if w[::-1] in words_set:",
      "mutated_line": "if w[::-0] in words_set:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-0] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if w[::-1] in words_set:",
      "mutated_line": "if w[::-0] in words_set:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::-0] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if w[::-1] in words_set:",
      "mutated_line": "if w[::--1] in words_set:",
      "code": "def minimal_reversals(test_cases):\n    results = []\n    for words in test_cases:\n        n = len(words)\n        same_1 = []\n        same_0 = []\n        zero_1 = []\n        one_0 = []\n        index_zero_1 = []\n        index_one_0 = []\n        for (index, w) in enumerate(words):\n            if w[0] == w[-1]:\n                if w[0] == '0':\n                    same_0.append(w)\n                elif w[0] == '1':\n                    same_1.append(w)\n            elif w[0] == '0' and w[-1] == '1':\n                zero_1.append(w)\n                index_zero_1.append(index)\n            elif w[0] == '1' and w[-1] == '0':\n                one_0.append(w)\n                index_one_0.append(index)\n        if len(same_1) > 0 and len(same_0) == 0 and (len(zero_1) == 0) and (len(one_0) == 0) or (len(same_0) > 0 and len(same_1) == 0 and (len(zero_1) == 0) and (len(one_0) == 0)):\n            results.append((0, []))\n            continue\n        elif len(same_0) > 0 and len(same_1) > 0 and (len(zero_1) == 0) and (len(one_0) == 0):\n            results.append((-1, []))\n            continue\n        elif len(one_0) == len(zero_1) or len(one_0) == len(zero_1) - 1 or len(one_0) == len(zero_1) + 1:\n            results.append((0, []))\n        else:\n            if len(zero_1) >= len(one_0):\n                words_to_reverse = zero_1\n                words_set = set(one_0)\n                index_map = index_zero_1\n                required = (len(zero_1) - len(one_0)) // 2\n            elif len(one_0) > len(zero_1):\n                words_to_reverse = one_0\n                words_set = set(zero_1)\n                index_map = index_one_0\n                required = (len(one_0) - len(zero_1)) // 2\n            indices = []\n            for (index, w) in enumerate(words_to_reverse):\n                if w[::--1] in words_set:\n                    continue\n                else:\n                    indices.append(index_map[index] + 1)\n                    if len(indices) >= required:\n                        break\n            results.append((len(indices), indices))\n    return results"
    }
  ]
}