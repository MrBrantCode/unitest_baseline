{
  "task_id": "taco_18051",
  "entry_point": "determine_winning_strategy",
  "mutant_count": 219,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 1\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = -1\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 1\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pre = 0",
      "mutated_line": "pre = 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 1\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pre = 0",
      "mutated_line": "pre = -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = -1\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pre = 0",
      "mutated_line": "pre = 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 1\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "post = 0",
      "mutated_line": "post = 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 1\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "post = 0",
      "mutated_line": "post = -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = -1\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "post = 0",
      "mutated_line": "post = 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 1\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while len(parent) > 0:",
      "mutated_line": "while len(parent) >= 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) >= 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while len(parent) > 0:",
      "mutated_line": "while len(parent) <= 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) <= 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while len(parent) > 0:",
      "mutated_line": "while len(parent) != 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) != 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u += 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v += 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][2].append(1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(1)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][2].append(-1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(-1)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][2].append(1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(1)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parity = [True for _ in range(n)]",
      "mutated_line": "parity = [False for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [False for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(parent) > 0:",
      "mutated_line": "while len(parent) > 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 1:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(parent) > 0:",
      "mutated_line": "while len(parent) > -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > -1:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(parent) > 0:",
      "mutated_line": "while len(parent) > 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 1:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][0] != -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] != -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "pre += 1",
      "mutated_line": "pre -= 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre -= 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "post += 1",
      "mutated_line": "post -= 1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post -= 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 2\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 0\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 0\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= -1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 2\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 0\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 0\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= -1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] or order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] or order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[int(c), 0, []] for c in coins]",
      "mutated_line": "G = [[int(c), 1, []] for c in coins]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 1, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[int(c), 0, []] for c in coins]",
      "mutated_line": "G = [[int(c), -1, []] for c in coins]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), -1, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[int(c), 0, []] for c in coins]",
      "mutated_line": "G = [[int(c), 1, []] for c in coins]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 1, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[+1, -1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[+1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-1, +1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, +1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][2].append(v2 + 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 + 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][2].append(v2 * 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 * 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][2].append(v1 + 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 + 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][2].append(v1 * 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 * 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = deque([0])",
      "mutated_line": "parent = deque([1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([1])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = deque([0])",
      "mutated_line": "parent = deque([-1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([-1])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = deque([0])",
      "mutated_line": "parent = deque([1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([1])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][0] == +1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == +1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pre += 1",
      "mutated_line": "pre += 2",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 2\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pre += 1",
      "mutated_line": "pre += 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 0\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pre += 1",
      "mutated_line": "pre += 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 0\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pre += 1",
      "mutated_line": "pre += -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += -1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][2]) != 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) != 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "post += 1",
      "mutated_line": "post += 2",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 2\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "post += 1",
      "mutated_line": "post += 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 0\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "post += 1",
      "mutated_line": "post += 0",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 0\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "post += 1",
      "mutated_line": "post += -1",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += -1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][2][0] != node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] != node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] <= order[v][0] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] <= order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] >= order[v][0] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] >= order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] != order[v][0] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] != order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] >= order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] >= order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] <= order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] <= order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] != order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] != order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif parity[u] == parity[v]:",
      "mutated_line": "elif parity[u] != parity[v]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] != parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][3].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][3].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][1].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][1].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][0].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][0].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][1].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][1].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[0][-2].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][-2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-2, -1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-2, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-0, -1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-0, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-0, -1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-0, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[--1, -1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[--1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-1, -2] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -2] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-1, -0] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -0] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-1, -0] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -0] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "order = [[-1, -1] for _ in range(n)]",
      "mutated_line": "order = [[-1, --1] for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, --1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][2].append(v2 - 2)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 2)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][2].append(v2 - 0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 0)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][2].append(v2 - 0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 0)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][2].append(v2 - -1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - -1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][2].append(v1 - 2)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 2)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][2].append(v1 - 0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 0)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][2].append(v1 - 0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 0)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][2].append(v1 - -1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - -1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][1] == -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][1] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][-1] == -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][-1] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][1] == -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][1] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][0] == -2:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -2:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][0] == -0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -0:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][0] == -0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -0:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if order[node][0] == -1:",
      "mutated_line": "if order[node][0] == --1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == --1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "order[node][0] = pre",
      "mutated_line": "order[node][1] = pre",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][1] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "order[node][0] = pre",
      "mutated_line": "order[node][-1] = pre",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][-1] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "order[node][0] = pre",
      "mutated_line": "order[node][1] = pre",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][1] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "total = total ^ G[node][0]",
      "mutated_line": "total = total | G[node][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total | G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][2]) == 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 1:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][2]) == -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == -1:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][2]) == 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 1:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "order[node][1] = post",
      "mutated_line": "order[node][2] = post",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][2] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "order[node][1] = post",
      "mutated_line": "order[node][0] = post",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][0] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "order[node][1] = post",
      "mutated_line": "order[node][0] = post",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][0] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "order[node][1] = post",
      "mutated_line": "order[node][-1] = post",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][-1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][3]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][3]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][1]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][0]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][0]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][1]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][-2]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][-2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][0] | G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] | G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "results.append('INVALID')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if newtotal ^ total == 0:",
      "mutated_line": "if newtotal ^ total != 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total != 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif total == 0:",
      "mutated_line": "elif total != 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total != 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[1][2].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[1][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[-1][2].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[-1][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[0][2].append(0)",
      "mutated_line": "G[1][2].append(0)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[1][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][3].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][3].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][1].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][1].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][0].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][0].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][1].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][1].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 1][-2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][-2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][3].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][3].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][1].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][1].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][0].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][0].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][1].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][1].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 1][-2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][-2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][2].remove(G[node][2])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][2])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][2].remove(G[node][0])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][0])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][2].remove(G[node][0])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][0])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][2].remove(G[node][-1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][-1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][3]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][3]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][1]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][0]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][0]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][1]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for c in G[node][2]:",
      "mutated_line": "for c in G[node][-2]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][-2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][1] = G[node][0] ^ G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][1] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][-1] = G[node][0] ^ G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][-1] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][1] = G[node][0] ^ G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][1] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][2][1] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][1] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][2][-1] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][-1] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][2][1] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][1] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][1] < order[v][0] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][1] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][-1] < order[v][0] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][-1] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][1] < order[v][0] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][1] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][1] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][1] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][-1] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][-1] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][1] and order[u][1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][1] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][2] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][2] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][0] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][0] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][0] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][0] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][-1] > order[v][1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][-1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][2]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][2]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][0]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][0]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][0]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][0]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][1]:",
      "mutated_line": "if order[u][0] < order[v][0] and order[u][1] > order[v][-1]:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][-1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "newtotal = G[u][0]",
      "mutated_line": "newtotal = G[u][1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][1]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "newtotal = G[u][0]",
      "mutated_line": "newtotal = G[u][-1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][-1]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "newtotal = G[u][0]",
      "mutated_line": "newtotal = G[u][1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][1]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if newtotal ^ total == 0:",
      "mutated_line": "if newtotal | total == 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal | total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if newtotal ^ total == 0:",
      "mutated_line": "if newtotal ^ total == 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 1:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if newtotal ^ total == 0:",
      "mutated_line": "if newtotal ^ total == -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == -1:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if newtotal ^ total == 0:",
      "mutated_line": "if newtotal ^ total == 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 1:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif total == 0:",
      "mutated_line": "elif total == 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 1:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif total == 0:",
      "mutated_line": "elif total == -1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == -1:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif total == 0:",
      "mutated_line": "elif total == 1:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 1:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 + 1][2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 + 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 * 1][2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 * 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 + 1][2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 + 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 * 1][2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 * 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parity[node] = not parity[G[node][1]]",
      "mutated_line": "parity[node] = not parity[G[node][2]]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][2]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parity[node] = not parity[G[node][1]]",
      "mutated_line": "parity[node] = not parity[G[node][0]]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][0]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parity[node] = not parity[G[node][1]]",
      "mutated_line": "parity[node] = not parity[G[node][0]]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][0]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parity[node] = not parity[G[node][1]]",
      "mutated_line": "parity[node] = not parity[G[node][-1]]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][-1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "total = total ^ G[node][0]",
      "mutated_line": "total = total ^ G[node][1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][1]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "total = total ^ G[node][0]",
      "mutated_line": "total = total ^ G[node][-1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][-1]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "total = total ^ G[node][0]",
      "mutated_line": "total = total ^ G[node][1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][1]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][3].remove(G[node][1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][3].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][1].remove(G[node][1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][1].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][0].remove(G[node][1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][0].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][1].remove(G[node][1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][1].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G[node][2].remove(G[node][1])",
      "mutated_line": "G[node][-2].remove(G[node][1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][-2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][3]) == 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][3]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][1]) == 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][1]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][0]) == 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][0]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][1]) == 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][1]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(G[node][2]) == 0:",
      "mutated_line": "if len(G[node][-2]) == 0:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][-2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "G[c][1] = node",
      "mutated_line": "G[c][2] = node",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][2] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "G[c][1] = node",
      "mutated_line": "G[c][0] = node",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][0] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "G[c][1] = node",
      "mutated_line": "G[c][0] = node",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][0] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "G[c][1] = node",
      "mutated_line": "G[c][-1] = node",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][-1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][1] ^ G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][1] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][-1] ^ G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][-1] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][1] ^ G[c][0]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][1] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][0] ^ G[c][1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][1]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][0] ^ G[c][-1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][-1]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "G[node][0] = G[node][0] ^ G[c][0]",
      "mutated_line": "G[node][0] = G[node][0] ^ G[c][1]",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][1]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][3][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][3][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][1][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][1][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][0][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][0][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][1][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][1][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][1]][-2][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][-2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "parent.append(G[node][1])",
      "mutated_line": "parent.append(G[node][2])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][2])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "parent.append(G[node][1])",
      "mutated_line": "parent.append(G[node][0])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][0])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "parent.append(G[node][1])",
      "mutated_line": "parent.append(G[node][0])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][0])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "parent.append(G[node][1])",
      "mutated_line": "parent.append(G[node][-1])",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][-1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "results.append('NO')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "results.append('YES')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "results.append('NO')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "results.append('YES')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 2][2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 2][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 0][2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 0][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - 0][2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 0][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v1 - 1][2].append(v2 - 1)",
      "mutated_line": "G[v1 - -1][2].append(v2 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - -1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 2][2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 2][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 0][2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 0][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - 0][2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 0][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "G[v2 - 1][2].append(v1 - 1)",
      "mutated_line": "G[v2 - -1][2].append(v1 - 1)",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - -1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][2]][2][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][2]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][0]][2][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][0]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][0]][2][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][0]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if G[G[node][1]][2][0] == node:",
      "mutated_line": "if G[G[node][-1]][2][0] == node:",
      "code": "from collections import deque\n\ndef determine_winning_strategy(n, coins, edges, questions):\n    G = [[int(c), 0, []] for c in coins]\n    G[0][2].append(0)\n    parity = [True for _ in range(n)]\n    order = [[-1, -1] for _ in range(n)]\n    for (v1, v2) in edges:\n        G[v1 - 1][2].append(v2 - 1)\n        G[v2 - 1][2].append(v1 - 1)\n    total = 0\n    pre = 0\n    post = 0\n    parent = deque([0])\n    while len(parent) > 0:\n        node = parent.pop()\n        if order[node][0] == -1:\n            order[node][0] = pre\n            pre += 1\n            parity[node] = not parity[G[node][1]]\n            if parity[node]:\n                total = total ^ G[node][0]\n            G[node][2].remove(G[node][1])\n            if len(G[node][2]) == 0:\n                parent.append(node)\n            else:\n                for c in G[node][2]:\n                    G[c][1] = node\n                    parent.append(c)\n        else:\n            order[node][1] = post\n            post += 1\n            for c in G[node][2]:\n                G[node][0] = G[node][0] ^ G[c][0]\n            if G[G[node][-1]][2][0] == node:\n                parent.append(G[node][1])\n    results = []\n    for (u, v) in questions:\n        u -= 1\n        v -= 1\n        if order[u][0] < order[v][0] and order[u][1] > order[v][1]:\n            results.append('INVALID')\n        elif parity[u] == parity[v]:\n            newtotal = G[u][0]\n            if newtotal ^ total == 0:\n                results.append('NO')\n            else:\n                results.append('YES')\n        elif total == 0:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    }
  ]
}