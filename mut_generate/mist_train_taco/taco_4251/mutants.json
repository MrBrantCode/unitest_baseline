{
  "task_id": "taco_4251",
  "entry_point": "count_promising_substrings",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 1\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = -1\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 1\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] / 3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] / 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] + 3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] + 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] ** 3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] ** 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt[cur_bal] = 1",
      "mutated_line": "cnt[cur_bal] = 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 2\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt[cur_bal] = 1",
      "mutated_line": "cnt[cur_bal] = 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 0\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt[cur_bal] = 1",
      "mutated_line": "cnt[cur_bal] = 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 0\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt[cur_bal] = 1",
      "mutated_line": "cnt[cur_bal] = -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = -1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 3] = 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 2\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 3] = 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 0\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 3] = 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 0\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 3] = -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = -1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [1 for _ in range(2 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [1 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [-1 for _ in range(2 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [-1 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [1 for _ in range(2 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [1 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] * 4",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 4\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] * 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 2\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] * 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 0\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] * 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 1\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [0] * -3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * -3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal * 3] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal * 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal + 3] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal + 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if c == '-':",
      "mutated_line": "if c != '-':",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c != '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "new_bal -= 1",
      "mutated_line": "new_bal += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal += 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res -= cnt_promise[new_bal % 3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res -= cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] -= 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] -= 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] -= 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] -= 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "new_bal += 1",
      "mutated_line": "new_bal -= 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal -= 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res -= cnt_promise[new_bal % 3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res -= cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] -= 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] -= 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] -= 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] -= 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [1] * 3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [1] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [-1] * 3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [-1] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt_promise = [0] * 3",
      "mutated_line": "cnt_promise = [1] * 3",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [1] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 4] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 4] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 2] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 2] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 0] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 0] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % 1] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 1] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt_promise[cur_bal % 3] = 1",
      "mutated_line": "cnt_promise[cur_bal % -3] = 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % -3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if c == '-':",
      "mutated_line": "if c == '':",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_bal -= 1",
      "mutated_line": "new_bal -= 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 2\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_bal -= 1",
      "mutated_line": "new_bal -= 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 0\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_bal -= 1",
      "mutated_line": "new_bal -= 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 0\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_bal -= 1",
      "mutated_line": "new_bal -= -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= -1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 2\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 0\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 0\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += -1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 2\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 0\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 0\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += -1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_bal += 1",
      "mutated_line": "new_bal += 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 2\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_bal += 1",
      "mutated_line": "new_bal += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 0\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_bal += 1",
      "mutated_line": "new_bal += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 0\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_bal += 1",
      "mutated_line": "new_bal += -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += -1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 2\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 0\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 0\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 3] += -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += -1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += 2",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 2\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 0\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += 0",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 0\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[new_bal] += 1",
      "mutated_line": "cnt[new_bal] += -1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += -1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 * n - 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n - 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 * n * 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n * 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal * 3] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal * 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal + 3] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal + 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal * 3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal * 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal + 3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal + 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal * 3] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal * 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal + 3] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal + 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal * 3] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal * 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal + 3] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal + 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal * 3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal * 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal + 3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal + 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal * 3] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal * 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal + 3] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal + 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 / n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 / n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 + n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 + n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 ** n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 ** n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 * n + 2)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 2)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 * n + 0)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 0)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 * n + 0)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 0)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(2 * n + -1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + -1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 4] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 4] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 2] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 2] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 0] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 0] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 1] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 1] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt_promise[new_bal % 3] += cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % -3] += cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % -3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 4]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 4]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 2]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 2]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 0]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 0]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 1]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 1]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % -3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % -3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 4] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 4] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 2] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 2] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 0] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 0] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 1] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 1] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % -3] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % -3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 4] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 4] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 2] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 2] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 0] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 0] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % 1] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 1] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt_promise[new_bal % 3] -= cnt[new_bal]",
      "mutated_line": "cnt_promise[new_bal % -3] -= cnt[new_bal]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % -3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 4]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 4]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 2]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 2]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 0]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 0]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % 1]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 1]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res += cnt_promise[new_bal % 3]",
      "mutated_line": "res += cnt_promise[new_bal % -3]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % -3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 4] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 4] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 2] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 2] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 0] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 0] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % 1] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 1] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt_promise[new_bal % 3] += 1",
      "mutated_line": "cnt_promise[new_bal % -3] += 1",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % -3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(3 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(3 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(1 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(1 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(0 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(0 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(1 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(1 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cnt = [0 for _ in range(2 * n + 1)]",
      "mutated_line": "cnt = [0 for _ in range(-2 * n + 1)]",
      "code": "def count_promising_substrings(n: int, s: str) -> int:\n    \"\"\"\n    Counts the number of promising non-empty substrings in the given string `s` of length `n`.\n\n    A string is promising if it can be made balanced by several (possibly zero) uses of the following operation:\n    replace two adjacent minus signs with one plus sign.\n\n    Args:\n        n (int): The length of the string `s`.\n        s (str): The string consisting only of characters \"+\" and \"-\".\n\n    Returns:\n        int: The number of promising non-empty substrings in the string `s`.\n    \"\"\"\n    res = 0\n    cnt = [0 for _ in range(-2 * n + 1)]\n    cnt_promise = [0] * 3\n    cur_bal = n\n    cnt[cur_bal] = 1\n    cnt_promise[cur_bal % 3] = 1\n    for c in s:\n        new_bal = cur_bal\n        if c == '-':\n            new_bal -= 1\n            cnt_promise[new_bal % 3] += cnt[new_bal]\n            res += cnt_promise[new_bal % 3]\n            cnt[new_bal] += 1\n            cnt_promise[new_bal % 3] += 1\n        else:\n            cnt_promise[new_bal % 3] -= cnt[new_bal]\n            new_bal += 1\n            res += cnt_promise[new_bal % 3]\n            cnt_promise[new_bal % 3] += 1\n            cnt[new_bal] += 1\n        cur_bal = new_bal\n    return res"
    }
  ]
}