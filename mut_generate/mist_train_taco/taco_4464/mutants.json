{
  "task_id": "taco_4464",
  "entry_point": "calculate_min_distances",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = 2",
      "mutated_line": "dis = 3",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 3\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = 2",
      "mutated_line": "dis = 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 1\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = 2",
      "mutated_line": "dis = 0",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 0\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = 2",
      "mutated_line": "dis = 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 1\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = 2",
      "mutated_line": "dis = -2",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = -2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "dis += 2",
      "mutated_line": "dis -= 2",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis -= 2\n    return dist"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [+1, 1, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [+1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 2, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 2, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 0, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 0, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 0, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 0, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, -1, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, -1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 1, 1, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 1, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 1, -1, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, -1, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 1, 1, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 1, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 1, 0, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 1]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 1, 0, -1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, -1]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-1, 1, 0, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 1]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [1, 0, -1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [1, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [-1, 0, -1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [-1, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [1, 0, -1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [1, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 1, -1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 1, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, -1, -1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, -1, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 1, -1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 1, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, +1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, +1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -1, 2]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 2]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -1, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 0]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -1, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 0]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -1, -1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, -1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dis += 2",
      "mutated_line": "dis += 3",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 3\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dis += 2",
      "mutated_line": "dis += 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dis += 2",
      "mutated_line": "dis += 0",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 0\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dis += 2",
      "mutated_line": "dis += 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dis += 2",
      "mutated_line": "dis += -2",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += -2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-2, 1, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-2, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-0, 1, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-0, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [-0, 1, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-0, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [-1, 1, 0, 0]",
      "mutated_line": "dx = [--1, 1, 0, 0]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [--1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -2, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -2, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -0, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -0, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, -0, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -0, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dy = [0, 0, -1, 1]",
      "mutated_line": "dy = [0, 0, --1, 1]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, --1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "dist = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dist = [[+1 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[+1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "vis = [[False for _ in range(m)] for _ in range(n)]",
      "mutated_line": "vis = [[True for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[True for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if grid[i][j] == 'W':",
      "mutated_line": "if grid[i][j] != 'W':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] == 'W' and grid[i][j] == '.' and (grid[i][j] == 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' and grid[i][j] == '.' and (grid[i][j] == 'N'):\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dist = [[-2 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-2 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dist = [[-0 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-0 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dist = [[-0 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-0 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dist = [[--1 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[--1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if grid[i][j] == 'W':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "vis[i][j] = True",
      "mutated_line": "vis[i][j] = False",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = False\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] != 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] != 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] == 'W' or grid[i][j] != '.' or grid[i][j] == 'N':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] != '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] != 'N':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] != 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 1\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = -1\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 1\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(5):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(5):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(3):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(3):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(0):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(0):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(1):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(-4):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(-4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n or 0 <= currj < m or (not vis[curri][currj]) or (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n or 0 <= currj < m or (not vis[curri][currj]) or (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] == '' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == '' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] == 'W' or grid[i][j] == '' or grid[i][j] == 'N':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':",
      "mutated_line": "if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == '':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == '':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(curri, currj) = (i + dx[k], j + dy[k])",
      "mutated_line": "(curri, currj) = (i - dx[k], j + dy[k])",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i - dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(curri, currj) = (i + dx[k], j + dy[k])",
      "mutated_line": "(curri, currj) = (i * dx[k], j + dy[k])",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i * dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(curri, currj) = (i + dx[k], j + dy[k])",
      "mutated_line": "(curri, currj) = (i + dx[k], j - dy[k])",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j - dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(curri, currj) = (i + dx[k], j + dy[k])",
      "mutated_line": "(curri, currj) = (i + dx[k], j * dy[k])",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j * dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 < curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 < curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 > curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 > curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 == curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 == curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 0 < currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 < currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 0 > currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 > currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 0 == currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 == currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] == 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] == 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vis[curri][currj] = True",
      "mutated_line": "vis[curri][currj] = False",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = False\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if grid[curri][currj] == 'H':",
      "mutated_line": "if grid[curri][currj] != 'H':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] != 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 1 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 1 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if -1 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if -1 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 1 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 1 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 1 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 1 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and -1 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and -1 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 1 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 1 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):",
      "mutated_line": "if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != ''):",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != ''):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == 'H':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if grid[curri][currj] == 'H':",
      "mutated_line": "if grid[curri][currj] == '':",
      "code": "from typing import List\nfrom collections import deque\n\ndef calculate_min_distances(n: int, m: int, grid: List[List[str]]) -> List[List[int]]:\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    dist = [[-1 for _ in range(m)] for _ in range(n)]\n    vis = [[False for _ in range(m)] for _ in range(n)]\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'W':\n                q.append((i, j))\n                vis[i][j] = True\n            if grid[i][j] == 'W' or grid[i][j] == '.' or grid[i][j] == 'N':\n                dist[i][j] = 0\n    dis = 2\n    while q:\n        qsize = len(q)\n        for _ in range(qsize):\n            (i, j) = q.popleft()\n            for k in range(4):\n                (curri, currj) = (i + dx[k], j + dy[k])\n                if 0 <= curri < n and 0 <= currj < m and (not vis[curri][currj]) and (grid[curri][currj] != 'N'):\n                    vis[curri][currj] = True\n                    q.append((curri, currj))\n                    if grid[curri][currj] == '':\n                        dist[curri][currj] = dis\n        dis += 2\n    return dist"
    }
  ]
}