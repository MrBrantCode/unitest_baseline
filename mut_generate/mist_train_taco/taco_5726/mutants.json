{
  "task_id": "taco_5726",
  "entry_point": "maximize_min_distance",
  "mutant_count": 113,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[0][0] + dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] + dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[0][0] * dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] * dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if first + m - prev_placed <= dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed <= dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if first + m - prev_placed >= dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed >= dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if first + m - prev_placed != dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed != dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return False\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while lo < hi:",
      "mutated_line": "while lo <= hi:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo <= hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while lo < hi:",
      "mutated_line": "while lo >= hi:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo >= hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while lo < hi:",
      "mutated_line": "while lo != hi:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo != hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] or first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] or first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first >= intervals[0][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first >= intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first <= intervals[0][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first <= intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first != intervals[0][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first != intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(2, len(intervals)):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(2, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(0, len(intervals)):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(0, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(0, len(intervals)):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(0, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(-1, len(intervals)):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(-1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "next_pos = prev_placed + dist",
      "mutated_line": "next_pos = prev_placed - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed - dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "next_pos = prev_placed + dist",
      "mutated_line": "next_pos = prev_placed * dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed * dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_pos < intervals[i][0]:",
      "mutated_line": "if next_pos <= intervals[i][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos <= intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_pos < intervals[i][0]:",
      "mutated_line": "if next_pos >= intervals[i][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos >= intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_pos < intervals[i][0]:",
      "mutated_line": "if next_pos != intervals[i][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos != intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if first + m + prev_placed < dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m + prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if (first + m) * prev_placed < dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if (first + m) * prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return True\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lo, hi = 1, m",
      "mutated_line": "(lo, hi) = (2, m)",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (2, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lo, hi = 1, m",
      "mutated_line": "(lo, hi) = (0, m)",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (0, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lo, hi = 1, m",
      "mutated_line": "(lo, hi) = (0, m)",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (0, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "lo, hi = 1, m",
      "mutated_line": "(lo, hi) = (-1, m)",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (-1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo - (hi - lo + 1) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo - (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo * ((hi - lo + 1) // 2)",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo * ((hi - lo + 1) // 2)\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[0][1] - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][1] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[0][-1] - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][-1] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[0][1] - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][1] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first > intervals[0][0] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first > intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first < intervals[0][0] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first < intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first == intervals[0][0] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first == intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first < intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first < intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first > intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first > intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first == intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first == intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if first - m - prev_placed < dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first - m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if first + m - prev_placed < dist:",
      "mutated_line": "if first * m - prev_placed < dist:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first * m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) / 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) / 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) * 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) * 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid + 1",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid + 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid * 1",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid * 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[1][0] - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[1][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[-1][0] - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[-1][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "first = prev_placed = intervals[0][0] - dist",
      "mutated_line": "first = prev_placed = intervals[1][0] - dist",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[1][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[0][2]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][2]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[0][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][0]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[0][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][0]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[0][-1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][-1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[0][2]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][2]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[0][0]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][0]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[0][0]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][0]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[0][-1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][-1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "first = prev_placed = intervals[0][0]",
      "mutated_line": "first = prev_placed = intervals[0][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][1]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "first = prev_placed = intervals[0][0]",
      "mutated_line": "first = prev_placed = intervals[0][-1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][-1]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "first = prev_placed = intervals[0][0]",
      "mutated_line": "first = prev_placed = intervals[0][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][1]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_pos < intervals[i][0]:",
      "mutated_line": "if next_pos < intervals[i][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][1]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_pos < intervals[i][0]:",
      "mutated_line": "if next_pos < intervals[i][-1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][-1]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if next_pos < intervals[i][0]:",
      "mutated_line": "if next_pos < intervals[i][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][1]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prev_placed = intervals[i][0]",
      "mutated_line": "prev_placed = intervals[i][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][1]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prev_placed = intervals[i][0]",
      "mutated_line": "prev_placed = intervals[i][-1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][-1]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prev_placed = intervals[i][0]",
      "mutated_line": "prev_placed = intervals[i][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][1]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos < intervals[i][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos < intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos > intervals[i][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos > intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos == intervals[i][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos == intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return True\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo - 1) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo - 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo) * 1 // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo) * 1 // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) // 3",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 3\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) // 1",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 1\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) // 0",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 0\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) // 1",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 1\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 1) // -2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // -2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 2\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 0",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 0\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 0",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 0\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - -1",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - -1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][1] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][1] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][-1] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][-1] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][1] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][1] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[0][2]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][2]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[0][0]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][0]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[0][0]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][0]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[0][-1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][-1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[1][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[1][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[-1][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[-1][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if first > intervals[0][1]:",
      "mutated_line": "if first > intervals[1][1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[1][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[1][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[1][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[-1][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[-1][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "first = prev_placed = intervals[0][1]",
      "mutated_line": "first = prev_placed = intervals[1][1]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[1][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "first = prev_placed = intervals[0][0]",
      "mutated_line": "first = prev_placed = intervals[1][0]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[1][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "first = prev_placed = intervals[0][0]",
      "mutated_line": "first = prev_placed = intervals[-1][0]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[-1][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "first = prev_placed = intervals[0][0]",
      "mutated_line": "first = prev_placed = intervals[1][0]",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[1][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi + lo + 1) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi + lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi * lo + 1) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi * lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 2) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 2) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 0) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 0) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + 0) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 0) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid = lo + (hi - lo + 1) // 2",
      "mutated_line": "mid = lo + (hi - lo + -1) // 2",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + -1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[1][0] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[1][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[-1][0] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[-1][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[1][0] and first <= intervals[0][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[1][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[1][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[1][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[-1][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[-1][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not (first >= intervals[0][0] and first <= intervals[0][1]):",
      "mutated_line": "if not (first >= intervals[0][0] and first <= intervals[1][1]):",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[1][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos <= intervals[i][2]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][2]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos <= intervals[i][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][0]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos <= intervals[i][0]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][0]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif not next_pos <= intervals[i][1]:",
      "mutated_line": "elif not next_pos <= intervals[i][-1]:",
      "code": "def maximize_min_distance(m, n, intervals):\n\n    def possible_with_dist(intervals, dist):\n        first = prev_placed = intervals[0][0] - dist\n        if not (first >= intervals[0][0] and first <= intervals[0][1]):\n            if first > intervals[0][1]:\n                first = prev_placed = intervals[0][1]\n            else:\n                first = prev_placed = intervals[0][0]\n        for i in range(1, len(intervals)):\n            next_pos = prev_placed + dist\n            if next_pos < intervals[i][0]:\n                prev_placed = intervals[i][0]\n            elif not next_pos <= intervals[i][-1]:\n                return False\n            else:\n                prev_placed = next_pos\n        if first + m - prev_placed < dist:\n            return False\n        return True\n\n    def upper_bound(intervals):\n        (lo, hi) = (1, m)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if possible_with_dist(intervals, mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        if not possible_with_dist(intervals, lo):\n            return None\n        return lo\n    return upper_bound(intervals)"
    }
  ]
}