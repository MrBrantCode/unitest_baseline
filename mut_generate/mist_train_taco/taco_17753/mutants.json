{
  "task_id": "taco_17753",
  "entry_point": "find_best_seats",
  "mutant_count": 266,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) / 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) / 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) * 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) * 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col + num + 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num + 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = (col + num) * 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = (col + num) * 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = abs(center - row) * num",
      "mutated_line": "distance = abs(center - row) / num",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) / num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = abs(center - row) * num",
      "mutated_line": "distance = abs(center - row) + num",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) + num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = abs(center - row) * num",
      "mutated_line": "distance = abs(center - row) ** num",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) ** num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if col >= center:",
      "mutated_line": "if col > center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col > center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if col >= center:",
      "mutated_line": "if col < center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col < center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if col >= center:",
      "mutated_line": "if col == center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col == center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance -= (col - center) * num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance -= (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K - 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K - 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = K * 1 // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = K * 1 // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) // 3",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 3\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 1\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) // 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 0\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 1\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 1) // -2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // -2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if closest == 10000:",
      "mutated_line": "if closest != 10000:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest != 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col - num - 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col - num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col * num - 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col * num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col + num - 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 2\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col + num - 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 0\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col + num - 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 0\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "end_col = col + num - 1",
      "mutated_line": "end_col = col + num - -1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - -1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num - (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num - (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num * ((num - 1) * num // 2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num * ((num - 1) * num // 2)\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif end_col <= center:",
      "mutated_line": "elif end_col < center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col < center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif end_col <= center:",
      "mutated_line": "elif end_col > center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col > center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif end_col <= center:",
      "mutated_line": "elif end_col == center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col == center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance -= (center - end_col) * num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance -= (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance -= (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance -= (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 2] for _ in range(K + 1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 2] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 0] for _ in range(K + 1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 0] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 0] for _ in range(K + 1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 0] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, -1] for _ in range(K + 1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, -1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 2) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 2) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 0) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 0) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + 0) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 0) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "center = (K + 1) // 2",
      "mutated_line": "center = (K + -1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + -1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10001, -1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10001, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (9999, -1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (9999, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (0, -1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (0, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (1, -1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (1, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (-10000, -1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (-10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, +1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, +1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -1, +1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, +1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(2, K + 1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(2, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(0, K + 1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(0, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(0, K + 1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(0, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(-1, K + 1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(-1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(1, K - 1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K - 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(1, K * 1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K * 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m or K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m or K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if available[row][0] == K:",
      "mutated_line": "if available[row][0] != K:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] != K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance < closest:",
      "mutated_line": "if distance <= closest:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance <= closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance < closest:",
      "mutated_line": "if distance >= closest:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance >= closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if distance < closest:",
      "mutated_line": "if distance != closest:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance != closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if closest == 10000:",
      "mutated_line": "if closest == 10001:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10001:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if closest == 10000:",
      "mutated_line": "if closest == 9999:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 9999:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if closest == 10000:",
      "mutated_line": "if closest == 0:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 0:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if closest == 10000:",
      "mutated_line": "if closest == 1:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 1:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if closest == 10000:",
      "mutated_line": "if closest == -10000:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == -10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = abs(center - row) * num",
      "mutated_line": "distance = abs(center + row) * num",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center + row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = abs(center - row) * num",
      "mutated_line": "distance = abs(center * row) * num",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center * row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) / num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) / num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += col - center + num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += col - center + num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) ** num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) ** num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num / 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num / 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num * 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num * 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num - (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num - (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num * ((num - 1) * num // 2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num * ((num - 1) * num // 2)\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 - (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 - (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 * ((end_col - center) * (end_col - center + 1) // 2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 * ((end_col - center) * (end_col - center + 1) // 2)\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 1] for _ in range(K - 1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K - 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 1] for _ in range(K * 1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K * 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -2, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -2, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -0, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -0, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -0, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -0, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, --1, -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, --1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -1, -2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -2)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -1, -0)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -0)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -1, -0)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -0)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closest, best_row, best_col = (10000, -1, -1)",
      "mutated_line": "(closest, best_row, best_col) = (10000, -1, --1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, --1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(1, K + 2):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 2):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(1, K + 0):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 0):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(1, K + 0):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 0):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for row in range(1, K + 1):",
      "mutated_line": "for row in range(1, K + -1):",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + -1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] <= m and K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] <= m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] >= m and K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] >= m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] != m and K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] != m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + 1 <= m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 <= m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + 1 >= m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 >= m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + 1 != m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 != m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center + m // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center + m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center * (m // 2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center * (m // 2)\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] < available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] < available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] > available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] > available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] == available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] == available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(+1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][1] = min(available[best_row][0], best_col - 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][1] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][-1] = min(available[best_row][0], best_col - 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][-1] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][1] = min(available[best_row][0], best_col - 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][1] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][0], best_col + 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col + 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][0], best_col * 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col * 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][2] = max(available[best_row][1], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][2] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][0] = max(available[best_row][1], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][0] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][0] = max(available[best_row][1], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][0] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][-1] = max(available[best_row][1], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][-1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][1] = max(available[best_row][1], best_col - m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col - m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][1] = max(available[best_row][1], best_col * m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col * m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col + center) * num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col + center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += col * center * num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += col * center * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) / num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) / num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1 + num) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1 + num) // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) ** num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) ** num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num // 3",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 3\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 1\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num // 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 0\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 1\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 1) * num // -2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // -2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) / num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) / num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += center - end_col + num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += center - end_col + num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) ** num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) ** num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num / 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num / 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num * 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num * 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) / 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) / 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) * 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) * 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) / 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) / 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) * 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) * 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 1] for _ in range(K + 2)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 2)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 1] for _ in range(K + 0)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 0)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 1] for _ in range(K + 0)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 0)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "available = [[K, 1] for _ in range(K + 1)]",
      "mutated_line": "available = [[K, 1] for _ in range(K + -1)]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + -1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] - 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] - 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and (K - available[row][1]) * 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and (K - available[row][1]) * 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if available[row][0] == K:",
      "mutated_line": "if available[row][1] == K:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][1] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if available[row][0] == K:",
      "mutated_line": "if available[row][-1] == K:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][-1] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if available[row][0] == K:",
      "mutated_line": "if available[row][1] == K:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][1] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m / 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m / 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m * 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m * 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center + available[row][0] <= available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center + available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center * available[row][0] <= available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center * available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] <= available[row][1] + center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] + center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] <= available[row][1] * center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] * center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] - m - 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m - 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = (available[row][0] - m) * 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = (available[row][0] - m) * 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-2)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-0)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-0)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(--1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col + m + 1))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m + 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, (best_col + m) * 1))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, (best_col + m) * 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][1], best_col - 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][1], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][-1], best_col - 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][-1], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][1], best_col - 1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][1], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][0], best_col - 2)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 2)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][0], best_col - 0)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 0)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][0], best_col - 0)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 0)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "available[best_row][0] = min(available[best_row][0], best_col - 1)",
      "mutated_line": "available[best_row][0] = min(available[best_row][0], best_col - -1)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - -1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][1] = max(available[best_row][2], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][2], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][1] = max(available[best_row][0], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][0], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][1] = max(available[best_row][0], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][0], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "available[best_row][1] = max(available[best_row][1], best_col + m)",
      "mutated_line": "available[best_row][1] = max(available[best_row][-1], best_col + m)",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][-1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num + 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num + 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + num * 1 * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + num * 1 * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center + end_col) * num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center + end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += center * end_col * num + (num - 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += center * end_col * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) / num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) / num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1 + num) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1 + num) // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) ** num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) ** num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num // 3",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 3\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 1\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num // 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 0\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 1\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 1) * num // -2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // -2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) / (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) / (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col + (center - col + 1)) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col + (center - col + 1)) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) ** (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) ** (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 3 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 3 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 1 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 1 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 0 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 0 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 1 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 1 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // -2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // -2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) / (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) / (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center + (end_col - center + 1)) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center + (end_col - center + 1)) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) ** (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) ** (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 3",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 3\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 1\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 0\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 1\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // -2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // -2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][1] < m and K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][1] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][-1] < m and K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][-1] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][1] < m and K - available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][1] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K + available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K + available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K * available[row][1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K * available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + 2 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 2 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + 0 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 0 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + 0 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 0 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][1] + -1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + -1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m // 3",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 3\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 1\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m // 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 0\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m // 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 1\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "col = center - m // 2",
      "mutated_line": "col = center - m // -2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // -2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] + m + 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] + m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] * m + 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] * m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] - m + 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 2\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] - m + 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 0\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] - m + 0",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 0\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][0] - m + -1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + -1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "col = available[row][1]",
      "mutated_line": "col = available[row][2]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][2]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "col = available[row][1]",
      "mutated_line": "col = available[row][0]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][0]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "col = available[row][1]",
      "mutated_line": "col = available[row][0]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][0]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "col = available[row][1]",
      "mutated_line": "col = available[row][-1]",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][-1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col - m - 1))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col - m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col * m - 1))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col * m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col + m - 2))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 2))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col + m - 0))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 0))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col + m - 0))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 0))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append((best_row, best_col, best_col + m - 1))",
      "mutated_line": "results.append((best_row, best_col, best_col + m - -1))",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - -1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 2) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 2) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 0) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 0) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - 0) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 0) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance += (col - center) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (col - center) * num + (num - -1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - -1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num + 1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num + 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + num * 1 * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + num * 1 * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center + col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center + col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += center * col * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += center * col * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col - 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col - 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * ((center - col) * 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * ((center - col) * 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col + center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col + center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + end_col * center * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + end_col * center * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center - 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center - 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * ((end_col - center) * 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * ((end_col - center) * 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][1] <= available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][1] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][-1] <= available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][-1] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][1] <= available[row][1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][1] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] <= available[row][2] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][2] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] <= available[row][0] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][0] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] <= available[row][0] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][0] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif center - available[row][0] <= available[row][1] - center:",
      "mutated_line": "elif center - available[row][0] <= available[row][-1] - center:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][-1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 2) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 2) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 0) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 0) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - 0) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 0) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance += (center - end_col) * num + (num - 1) * num // 2",
      "mutated_line": "distance += (center - end_col) * num + (num - -1) * num // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - -1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center + col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center + col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center * col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center * col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 2) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 2) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 0) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 0) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 0) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 0) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + -1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + -1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col + center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col + center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col * center + 1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col * center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 2) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 2) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 0) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 0) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 0) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 0) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2",
      "mutated_line": "distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + -1) // 2",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + -1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][2] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][2] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][0] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][0] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][0] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][0] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if available[row][0] < m and K - available[row][1] + 1 < m:",
      "mutated_line": "if available[row][0] < m and K - available[row][-1] + 1 < m:",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][-1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][0] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][1] - m + 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][1] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][-1] - m + 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][-1] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "col = available[row][0] - m + 1",
      "mutated_line": "col = available[row][1] - m + 1",
      "code": "def find_best_seats(N, K, requests):\n\n    def calc_distance(center, row, col, num):\n        end_col = col + num - 1\n        distance = abs(center - row) * num\n        if col >= center:\n            distance += (col - center) * num + (num - 1) * num // 2\n        elif end_col <= center:\n            distance += (center - end_col) * num + (num - 1) * num // 2\n        else:\n            distance += (center - col) * (center - col + 1) // 2 + (end_col - center) * (end_col - center + 1) // 2\n        return distance\n    results = []\n    available = [[K, 1] for _ in range(K + 1)]\n    center = (K + 1) // 2\n    for m in requests:\n        (closest, best_row, best_col) = (10000, -1, -1)\n        for row in range(1, K + 1):\n            if available[row][0] < m and K - available[row][1] + 1 < m:\n                continue\n            if available[row][0] == K:\n                col = center - m // 2\n            elif center - available[row][0] <= available[row][1] - center:\n                col = available[row][1] - m + 1\n            else:\n                col = available[row][1]\n            distance = calc_distance(center, row, col, m)\n            if distance < closest:\n                closest = distance\n                best_row = row\n                best_col = col\n        if closest == 10000:\n            results.append(-1)\n        else:\n            results.append((best_row, best_col, best_col + m - 1))\n            available[best_row][0] = min(available[best_row][0], best_col - 1)\n            available[best_row][1] = max(available[best_row][1], best_col + m)\n    return results"
    }
  ]
}