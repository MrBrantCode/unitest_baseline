{
  "task_id": "taco_5063",
  "entry_point": "min_operations_to_make_sequence_good",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] / (len(ar) + 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] / (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] + (len(ar) + 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] + (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] ** (len(ar) + 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] ** (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 1\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = -1",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = -1\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 1\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[1] + ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] + ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[1] * ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] * ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(ar) == 0:",
      "mutated_line": "if len(ar) != 0:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) != 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] * (len(ar) - 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) - 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] * (len(ar) * 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) * 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[1] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[-1] = 0",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[-1] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[1] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[1] = maxsize",
      "mutated_line": "dp[2] = maxsize",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[2] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[1] = maxsize",
      "mutated_line": "dp[0] = maxsize",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[0] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[1] = maxsize",
      "mutated_line": "dp[0] = maxsize",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[0] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[1] = maxsize",
      "mutated_line": "dp[-1] = maxsize",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[-1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[3] = ar[1] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[3] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[1] = ar[1] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[1] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[0] = ar[1] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[0] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[1] = ar[1] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[1] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[-2] = ar[1] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[-2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(4, len(ar) + 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(4, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(2, len(ar) + 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(2, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(0, len(ar) + 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(0, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(1, len(ar) + 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(1, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(-3, len(ar) + 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(-3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(3, len(ar) - 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) - 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(3, len(ar) * 1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) * 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(ar) == 0:",
      "mutated_line": "if len(ar) == 1:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 1:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(ar) == 0:",
      "mutated_line": "if len(ar) == -1:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == -1:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(ar) == 0:",
      "mutated_line": "if len(ar) == 1:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 1:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif len(ar) == 1:",
      "mutated_line": "elif len(ar) != 1:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) != 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [1] * (len(ar) + 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [1] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [-1] * (len(ar) + 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [-1] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [1] * (len(ar) + 1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [1] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] * (len(ar) + 2)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 2)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] * (len(ar) + 0)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 0)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] * (len(ar) + 0)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 0)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp = [0] * (len(ar) + 1)",
      "mutated_line": "dp = [0] * (len(ar) + -1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + -1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[2] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[2] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[0] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[0] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[0] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[0] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[-1] - ar[0]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[-1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[1] - ar[1]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[1]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[1] - ar[-1]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[-1]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[2] = ar[1] - ar[0]",
      "mutated_line": "dp[2] = ar[1] - ar[1]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[1]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(3, len(ar) + 2):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 2):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(3, len(ar) + 0):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 0):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(3, len(ar) + 0):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 0):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(3, len(ar) + 1):",
      "mutated_line": "for i in range(3, len(ar) + -1):",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + -1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] + ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] + ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min((dp[i - 2] + ar[i - 1]) * ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min((dp[i - 2] + ar[i - 1]) * ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] + ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] + ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], (dp[i - 3] + ar[i - 1]) * ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], (dp[i - 3] + ar[i - 1]) * ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(1)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(-1)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(1)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(ar) == 1:",
      "mutated_line": "elif len(ar) == 2:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 2:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(ar) == 1:",
      "mutated_line": "elif len(ar) == 0:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 0:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(ar) == 1:",
      "mutated_line": "elif len(ar) == 0:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 0:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif len(ar) == 1:",
      "mutated_line": "elif len(ar) == -1:",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == -1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] - ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] - ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] * ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] * ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] - ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] - ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] * ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] * ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] - ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] - ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] * ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] * ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] - ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] - ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] * ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] * ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(+1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i + 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i + 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i * 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i * 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i + 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i + 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i * 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i * 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-2)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-0)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-0)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(--1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i + 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i + 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i * 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i * 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i + 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i + 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i * 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i * 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 3], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 3], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 1], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 1], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 0], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 0], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 1], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 1], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - -2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - -2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i + 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i + 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i * 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i * 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i + 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i + 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i * 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i * 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 4])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 4])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 2])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 2])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 0])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 0])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 1])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 1])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - -3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - -3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[+(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[+(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:+(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:+(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[+(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[+(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:+(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:+(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 3] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 3] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 1] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 1] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 0] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 0] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 1] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 1] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - -2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - -2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 2] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 2] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 0] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 0] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 0] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 0] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - -1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - -1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 4] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 4] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 2] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 2] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 0] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 0] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 1] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 1] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - -3] + ar[i - 1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - -3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 2] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 2] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 0] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 0] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 0] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 0] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])",
      "mutated_line": "dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - -1] - ar[i - 3])",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - -1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n + ar[-1]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n + ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n * ar[-1]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n * ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n + ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n + ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n * ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n * ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n + ar[-2]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n + ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n * ar[-2]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n * ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n + ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n + ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n * ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n * ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[+1]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[+1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[+1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[+1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[+2]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[+2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[+2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[+2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-0]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-0]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-0]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-0]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[--1]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[--1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-2])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-0])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-0])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-0])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-0])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]",
      "mutated_line": "temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[--1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[--1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-3]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-3]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-0]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-0]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[--2]):] + ls[:-(n - ar[-2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[--2]):] + ls[:-(n - ar[-2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-3])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-3])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-1])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-0])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-0])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-1])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-1])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[-2])]",
      "mutated_line": "temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[--2])]",
      "code": "from sys import maxsize\n\ndef min_operations_to_make_sequence_good(test_cases):\n\n    def solve(ar):\n        dp = [0] * (len(ar) + 1)\n        dp[0] = 0\n        dp[1] = maxsize\n        dp[2] = ar[1] - ar[0]\n        for i in range(3, len(ar) + 1):\n            dp[i] = min(dp[i - 2] + ar[i - 1] - ar[i - 2], dp[i - 3] + ar[i - 1] - ar[i - 3])\n        return dp[len(ar)]\n\n    def construct_arr(arr):\n        ar = []\n        for i in range(len(arr)):\n            if arr[i]:\n                ar.append(i)\n        return ar\n    results = []\n    for (n, ls) in test_cases:\n        ar = construct_arr(ls)\n        if len(ar) == 0:\n            results.append(0)\n        elif len(ar) == 1:\n            results.append(-1)\n        else:\n            ans1 = solve(ar)\n            temp1 = ls[-(n - ar[-1]):] + ls[:-(n - ar[-1])]\n            temp2 = ls[-(n - ar[-2]):] + ls[:-(n - ar[--2])]\n            results.append(min((solve(ar), solve(construct_arr(temp1)), solve(construct_arr(temp2)))))\n    return results"
    }
  ]
}