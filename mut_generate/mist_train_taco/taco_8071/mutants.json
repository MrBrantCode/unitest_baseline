{
  "task_id": "taco_8071",
  "entry_point": "count_max_hamming_permutations",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "MOD = 1000000008\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "MOD = 1000000006\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "MOD = -1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if L == 1:",
      "mutated_line": "if L != 1:",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L != 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nfact = [1]",
      "mutated_line": "nfact = [2]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [2]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nfact = [1]",
      "mutated_line": "nfact = [0]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [0]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nfact = [1]",
      "mutated_line": "nfact = [0]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [0]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nfact = [1]",
      "mutated_line": "nfact = [-1]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [-1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(100):",
      "mutated_line": "for i in range(101):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(101):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(100):",
      "mutated_line": "for i in range(99):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(99):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(100):",
      "mutated_line": "for i in range(0):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(0):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(100):",
      "mutated_line": "for i in range(1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(1):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(100):",
      "mutated_line": "for i in range(-100):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(-100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(2, 100):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(2, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(0, 100):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(0, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(0, 100):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(0, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(-1, 100):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(-1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(1, 101):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 101):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(1, 99):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 99):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(1, 0):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 0):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(1, 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 1):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, 100):",
      "mutated_line": "for i in range(1, -100):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, -100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if L == 1:",
      "mutated_line": "if L == 2:",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 2:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if L == 1:",
      "mutated_line": "if L == 0:",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 0:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if L == 1:",
      "mutated_line": "if L == 0:",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 0:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if L == 1:",
      "mutated_line": "if L == -1:",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == -1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 2\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 0\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 0\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return -1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "signum = -1",
      "mutated_line": "signum = +1",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = +1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "signum *= -1",
      "mutated_line": "signum /= -1",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum /= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i + 1) * MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) * MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i + 1) + MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) + MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nak = [[1]]  # nak[0][0] = 1",
      "mutated_line": "nak = [[2]]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[2]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nak = [[1]]  # nak[0][0] = 1",
      "mutated_line": "nak = [[0]]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[0]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nak = [[1]]  # nak[0][0] = 1",
      "mutated_line": "nak = [[0]]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[0]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nak = [[1]]  # nak[0][0] = 1",
      "mutated_line": "nak = [[-1]]",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[-1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(i - 1):",
      "mutated_line": "for j in range(i + 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i + 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(i - 1):",
      "mutated_line": "for j in range(i * 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i * 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nak[i].append(1)",
      "mutated_line": "nak[i].append(2)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(2)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nak[i].append(1)",
      "mutated_line": "nak[i].append(0)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(0)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nak[i].append(1)",
      "mutated_line": "nak[i].append(0)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(0)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nak[i].append(1)",
      "mutated_line": "nak[i].append(-1)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(-1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "signum = -1",
      "mutated_line": "signum = -2",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -2\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "signum = -1",
      "mutated_line": "signum = -0",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -0\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "signum = -1",
      "mutated_line": "signum = -0",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -0\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "signum = -1",
      "mutated_line": "signum = --1",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = --1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(2, L + 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(2, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(0, L + 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(0, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(0, L + 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(0, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(-1, L + 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(-1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(1, L - 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L - 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(1, L * 1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L * 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) * MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) * MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = temp + MOD + signum * nak[L][i] * nfact[L - i] + MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = temp + MOD + signum * nak[L][i] * nfact[L - i] + MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "signum *= -1",
      "mutated_line": "signum *= +1",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= +1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] / (i + 1) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] / (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append((nfact[i] + (i + 1)) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append((nfact[i] + (i + 1)) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] ** (i + 1) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] ** (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nak.append([1])",
      "mutated_line": "nak.append([2])",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([2])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nak.append([1])",
      "mutated_line": "nak.append([0])",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([0])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nak.append([1])",
      "mutated_line": "nak.append([0])",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([0])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nak.append([1])",
      "mutated_line": "nak.append([-1])",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([-1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i - 1):",
      "mutated_line": "for j in range(i - 2):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 2):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i - 1):",
      "mutated_line": "for j in range(i - 0):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 0):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i - 1):",
      "mutated_line": "for j in range(i - 0):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 0):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i - 1):",
      "mutated_line": "for j in range(i - -1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - -1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) * MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) * MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append(nak[i - 1][j] + nak[i - 1][j + 1] + MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append(nak[i - 1][j] + nak[i - 1][j + 1] + MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(1, L + 2):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 2):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(1, L + 0):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 0):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(1, L + 0):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 0):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, L + 1):  # i of N are at least fix points",
      "mutated_line": "for i in range(1, L + -1):",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + -1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD - signum * nak[L][i] * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD - signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD) * (signum * nak[L][i] * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD) * (signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "signum *= -1",
      "mutated_line": "signum *= -2",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -2\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "signum *= -1",
      "mutated_line": "signum *= -0",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -0\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "signum *= -1",
      "mutated_line": "signum *= -0",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -0\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "signum *= -1",
      "mutated_line": "signum *= --1",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= --1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i - 1) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i - 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i * 1) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i * 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] - nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] - nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append(nak[i - 1][j] * nak[i - 1][j + 1] % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append(nak[i - 1][j] * nak[i - 1][j + 1] % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp - MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp - MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp * MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp * MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + signum * nak[L][i] / nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] / nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + (signum * nak[L][i] + nfact[L - i])) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + (signum * nak[L][i] + nfact[L - i])) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + (signum * nak[L][i]) ** nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + (signum * nak[L][i]) ** nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i + 2) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 2) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i + 0) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 0) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i + 0) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 0) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nfact.append((nfact[i] * (i + 1)) % MOD)",
      "mutated_line": "nfact.append(nfact[i] * (i + -1) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + -1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + signum / nak[L][i] * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum / nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + (signum + nak[L][i]) * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + (signum + nak[L][i]) * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + signum ** nak[L][i] * nfact[L - i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum ** nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j - 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j - 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j * 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j * 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L + i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L + i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD",
      "mutated_line": "temp = (temp + MOD + signum * nak[L][i] * nfact[L * i]) % MOD",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L * i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i + 1][j] + nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i + 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i * 1][j] + nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i * 1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i + 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i + 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i * 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i * 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 2]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 2]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 0]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 0]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 0]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + 0]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + -1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 1][j + -1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 2][j] + nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 2][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 0][j] + nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 0][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 0][j] + nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 0][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - -1][j] + nak[i - 1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - -1][j] + nak[i - 1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 2][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 2][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 0][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 0][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - 0][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - 0][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "nak[i].append((nak[i - 1][j] + nak[i - 1][j + 1]) % MOD)",
      "mutated_line": "nak[i].append((nak[i - 1][j] + nak[i - -1][j + 1]) % MOD)",
      "code": "MOD = 1000000007\n\ndef count_max_hamming_permutations(L, string):\n    nfact = [1]\n    for i in range(100):\n        nfact.append(nfact[i] * (i + 1) % MOD)\n    nak = [[1]]\n    for i in range(1, 100):\n        nak.append([1])\n        for j in range(i - 1):\n            nak[i].append((nak[i - 1][j] + nak[i - -1][j + 1]) % MOD)\n        nak[i].append(1)\n    if L == 1:\n        return 1\n    else:\n        temp = nfact[L]\n        signum = -1\n        for i in range(1, L + 1):\n            temp = (temp + MOD + signum * nak[L][i] * nfact[L - i]) % MOD\n            signum *= -1\n        return temp"
    }
  ]
}