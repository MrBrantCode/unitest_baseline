{
  "task_id": "taco_698",
  "entry_point": "maximum_profit",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] / (M + 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] / (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] + (M + 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] + (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] ** (M + 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] ** (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-1][2]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][2]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-1][0]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][0]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-1][0]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][0]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-1][-1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][-1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] * (M - 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M - 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] * (M * 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M * 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if p + dp[s] > dp[e]:",
      "mutated_line": "if p + dp[s] >= dp[e]:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] >= dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if p + dp[s] > dp[e]:",
      "mutated_line": "if p + dp[s] <= dp[e]:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] <= dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if p + dp[s] > dp[e]:",
      "mutated_line": "if p + dp[s] != dp[e]:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] != dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i <= n - 1:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i <= n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i >= n - 1:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i >= n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i != n - 1:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i != n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[+1][1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[+1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [1] * (M + 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [1] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [-1] * (M + 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [-1] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [1] * (M + 1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [1] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] * (M + 2)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 2)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] * (M + 0)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 0)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] * (M + 0)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 0)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [0] * (M + 1)",
      "mutated_line": "dp = [0] * (M + -1)",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + -1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if p + dp[s] > dp[e]:",
      "mutated_line": "if p - dp[s] > dp[e]:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p - dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if p + dp[s] > dp[e]:",
      "mutated_line": "if p * dp[s] > dp[e]:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p * dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp[e] = p + dp[s]",
      "mutated_line": "dp[e] = p - dp[s]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p - dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp[e] = p + dp[s]",
      "mutated_line": "dp[e] = p * dp[s]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p * dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i < n + 1:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n + 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i < n * 1:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n * 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-2][1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-2][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-0][1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-0][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[-0][1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-0][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "M = intervals[-1][1]",
      "mutated_line": "M = intervals[--1][1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[--1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i < n - 2:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 2:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i < n - 0:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 0:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i < n - 0:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 0:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i < n - 1:",
      "mutated_line": "if i < n - -1:",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - -1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(_, en, _) = intervals[i + 1]",
      "mutated_line": "(_, en, _) = intervals[i - 1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i - 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(_, en, _) = intervals[i + 1]",
      "mutated_line": "(_, en, _) = intervals[i * 1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i * 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e - 1, en + 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e - 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e * 1, en + 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e * 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 1, en - 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en - 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 1, en * 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en * 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(_, en, _) = intervals[i + 1]",
      "mutated_line": "(_, en, _) = intervals[i + 2]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 2]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(_, en, _) = intervals[i + 1]",
      "mutated_line": "(_, en, _) = intervals[i + 0]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 0]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(_, en, _) = intervals[i + 1]",
      "mutated_line": "(_, en, _) = intervals[i + 0]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 0]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(_, en, _) = intervals[i + 1]",
      "mutated_line": "(_, en, _) = intervals[i + -1]",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + -1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 2, en + 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 2, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 0, en + 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 0, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 0, en + 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 0, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + -1, en + 1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + -1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 1, en + 2):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 2):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 1, en + 0):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 0):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 1, en + 0):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 0):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(e + 1, en + 1):",
      "mutated_line": "for j in range(e + 1, en + -1):",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + -1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[2], x[0]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[2], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], x[0]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[0], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], x[0]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[0], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[-1], x[0]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[-1], x[0]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], x[1]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[1]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], x[-1]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[-1]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intervals.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], x[1]))",
      "code": "from typing import List\n\ndef maximum_profit(n: int, intervals: List[List[int]]) -> int:\n    intervals.sort(key=lambda x: (x[1], x[1]))\n    M = intervals[-1][1]\n    dp = [0] * (M + 1)\n    for i in range(n):\n        (s, e, p) = intervals[i]\n        if p + dp[s] > dp[e]:\n            dp[e] = p + dp[s]\n        if i < n - 1:\n            (_, en, _) = intervals[i + 1]\n            for j in range(e + 1, en + 1):\n                dp[j] = dp[e]\n    return dp[M]"
    }
  ]
}