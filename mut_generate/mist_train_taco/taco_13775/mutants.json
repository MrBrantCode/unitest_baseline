{
  "task_id": "taco_13775",
  "entry_point": "alternating_characters",
  "mutant_count": 10,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\"\"\"\n    return sum((1 for (c1, c2) in zip(s, s[1:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((2 for (c1, c2) in zip(s, s[1:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((2 for (c1, c2) in zip(s, s[1:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((0 for (c1, c2) in zip(s, s[1:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((0 for (c1, c2) in zip(s, s[1:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((0 for (c1, c2) in zip(s, s[1:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((0 for (c1, c2) in zip(s, s[1:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((-1 for (c1, c2) in zip(s, s[1:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((-1 for (c1, c2) in zip(s, s[1:]) if c1 == c2))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((1 for (c1, c2) in zip(s, s[1:]) if c1 != c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((1 for (c1, c2) in zip(s, s[1:]) if c1 != c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((1 for (c1, c2) in zip(s, s[2:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((1 for (c1, c2) in zip(s, s[2:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((1 for (c1, c2) in zip(s, s[0:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((1 for (c1, c2) in zip(s, s[0:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((1 for (c1, c2) in zip(s, s[0:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((1 for (c1, c2) in zip(s, s[0:]) if c1 == c2))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return sum(1 for c1, c2 in zip(s, s[1:]) if c1 == c2)",
      "mutated_line": "return sum((1 for (c1, c2) in zip(s, s[-1:]) if c1 == c2))",
      "code": "def alternating_characters(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of deletions required to ensure no two adjacent characters in the string are the same.\n\n    Parameters:\n    s (str): The input string containing only characters 'A' and 'B'.\n\n    Returns:\n    int: The minimum number of deletions required.\n    \"\"\"\n    return sum((1 for (c1, c2) in zip(s, s[-1:]) if c1 == c2))"
    }
  ]
}