{
  "task_id": "taco_3586",
  "entry_point": "build_tree",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[0] += 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] += 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "inS = 0",
      "mutated_line": "inS = 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 1\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "inS = 0",
      "mutated_line": "inS = -1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = -1\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "inS = 0",
      "mutated_line": "inS = 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 1\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "inE = n - 1",
      "mutated_line": "inE = n + 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n + 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "inE = n - 1",
      "mutated_line": "inE = n * 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n * 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < 0 and inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 and inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[0] -= 2",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 2\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[0] -= 0",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 0\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[0] -= 0",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 0\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[0] -= -1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= -1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if inorder[i] not in mp:",
      "mutated_line": "if inorder[i] in mp:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "postS = [n - 1]",
      "mutated_line": "postS = [n + 1]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n + 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "postS = [n - 1]",
      "mutated_line": "postS = [n * 1]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n * 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inE = n - 1",
      "mutated_line": "inE = n - 2",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 2\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inE = n - 1",
      "mutated_line": "inE = n - 0",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 0\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inE = n - 1",
      "mutated_line": "inE = n - 0",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 0\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inE = n - 1",
      "mutated_line": "inE = n - -1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - -1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] <= 0 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] <= 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] >= 0 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] >= 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] != 0 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] != 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < 0 or inS >= inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS >= inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < 0 or inS <= inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS <= inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < 0 or inS != inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS != inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[1] -= 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[1] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[-1] -= 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[-1] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "postS[0] -= 1",
      "mutated_line": "postS[1] -= 1",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[1] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "index = mp[val].pop(0)",
      "mutated_line": "index = mp[val].pop(1)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(1)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "index = mp[val].pop(0)",
      "mutated_line": "index = mp[val].pop(-1)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(-1)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "index = mp[val].pop(0)",
      "mutated_line": "index = mp[val].pop(1)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(1)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "root.right = solution(inorder, postorder, postS, index + 1, inE, mp)",
      "mutated_line": "root.right = solution(inorder, postorder, postS, index - 1, inE, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index - 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "root.right = solution(inorder, postorder, postS, index + 1, inE, mp)",
      "mutated_line": "root.right = solution(inorder, postorder, postS, index * 1, inE, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index * 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "root.left = solution(inorder, postorder, postS, inS, index - 1, mp)",
      "mutated_line": "root.left = solution(inorder, postorder, postS, inS, index + 1, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index + 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "root.left = solution(inorder, postorder, postS, inS, index - 1, mp)",
      "mutated_line": "root.left = solution(inorder, postorder, postS, inS, index * 1, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index * 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "postS = [n - 1]",
      "mutated_line": "postS = [n - 2]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 2]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "postS = [n - 1]",
      "mutated_line": "postS = [n - 0]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 0]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "postS = [n - 1]",
      "mutated_line": "postS = [n - 0]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 0]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "postS = [n - 1]",
      "mutated_line": "postS = [n - -1]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - -1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < 1 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 1 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < -1 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < -1 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[0] < 1 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 1 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "val = postorder[postS[0]]",
      "mutated_line": "val = postorder[postS[1]]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[1]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "val = postorder[postS[0]]",
      "mutated_line": "val = postorder[postS[-1]]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[-1]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "val = postorder[postS[0]]",
      "mutated_line": "val = postorder[postS[1]]",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[1]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "root.right = solution(inorder, postorder, postS, index + 1, inE, mp)",
      "mutated_line": "root.right = solution(inorder, postorder, postS, index + 2, inE, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 2, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "root.right = solution(inorder, postorder, postS, index + 1, inE, mp)",
      "mutated_line": "root.right = solution(inorder, postorder, postS, index + 0, inE, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 0, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "root.right = solution(inorder, postorder, postS, index + 1, inE, mp)",
      "mutated_line": "root.right = solution(inorder, postorder, postS, index + 0, inE, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 0, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "root.right = solution(inorder, postorder, postS, index + 1, inE, mp)",
      "mutated_line": "root.right = solution(inorder, postorder, postS, index + -1, inE, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + -1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "root.left = solution(inorder, postorder, postS, inS, index - 1, mp)",
      "mutated_line": "root.left = solution(inorder, postorder, postS, inS, index - 2, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 2, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "root.left = solution(inorder, postorder, postS, inS, index - 1, mp)",
      "mutated_line": "root.left = solution(inorder, postorder, postS, inS, index - 0, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 0, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "root.left = solution(inorder, postorder, postS, inS, index - 1, mp)",
      "mutated_line": "root.left = solution(inorder, postorder, postS, inS, index - 0, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 0, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "root.left = solution(inorder, postorder, postS, inS, index - 1, mp)",
      "mutated_line": "root.left = solution(inorder, postorder, postS, inS, index - -1, mp)",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[0] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - -1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[1] < 0 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[1] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[-1] < 0 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[-1] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if postS[0] < 0 or inS > inE:",
      "mutated_line": "if postS[1] < 0 or inS > inE:",
      "code": "def build_tree(inorder, postorder, n):\n    \"\"\"\n    Constructs a binary tree from given inorder and postorder traversals.\n\n    Parameters:\n    - inorder (list): List representing the inorder traversal of the binary tree.\n    - postorder (list): List representing the postorder traversal of the binary tree.\n    - n (int): Number of nodes in the tree.\n\n    Returns:\n    - Node: The root node of the constructed binary tree.\n    \"\"\"\n    mp = {}\n    for i in range(n):\n        if inorder[i] not in mp:\n            mp[inorder[i]] = []\n        mp[inorder[i]].append(i)\n    postS = [n - 1]\n    inS = 0\n    inE = n - 1\n    return solution(inorder, postorder, postS, inS, inE, mp)\n\ndef solution(inorder, postorder, postS, inS, inE, mp):\n    if postS[1] < 0 or inS > inE:\n        return None\n    val = postorder[postS[0]]\n    postS[0] -= 1\n    root = Node(val)\n    index = mp[val].pop(0)\n    root.right = solution(inorder, postorder, postS, index + 1, inE, mp)\n    root.left = solution(inorder, postorder, postS, inS, index - 1, mp)\n    return root\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None"
    }
  ]
}