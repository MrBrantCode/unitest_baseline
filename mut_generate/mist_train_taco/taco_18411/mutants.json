{
  "task_id": "taco_18411",
  "entry_point": "segment_tree_min_query",
  "mutant_count": 167,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] / (4 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] / (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] + 4 * n",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] + 4 * n\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] ** (4 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] ** (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (4 / n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 / n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (4 + n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 + n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * 4 ** n",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * 4 ** n\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if l == r:",
      "mutated_line": "if l != r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l != r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(1, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(-1, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(1, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 1, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, -1, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 1, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n + 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n * 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs > r and qe < l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r and qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs <= l or qe >= r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l or qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) / 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) * 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (5 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (5 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (3 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (3 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (0 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (0 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (1 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (1 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = [sys.maxsize] * (4 * n)",
      "mutated_line": "st = [sys.maxsize] * (-4 * n)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (-4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) / 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) * 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 2)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 0)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 0)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, n - 1)",
      "mutated_line": "",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - -1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs >= r or qe < l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs >= r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs <= r or qe < l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs <= r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs != r or qe < l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs != r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs > r or qe <= l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe <= l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs > r or qe >= l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe >= l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qs > r or qe < l:",
      "mutated_line": "if qs > r or qe != l:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe != l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs < l and qe >= r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs < l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs > l and qe >= r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs > l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs == l and qe >= r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs == l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs <= l and qe > r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe > r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs <= l and qe < r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe < r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if qs <= l and qe >= r:",
      "mutated_line": "if qs <= l and qe == r:",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe == r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l - r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = l * r // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 3\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 1\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 0\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 1\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // -2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l - r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = l * r // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 3\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 1\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 0\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 1\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // -2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 * node - 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node - 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 * node * 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node * 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node - 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node - 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node * 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node * 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 2, m - 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m - 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 2, m * 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m * 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node - 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node - 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node * 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node * 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node - 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node - 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node * 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node * 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m - 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m - 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m * 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m * 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(1, 0, n - 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(1, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(-1, 0, n - 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(-1, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(1, 0, n - 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(1, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 1, n - 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 1, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, -1, n - 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, -1, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 1, n - 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 1, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 0, n + 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n + 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 0, n * 1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n * 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 / node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 / node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 + node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 + node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 ** node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 ** node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 * node + 2, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 2, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 * node + 0, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 0, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 * node + 0, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 0, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(2 * node + -1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + -1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 / node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 / node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 + node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 + node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 ** node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 ** node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 3, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 3, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 1, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 1, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 0, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 0, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 1, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 1, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + -2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + -2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 2, m + 2, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 2, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 2, m + 0, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 0, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 2, m + 0, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 0, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(2 * node + 2, m + -1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + -1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node - 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node - 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node * 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node * 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node - 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node - 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node * 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node * 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 / node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 / node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 + node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 + node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 ** node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 ** node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 2, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 2, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 0, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 0, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 0, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 0, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + -1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + -1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 / node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 / node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 + node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 + node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 ** node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 ** node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 3, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 3, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 1, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 1, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 0, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 0, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 1, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 1, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + -2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + -2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 2, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 2, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 0, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 0, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 0, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 0, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + -1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + -1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 0, n - 2, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 2, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 0, n - 0, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 0, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 0, n - 0, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 0, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(mini(0, 0, n - 1, qs, qe))",
      "mutated_line": "results.append(mini(0, 0, n - -1, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - -1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(3 * node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(3 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(1 * node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(1 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(0 * node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(0 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(1 * node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(1 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "build(2 * node + 1, l, m)",
      "mutated_line": "build(-2 * node + 1, l, m)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(-2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(3 * node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(3 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(1 * node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(1 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(0 * node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(0 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(1 * node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(1 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(2 * node + 2, m + 1, r)",
      "mutated_line": "build(-2 * node + 2, m + 1, r)",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(-2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 / node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 / node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 + node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 + node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 ** node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 ** node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 2], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 2], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 0], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 0], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 0], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 0], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + -1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + -1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 / node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 / node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 + node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 + node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 ** node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 ** node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node + 3])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 3])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node + 1])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 1])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node + 0])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 0])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node + 1])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 1])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[2 * node + -2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + -2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(3 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(3 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(1 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(1 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(0 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(0 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(1 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(1 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(-2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(-2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(3 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(3 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(1 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(1 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(0 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(0 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(1 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(1 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))",
      "mutated_line": "return min(mini(2 * node + 1, l, m, qs, qe), mini(-2 * node + 2, m + 1, r, qs, qe))",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(-2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[3 * node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[3 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[1 * node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[1 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[0 * node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[0 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[1 * node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[1 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[-2 * node + 1], st[2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[-2 * node + 1], st[2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[3 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[3 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[1 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[1 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[0 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[0 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[1 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[1 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st[node] = min(st[2 * node + 1], st[2 * node + 2])",
      "mutated_line": "st[node] = min(st[2 * node + 1], st[-2 * node + 2])",
      "code": "import sys\n\ndef segment_tree_min_query(arr, queries):\n    n = len(arr)\n    st = [sys.maxsize] * (4 * n)\n\n    def build(node, l, r):\n        if l == r:\n            st[node] = arr[l]\n        else:\n            m = (l + r) // 2\n            build(2 * node + 1, l, m)\n            build(2 * node + 2, m + 1, r)\n            st[node] = min(st[2 * node + 1], st[-2 * node + 2])\n    build(0, 0, n - 1)\n\n    def mini(node, l, r, qs, qe):\n        if qs > r or qe < l:\n            return sys.maxsize\n        if qs <= l and qe >= r:\n            return st[node]\n        m = (l + r) // 2\n        return min(mini(2 * node + 1, l, m, qs, qe), mini(2 * node + 2, m + 1, r, qs, qe))\n    results = []\n    for (qs, qe) in queries:\n        results.append(mini(0, 0, n - 1, qs, qe))\n    return results"
    }
  ]
}