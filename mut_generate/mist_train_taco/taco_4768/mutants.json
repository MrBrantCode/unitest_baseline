{
  "task_id": "taco_4768",
  "entry_point": "find_possible_s_t",
  "mutant_count": 140,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos -= [n * 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos -= [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos -= [n * 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos -= [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt -= [0] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt -= [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt -= [0] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt -= [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = 3 + winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 + winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = 3 * winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 * winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 10] / n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] / n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 10] + n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] + n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 10] ** n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] ** n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 10] / n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] / n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 10] + n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] + n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 10] ** n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] ** n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt += [0] / n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] / n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt += [0] + n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] + n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt += [0] ** n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] ** n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt += [0] / n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] / n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt += [0] + n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] + n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt += [0] ** n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] ** n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "winner = a[-1]",
      "mutated_line": "winner = a[+1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[+1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = 4 - winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 4 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = 2 - winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 2 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = 0 - winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 0 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = 1 - winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 1 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "looser = 3 - winner",
      "mutated_line": "looser = -3 - winner",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = -3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "serve_win_cnt = [0]",
      "mutated_line": "serve_win_cnt = [1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [1]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "serve_win_cnt = [0]",
      "mutated_line": "serve_win_cnt = [-1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [-1]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "serve_win_cnt = [0]",
      "mutated_line": "serve_win_cnt = [1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [1]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "serve_loose_cnt = [0]",
      "mutated_line": "serve_loose_cnt = [1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [1]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "serve_loose_cnt = [0]",
      "mutated_line": "serve_loose_cnt = [-1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [-1]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "serve_loose_cnt = [0]",
      "mutated_line": "serve_loose_cnt = [1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [1]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "win_pos = [-1]",
      "mutated_line": "win_pos = [+1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [+1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "loose_pos = [-1]",
      "mutated_line": "loose_pos = [+1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [+1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a[i] == winner:",
      "mutated_line": "if a[i] != winner:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] != winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = l = i = 0",
      "mutated_line": "s = l = i = 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 1\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = l = i = 0",
      "mutated_line": "s = l = i = -1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = -1\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = l = i = 0",
      "mutated_line": "s = l = i = 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 1\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sw = sl = 0",
      "mutated_line": "sw = sl = 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 1\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sw = sl = 0",
      "mutated_line": "sw = sl = -1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = -1\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sw = sl = 0",
      "mutated_line": "sw = sl = 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 1\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i <= n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i >= n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i != n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s > l or i <= n or serve_win_cnt[i] == win_cnt:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l or i <= n or serve_win_cnt[i] == win_cnt:\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "winner = a[-1]",
      "mutated_line": "winner = a[-2]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-2]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "winner = a[-1]",
      "mutated_line": "winner = a[-0]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-0]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "winner = a[-1]",
      "mutated_line": "winner = a[-0]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-0]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "winner = a[-1]",
      "mutated_line": "winner = a[--1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[--1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "win_pos = [-1]",
      "mutated_line": "win_pos = [-2]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-2]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "win_pos = [-1]",
      "mutated_line": "win_pos = [-0]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-0]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "win_pos = [-1]",
      "mutated_line": "win_pos = [-0]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-0]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "win_pos = [-1]",
      "mutated_line": "win_pos = [--1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [--1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "loose_pos = [-1]",
      "mutated_line": "loose_pos = [-2]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-2]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "loose_pos = [-1]",
      "mutated_line": "loose_pos = [-0]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-0]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "loose_pos = [-1]",
      "mutated_line": "loose_pos = [-0]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-0]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "loose_pos = [-1]",
      "mutated_line": "loose_pos = [--1]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [--1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[-1] - (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] - (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[-1] * (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] * (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[-1] - (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] - (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[-1] * (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] * (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n / 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n / 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n + 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n + 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n ** 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n ** 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n / 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n / 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n + 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n + 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n ** 10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n ** 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt += [1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [1] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt += [-1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [-1] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "serve_win_cnt += [0] * n",
      "mutated_line": "serve_win_cnt += [1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [1] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt += [1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [1] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt += [-1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [-1] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "serve_loose_cnt += [0] * n",
      "mutated_line": "serve_loose_cnt += [1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [1] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if xw < xl:",
      "mutated_line": "if xw <= xl:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw <= xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if xw < xl:",
      "mutated_line": "if xw >= xl:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw >= xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if xw < xl:",
      "mutated_line": "if xw != xl:",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw != xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "s += 1",
      "mutated_line": "s -= 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s -= 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l -= 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l -= 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "i = min(xw, xl) + 1",
      "mutated_line": "i = min(xw, xl) - 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) - 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "i = min(xw, xl) + 1",
      "mutated_line": "i = min(xw, xl) * 1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) * 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s >= l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s >= l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s <= l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s <= l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s != l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s != l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s > l and i < n and (serve_win_cnt[i] == win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i < n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s > l and i > n and (serve_win_cnt[i] == win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i > n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s > l and i == n and (serve_win_cnt[i] == win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i == n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s > l and i <= n and (serve_win_cnt[i] == win_cnt):",
      "mutated_line": "if s > l and i <= n and (serve_win_cnt[i] != win_cnt):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] != win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] != winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] != winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] != looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] != looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 11] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 11] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 9] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 9] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 0] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 0] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * 1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 1] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "win_pos += [n * 10] * n",
      "mutated_line": "win_pos += [n * -10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * -10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 11] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 11] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 9] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 9] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 0] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 0] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * 1] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 1] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "loose_pos += [n * 10] * n",
      "mutated_line": "loose_pos += [n * -10] * n",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * -10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(2, 1 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(2, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(0, 1 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(0, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(0, 1 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(0, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(-1, 1 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(-1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 - win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 - win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 * (win_cnt // 2))), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 * (win_cnt // 2))), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "xw = win_pos[serve_win_cnt[i] + t]",
      "mutated_line": "xw = win_pos[serve_win_cnt[i] - t]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] - t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "xw = win_pos[serve_win_cnt[i] + t]",
      "mutated_line": "xw = win_pos[serve_win_cnt[i] * t]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] * t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "xl = loose_pos[serve_loose_cnt[i] + t]",
      "mutated_line": "xl = loose_pos[serve_loose_cnt[i] - t]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] - t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "xl = loose_pos[serve_loose_cnt[i] + t]",
      "mutated_line": "xl = loose_pos[serve_loose_cnt[i] * t]",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] * t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "s += 1",
      "mutated_line": "s += 2",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 2\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 0\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 0\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "s += 1",
      "mutated_line": "s += -1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += -1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += 2",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 2\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 0\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 0\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += -1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += -1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min(xw, xl) + 1",
      "mutated_line": "i = min(xw, xl) + 2",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 2\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min(xw, xl) + 1",
      "mutated_line": "i = min(xw, xl) + 0",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 0\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min(xw, xl) + 1",
      "mutated_line": "i = min(xw, xl) + 0",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 0\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min(xw, xl) + 1",
      "mutated_line": "i = min(xw, xl) + -1",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + -1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[+1] + (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[+1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[+1] + (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[+1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 2 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 2 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 0 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 0 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 0 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 0 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, -1 + win_cnt // 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, -1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt / 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt / 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt * 2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt * 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[-2] + (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-2] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[-0] + (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-0] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[-0] + (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-0] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))",
      "mutated_line": "serve_win_cnt.append(serve_win_cnt[--1] + (a[i] == winner))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[--1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[-2] + (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-2] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[-0] + (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-0] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[-0] + (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-0] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))",
      "mutated_line": "serve_loose_cnt.append(serve_loose_cnt[--1] + (a[i] == looser))",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[--1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 3)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 3)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 1)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 1)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 0)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 0)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 1)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // 1)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // 2)), [win_cnt]):",
      "mutated_line": "for t in itertools.chain(list(range(1, 1 + win_cnt // -2)), [win_cnt]):",
      "code": "import itertools\n\ndef find_possible_s_t(n, a):\n    winner = a[-1]\n    looser = 3 - winner\n    serve_win_cnt = [0]\n    serve_loose_cnt = [0]\n    win_pos = [-1]\n    loose_pos = [-1]\n    result = []\n    win_cnt = a.count(winner)\n    for i in range(n):\n        if a[i] == winner:\n            win_pos.append(i)\n        else:\n            loose_pos.append(i)\n        serve_win_cnt.append(serve_win_cnt[-1] + (a[i] == winner))\n        serve_loose_cnt.append(serve_loose_cnt[-1] + (a[i] == looser))\n    win_pos += [n * 10] * n\n    loose_pos += [n * 10] * n\n    serve_win_cnt += [0] * n\n    serve_loose_cnt += [0] * n\n    for t in itertools.chain(list(range(1, 1 + win_cnt // -2)), [win_cnt]):\n        s = l = i = 0\n        sw = sl = 0\n        while i < n:\n            xw = win_pos[serve_win_cnt[i] + t]\n            xl = loose_pos[serve_loose_cnt[i] + t]\n            if xw < xl:\n                s += 1\n            else:\n                l += 1\n            i = min(xw, xl) + 1\n        if s > l and i <= n and (serve_win_cnt[i] == win_cnt):\n            result.append((s, t))\n    k = len(result)\n    options = sorted(result)\n    return (k, options)"
    }
  ]
}