{
  "task_id": "taco_8158",
  "entry_point": "is_possible_permutation_game",
  "mutant_count": 140,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[0] or not earliestPossible[1]:",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] or not earliestPossible[1]:\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) or (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) or (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s and (ups[1] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s and (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] / n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] / n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] + n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] + n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] ** n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] ** n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] / n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] / n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] + n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] + n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [0] ** n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] ** n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, +1, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, +1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -1, +1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, +1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if ups[i] == s:",
      "mutated_line": "if ups[i] != s:",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] != s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if downs[i] == s:",
      "mutated_line": "if downs[i] != s:",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] != s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, +1, -2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, +1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -1, +2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, +2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if ups[i] == s:",
      "mutated_line": "if ups[i] != s:",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] != s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if downs[i] == s:",
      "mutated_line": "if downs[i] != s:",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] != s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return ''\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] and earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] and earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] and earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] and earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return ''\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] != s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] != s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s or downs[1] == s or k > 1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s or downs[1] == s or k > 1):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return ''\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ups = [[i + 1 for i in range(n)]]",
      "mutated_line": "ups = [[i - 1 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i - 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ups = [[i + 1 for i in range(n)]]",
      "mutated_line": "ups = [[i * 1 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i * 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "downs = [[i + 1 for i in range(n)]]",
      "mutated_line": "downs = [[i - 1 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i - 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "downs = [[i + 1 for i in range(n)]]",
      "mutated_line": "downs = [[i * 1 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i * 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -2, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -2, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -0, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -0, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -0, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -0, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, --1, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, --1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -1, -2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -1, -0):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -0):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -1, -0):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -0):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(k, -1, -1):",
      "mutated_line": "for i in range(k, -1, --1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, --1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -2, -2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -2, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -0, -2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -0, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -0, -2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -0, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, --1, -2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, --1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -1, -3):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -3):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -1, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -1, -0):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -0):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -1, -1):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(k, -1, -2):",
      "mutated_line": "for i in range(k, -1, --2):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, --2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] <= earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] <= earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] >= earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] >= earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] != earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] != earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] <= earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] <= earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] >= earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] >= earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] != earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] != earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] != s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] != s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] != s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] != s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k >= 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k >= 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k <= 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k <= 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k != 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k != 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [1] * n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [1] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [-1] * n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [-1] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [1] * n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [1] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "out[i] = arr[q[i] - 1]",
      "mutated_line": "out[i] = arr[q[i] + 1]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] + 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "out[i] = arr[q[i] - 1]",
      "mutated_line": "out[i] = arr[q[i] * 1]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] * 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [1] * n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [1] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [-1] * n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [-1] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "out = [0] * n",
      "mutated_line": "out = [1] * n",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [1] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "out[q[i] - 1] = arr[i]",
      "mutated_line": "out[q[i] + 1] = arr[i]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] + 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "out[q[i] - 1] = arr[i]",
      "mutated_line": "out[q[i] * 1] = arr[i]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] * 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ups = [[i + 1 for i in range(n)]]",
      "mutated_line": "ups = [[i + 2 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 2 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ups = [[i + 1 for i in range(n)]]",
      "mutated_line": "ups = [[i + 0 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 0 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ups = [[i + 1 for i in range(n)]]",
      "mutated_line": "ups = [[i + 0 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 0 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ups = [[i + 1 for i in range(n)]]",
      "mutated_line": "ups = [[i + -1 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + -1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "downs = [[i + 1 for i in range(n)]]",
      "mutated_line": "downs = [[i + 2 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 2 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "downs = [[i + 1 for i in range(n)]]",
      "mutated_line": "downs = [[i + 0 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 0 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "downs = [[i + 1 for i in range(n)]]",
      "mutated_line": "downs = [[i + 0 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 0 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "downs = [[i + 1 for i in range(n)]]",
      "mutated_line": "downs = [[i + -1 for i in range(n)]]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + -1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "earliest[0] = i",
      "mutated_line": "earliest[1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[1] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "earliest[0] = i",
      "mutated_line": "earliest[-1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[-1] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "earliest[0] = i",
      "mutated_line": "earliest[1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[1] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "earliest[1] = i",
      "mutated_line": "earliest[2] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[2] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "earliest[1] = i",
      "mutated_line": "earliest[0] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[0] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "earliest[1] = i",
      "mutated_line": "earliest[0] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[0] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "earliest[1] = i",
      "mutated_line": "earliest[-1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[-1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "earliestPossible[0] = i",
      "mutated_line": "earliestPossible[1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[1] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "earliestPossible[0] = i",
      "mutated_line": "earliestPossible[-1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[-1] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "earliestPossible[0] = i",
      "mutated_line": "earliestPossible[1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[1] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "earliestPossible[1] = i",
      "mutated_line": "earliestPossible[2] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[2] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "earliestPossible[1] = i",
      "mutated_line": "earliestPossible[0] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[0] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "earliestPossible[1] = i",
      "mutated_line": "earliestPossible[0] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[0] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "earliestPossible[1] = i",
      "mutated_line": "earliestPossible[-1] = i",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[-1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[1] and (not earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[1] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[-1] and (not earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[-1] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[1] and (not earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[1] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[0] and (not earliestPossible[2]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[2]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[0] and (not earliestPossible[0]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[0]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[0] and (not earliestPossible[0]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[0]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not earliestPossible[0] and (not earliestPossible[1]):",
      "mutated_line": "if not earliestPossible[0] and (not earliestPossible[-1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[-1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[1] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[1] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[-1] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[-1] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[1] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[1] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 2)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 2)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 0)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 0)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 0)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 0)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > -1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > -1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "out[i] = arr[q[i] - 1]",
      "mutated_line": "out[i] = arr[q[i] - 2]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 2]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "out[i] = arr[q[i] - 1]",
      "mutated_line": "out[i] = arr[q[i] - 0]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 0]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "out[i] = arr[q[i] - 1]",
      "mutated_line": "out[i] = arr[q[i] - 0]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 0]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "out[i] = arr[q[i] - 1]",
      "mutated_line": "out[i] = arr[q[i] - -1]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - -1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "out[q[i] - 1] = arr[i]",
      "mutated_line": "out[q[i] - 2] = arr[i]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 2] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "out[q[i] - 1] = arr[i]",
      "mutated_line": "out[q[i] - 0] = arr[i]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 0] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "out[q[i] - 1] = arr[i]",
      "mutated_line": "out[q[i] - 0] = arr[i]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 0] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "out[q[i] - 1] = arr[i]",
      "mutated_line": "out[q[i] - -1] = arr[i]",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - -1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[1] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[1] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[-1] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[-1] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[1] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[1] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[1] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[1] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[-1] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[-1] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[1] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[1] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[1]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[1]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[-1]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[-1]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[1]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[1]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[2] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[2] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[0] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[0] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[0] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[0] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[-1] or earliest[1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[-1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[2] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[2] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[0] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[0] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[0] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[0] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[-1] < earliestPossible[1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[-1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[2]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[2]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[0]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[0]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[0]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[0]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):",
      "mutated_line": "if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[-1]):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[-1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[2] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[2] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[0] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[0] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[0] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[0] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[-1] == s and downs[1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[-1] == s and downs[1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[2] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[2] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[0] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[0] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[0] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[0] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ups[0] == s or (ups[1] == s and downs[1] == s and (k > 1)):",
      "mutated_line": "if ups[0] == s or (ups[1] == s and downs[-1] == s and (k > 1)):",
      "code": "def is_possible_permutation_game(n, k, q, s):\n\n    def apply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[i] = arr[q[i] - 1]\n        return out\n\n    def unapply(arr):\n        out = [0] * n\n        for i in range(n):\n            out[q[i] - 1] = arr[i]\n        return out\n    ups = [[i + 1 for i in range(n)]]\n    downs = [[i + 1 for i in range(n)]]\n    for i in range(k):\n        ups.append(apply(ups[i]))\n    for i in range(k):\n        downs.append(unapply(downs[i]))\n    earliest = [None, None]\n    earliestPossible = [None, None]\n    for i in range(k, -1, -1):\n        if ups[i] == s:\n            earliest[0] = i\n        if downs[i] == s:\n            earliest[1] = i\n    for i in range(k, -1, -2):\n        if ups[i] == s:\n            earliestPossible[0] = i\n        if downs[i] == s:\n            earliestPossible[1] = i\n    if not earliestPossible[0] and (not earliestPossible[1]):\n        return 'NO'\n    if (not earliestPossible[0] or earliest[0] < earliestPossible[0]) and (not earliestPossible[1] or earliest[1] < earliestPossible[1]):\n        return 'NO'\n    if ups[0] == s or (ups[1] == s and downs[-1] == s and (k > 1)):\n        return 'NO'\n    return 'YES'"
    }
  ]
}