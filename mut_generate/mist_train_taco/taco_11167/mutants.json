{
  "task_id": "taco_11167",
  "entry_point": "find_longest_palindrome_prefix_suffix",
  "mutant_count": 208,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 != 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 != 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a = '#' + a + '#'",
      "mutated_line": "a = '#' + a - '#'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a - '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a = '#' + a + '#'",
      "mutated_line": "a = ('#' + a) * '#'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = ('#' + a) * '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = ''",
      "mutated_line": "ans1 = 'MUTATED'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = 'MUTATED'\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans2 = ''",
      "mutated_line": "ans2 = 'MUTATED'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = 'MUTATED'\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if len(ans1) > len(ans2):",
      "mutated_line": "if len(ans1) >= len(ans2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) >= len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if len(ans1) > len(ans2):",
      "mutated_line": "if len(ans1) <= len(ans2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) <= len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if len(ans1) > len(ans2):",
      "mutated_line": "if len(ans1) != len(ans2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) != len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v + ans - v[::-1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans - v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return (v + ans) * v[::-1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return (v + ans) * v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] / N",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] / N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] + N",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] + N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] ** N",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] ** N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n * 2 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n * 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n + 2 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n + 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 1:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == -1:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 1:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = ''",
      "mutated_line": "c = 'MUTATED'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = 'MUTATED'\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n / 2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n / 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n * 2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n * 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] == s[n - 1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] == s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a = '#' + a + '#'",
      "mutated_line": "a = '#' - a + '#'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' - a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a = '#' + a + '#'",
      "mutated_line": "a = '#' * a + '#'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' * a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a = '#' + a + '#'",
      "mutated_line": "a = '#' + a + ''",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + ''\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 1, -1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 1, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), -1, -1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), -1, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 1, -1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 1, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, +1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, +1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if i == A[i]:",
      "mutated_line": "if i != A[i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i != A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 1, -1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 1, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), -1, -1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), -1, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 1, -1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 1, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, +1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, +1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i != A[-1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i != A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v - ans + v[::-1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v - ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v * ans + v[::-1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v * ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(r, p) = (0, 0)",
      "mutated_line": "(r, p) = (1, 0)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (1, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(r, p) = (0, 0)",
      "mutated_line": "(r, p) = (-1, 0)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (-1, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(r, p) = (0, 0)",
      "mutated_line": "(r, p) = (1, 0)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (1, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(r, p) = (0, 0)",
      "mutated_line": "(r, p) = (0, 1)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 1)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(r, p) = (0, 0)",
      "mutated_line": "(r, p) = (0, -1)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, -1)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(r, p) = (0, 0)",
      "mutated_line": "(r, p) = (0, 1)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 1)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i <= r:",
      "mutated_line": "if i < r:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i < r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i <= r:",
      "mutated_line": "if i > r:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i > r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i <= r:",
      "mutated_line": "if i == r:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i == r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 or i + A[i] + 1 < N or S[i - A[i] - 1] == S[i + A[i] + 1]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 or i + A[i] + 1 < N or S[i - A[i] - 1] == S[i + A[i] + 1]:\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "A[i] += 1",
      "mutated_line": "A[i] -= 1",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] -= 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if r < i + A[i]:",
      "mutated_line": "if r <= i + A[i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r <= i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if r < i + A[i]:",
      "mutated_line": "if r >= i + A[i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r >= i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if r < i + A[i]:",
      "mutated_line": "if r != i + A[i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r != i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 3 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 3 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 1 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 0 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 0 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 1 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % -2 == 0:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % -2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n / 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n / 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n * 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n * 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 3):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 3):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 1):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 0):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 0):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 1):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // -2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // -2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "a = '#'.join(c)",
      "mutated_line": "a = ''.join(c)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = ''.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a = '#' + a + '#'",
      "mutated_line": "a = '' + a + '#'",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, -2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -2):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, -0):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -0):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, -0):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -0):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, --1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, --1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, -2):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -2):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, -0):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -0):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, -0):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -0):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(len(c), 0, -1):",
      "mutated_line": "for i in range(len(c), 0, --1):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, --1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [1] * N",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [1] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [-1] * N",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [-1] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [1] * N",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [1] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "A[i] = 0",
      "mutated_line": "A[i] = 1",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 1\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "A[i] = 0",
      "mutated_line": "A[i] = -1",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = -1\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "A[i] = 0",
      "mutated_line": "A[i] = 1",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 1\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 > 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 > 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 < 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 < 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 == 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 == 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 <= N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 <= N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 >= N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 >= N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 != N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 != N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] != S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] != S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "A[i] += 1",
      "mutated_line": "A[i] += 2",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 2\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "A[i] += 1",
      "mutated_line": "A[i] += 0",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 0\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "A[i] += 1",
      "mutated_line": "A[i] += 0",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 0\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "A[i] += 1",
      "mutated_line": "A[i] += -1",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += -1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if r < i + A[i]:",
      "mutated_line": "if r < i - A[i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i - A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if r < i + A[i]:",
      "mutated_line": "if r < i * A[i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i * A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "r = i + A[i]",
      "mutated_line": "r = i - A[i]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i - A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "r = i + A[i]",
      "mutated_line": "r = i * A[i]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i * A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ''.join([i for i in S if i != '#'])",
      "mutated_line": "return 'MUTATED'.join([i for i in S if i != '#'])",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return 'MUTATED'.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n / 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n / 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n * 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n * 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n // 3]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 3]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n // 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 1]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n // 0]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 0]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n // 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 1]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "c = s[n // 2]",
      "mutated_line": "c = s[n // -2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // -2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n / 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n / 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n * 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n * 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n - 1 + i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 + i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[(n - 1) * i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[(n - 1) * i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[-1 + i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 + i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[-1 * i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 * i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v + ans + v[::+1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::+1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 * p - i], r + i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r + i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 * p - i], r * i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r * i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] + 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] + 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while (i - A[i]) * 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while (i - A[i]) * 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 1 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 1 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= -1 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= -1 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 1 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 1 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] - 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] - 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and (i + A[i]) * 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and (i + A[i]) * 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return ''.join([i for i in S if i != '#'])",
      "mutated_line": "return ''.join([i for i in S if i == '#'])",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i == '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 3]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 3]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 1]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 0]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 0]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 1]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // -2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // -2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 3]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 3]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 1]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 0]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 0]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 1]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v = s[:n // 2]",
      "mutated_line": "v = s[:n // -2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // -2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n + 1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n + 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n * 1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n * 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "c = s[i:n - i]",
      "mutated_line": "c = s[i:n + i]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n + i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "c = s[i:n - i]",
      "mutated_line": "c = s[i:n * i]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n * i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i / 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i / 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i + 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i + 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i ** 2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i ** 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[+1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[+1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 2 + 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 + 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 2 * 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 * 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v + ans + v[::-2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-2]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v + ans + v[::-0]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v + ans + v[::-0]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return v + ans + v[::-1]",
      "mutated_line": "return v + ans + v[::--1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::--1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 * p + i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p + i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 * p * i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p * i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i + A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i + A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i * A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i * A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 2 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 2 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 0 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 0 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 0 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 0 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - -1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - -1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i - A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i - A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i * A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i * A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 2 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 2 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 0 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 0 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 0 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 0 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + -1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + -1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] + 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] + 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[(i - A[i]) * 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[(i - A[i]) * 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] - 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] - 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[(i + A[i]) * 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[(i + A[i]) * 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ''.join([i for i in S if i != '#'])",
      "mutated_line": "return ''.join([i for i in S if i != ''])",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != ''])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n - 2 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 2 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n - 0 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 0 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n - 0 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 0 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[i] != s[n - 1 - i]:",
      "mutated_line": "if s[i] != s[n - -1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - -1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i * 3]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 3]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i * 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 1]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i * 0]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 0]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i * 1]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 1]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans1 = a[:i * 2]",
      "mutated_line": "ans1 = a[:i * -2]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * -2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[-2 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-2 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[-0 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-0 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[-0 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-0 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i == A[-1 - i]:",
      "mutated_line": "if i == A[--1 - i]:",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[--1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i / 2 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i / 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i + 2 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i + 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[(-i) ** 2 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[(-i) ** 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 2 - 2:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 2:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 2 - 0:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 0:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 2 - 0:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 0:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 2 - -1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - -1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 / p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 / p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 + p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 + p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[2 ** p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 ** p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i + A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i + A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i * A[i] - 1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i * A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 2] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 2] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 0] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 0] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 0] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 0] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - -1] == S[i + A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - -1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i - A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i - A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i * A[i] + 1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i * A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 2]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 2]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 0]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 0]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 0]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 0]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):",
      "mutated_line": "while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + -1]):",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + -1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[+i * 2 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[+i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 3 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 3 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 1 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 1 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 0 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 0 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * 1 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 1 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans2 = a[-i * 2 - 1:]",
      "mutated_line": "ans2 = a[-i * -2 - 1:]",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * -2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[3 * p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[3 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[1 * p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[1 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[0 * p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[0 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[1 * p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[1 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A[i] = min(A[2 * p - i], r - i)",
      "mutated_line": "A[i] = min(A[-2 * p - i], r - i)",
      "code": "def find_longest_palindrome_prefix_suffix(s: str) -> str:\n\n    def manacher(S):\n        N = len(S)\n        (r, p) = (0, 0)\n        A = [0] * N\n        for i in range(N):\n            if i <= r:\n                A[i] = min(A[-2 * p - i], r - i)\n            else:\n                A[i] = 0\n            while i - A[i] - 1 >= 0 and i + A[i] + 1 < N and (S[i - A[i] - 1] == S[i + A[i] + 1]):\n                A[i] += 1\n            if r < i + A[i]:\n                r = i + A[i]\n                p = i\n        return A\n\n    def f(S):\n        return ''.join([i for i in S if i != '#'])\n    n = len(s)\n    if n % 2 == 0:\n        c = ''\n        v = s[:n // 2]\n    else:\n        c = s[n // 2]\n        v = s[:n // 2]\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            c = s[i:n - i]\n            v = s[:i]\n            break\n    a = '#'.join(c)\n    a = '#' + a + '#'\n    A = manacher(a)\n    ans1 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[i]:\n            ans1 = a[:i * 2]\n            break\n    ans1 = f(ans1)\n    ans2 = ''\n    for i in range(len(c), 0, -1):\n        if i == A[-1 - i]:\n            ans2 = a[-i * 2 - 1:]\n            break\n    ans2 = f(ans2)\n    if len(ans1) > len(ans2):\n        ans = ans1\n    else:\n        ans = ans2\n    return v + ans + v[::-1]"
    }
  ]
}