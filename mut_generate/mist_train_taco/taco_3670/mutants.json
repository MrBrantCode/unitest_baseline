{
  "task_id": "taco_3670",
  "entry_point": "find_safe_moves",
  "mutant_count": 282,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 1\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = -1\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 1\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 1\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = 0",
      "mutated_line": "y = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = -1\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 1\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x -= s * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x -= s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y -= s * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y -= s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 1\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = -1\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 1\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 1\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = 0",
      "mutated_line": "y = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = -1\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 1\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x -= s * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x -= s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y -= s * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y -= s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx -= v[3] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx -= v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy -= v[3] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy -= v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "v[3] *= s",
      "mutated_line": "v[3] /= s",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] /= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s / v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s / v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s + v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s + v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s ** v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s ** v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s / v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s / v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s + v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s + v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s ** v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s ** v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 - y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 - y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 * y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 * y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s / v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s / v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s + v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s + v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s ** v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s ** v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s / v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s / v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s + v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s + v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s ** v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s ** v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] >= 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] >= 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] <= 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] <= 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] != 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] != 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] <= 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] <= 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] >= 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] >= 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] != 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] != 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 2] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 0] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, -1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 or v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 or v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=False, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(sx, sy) = (0, 0)",
      "mutated_line": "(sx, sy) = (1, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (1, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(sx, sy) = (0, 0)",
      "mutated_line": "(sx, sy) = (-1, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (-1, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(sx, sy) = (0, 0)",
      "mutated_line": "(sx, sy) = (1, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (1, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(sx, sy) = (0, 0)",
      "mutated_line": "(sx, sy) = (0, 1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 1)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(sx, sy) = (0, 0)",
      "mutated_line": "(sx, sy) = (0, -1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, -1)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "(sx, sy) = (0, 0)",
      "mutated_line": "(sx, sy) = (0, 1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 1)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) <= abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) <= abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) >= abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) >= abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) != abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) != abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[3] / v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] / v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[3] + v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] + v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[3] ** v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] ** v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] / v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] / v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] + v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] + v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] ** v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] ** v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for (s, V_) in zip(S[1], [V1, V2, V3, V4]):",
      "mutated_line": "for (s, V_) in zip(S[2], [V1, V2, V3, V4]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[2], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for (s, V_) in zip(S[1], [V1, V2, V3, V4]):",
      "mutated_line": "for (s, V_) in zip(S[0], [V1, V2, V3, V4]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[0], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for (s, V_) in zip(S[1], [V1, V2, V3, V4]):",
      "mutated_line": "for (s, V_) in zip(S[0], [V1, V2, V3, V4]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[0], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for (s, V_) in zip(S[1], [V1, V2, V3, V4]):",
      "mutated_line": "for (s, V_) in zip(S[-1], [V1, V2, V3, V4]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[-1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = [v[3] for v in V1]",
      "mutated_line": "ans = [v[4] for v in V1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[4] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = [v[3] for v in V1]",
      "mutated_line": "ans = [v[2] for v in V1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[2] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = [v[3] for v in V1]",
      "mutated_line": "ans = [v[0] for v in V1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[0] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = [v[3] for v in V1]",
      "mutated_line": "ans = [v[1] for v in V1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[1] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = [v[3] for v in V1]",
      "mutated_line": "ans = [v[-3] for v in V1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[-3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x * 2 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x * 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x + 2 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x + 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + y * 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y * 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + (y + 2))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + (y + 2))\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] / v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] / v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] + v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] + v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] ** v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] ** v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 1]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > -1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > -1]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 1]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] / v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] / v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] + v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] + v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] ** v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] ** v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 1]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < -1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < -1]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 1]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 1]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == -1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == -1]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 1]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] != 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] != 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) - abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) * abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) - abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) - abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) * abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) * abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) - abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) - abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) * abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) * abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[3] = 2",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 2\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[3] = 0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 0\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[3] = 0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 0\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[3] = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = -1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[3] = +1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = +1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v[3] *= s",
      "mutated_line": "v[4] *= s",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[4] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v[3] *= s",
      "mutated_line": "v[2] *= s",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[2] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v[3] *= s",
      "mutated_line": "v[0] *= s",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[0] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v[3] *= s",
      "mutated_line": "v[1] *= s",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[1] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v[3] *= s",
      "mutated_line": "v[-3] *= s",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[-3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[1]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s * v[-1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[-1]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[1]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[2]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[2]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[0]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[0]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[-1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[-1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 3 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 3 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 1 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 1 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 0 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 0 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 1 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 1 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** -2 + y ** 2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** -2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + y ** 3)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 3)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + y ** 1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 1)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + y ** 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 0)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + y ** 1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 1)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "return math.sqrt(x ** 2 + y ** -2)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** -2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[1]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s * v[-1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[-1]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x += s * v[0]",
      "mutated_line": "x += s * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[1]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[2]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[2]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[0]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[0]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y += s * v[1]",
      "mutated_line": "y += s * v[-1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[-1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]",
      "mutated_line": "V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 1 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 1 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != -1 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != -1 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 1 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 1 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 1]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == -1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == -1]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 1]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[4] = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[4] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[2] = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[2] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[0] = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[0] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[1] = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[1] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v[3] = 1",
      "mutated_line": "v[-3] = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[-3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[4] = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[4] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[2] = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[2] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[0] = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[0] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[1] = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[1] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[-3] = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[-3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[3] = -2",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -2\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[3] = -0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -0\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[3] = -0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -0\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v[3] = -1",
      "mutated_line": "v[3] = --1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = --1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[4] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[4] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[2] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[2] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[0] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[0] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[1] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[1] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[-3] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[-3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[3] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[1]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[3] * v[-1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[-1]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sx += v[3] * v[0]",
      "mutated_line": "sx += v[3] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[1]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[4] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[4] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[2] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[2] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[0] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[0] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[1] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[1] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[-3] * v[1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[-3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] * v[2]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[2]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[0]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] * v[0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[0]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sy += v[3] * v[1]",
      "mutated_line": "sy += v[3] * v[-1]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[-1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "V1.sort(key=lambda x: x[2])",
      "mutated_line": "V1.sort(key=lambda x: x[3])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[3])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "V1.sort(key=lambda x: x[2])",
      "mutated_line": "V1.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[1])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "V1.sort(key=lambda x: x[2])",
      "mutated_line": "V1.sort(key=lambda x: x[0])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[0])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "V1.sort(key=lambda x: x[2])",
      "mutated_line": "V1.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[1])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "V1.sort(key=lambda x: x[2])",
      "mutated_line": "V1.sort(key=lambda x: x[-2])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[-2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[2] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[2] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]",
      "mutated_line": "V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[-1] > 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[-1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[2] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[2] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[0] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]",
      "mutated_line": "V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[-1] < 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[-1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[-1] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] != 0 and v[1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[1] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[2] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[2] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[0] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[0] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[0] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[0] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]",
      "mutated_line": "V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[-1] == 0]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[-1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx - v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx - v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx * v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx * v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy - v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy - v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy * v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy * v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx + v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx + v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx * v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx * v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy + v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy + v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy * v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy * v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([+1, 1], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([+1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 2], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 2], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 0], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 0], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 0], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 0], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, -1], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, -1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=5)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=5)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=3)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=3)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=0)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=0)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=1)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=1)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=-4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=-4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[-1]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[1]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[2]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[0]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))",
      "mutated_line": "V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[-1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-2, 1], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-2, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-0, 1], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-0, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([-0, 1], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-0, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])",
      "mutated_line": "S = min([(D(SV, s), s) for s in product([--1, 1], repeat=4)])",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([--1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[1]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[1]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[-1]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[-1]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[1]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[1]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[2]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[2]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[0]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[0]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[0]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[0]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[-1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[-1]) < abs(sx - v[0]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[1]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[1]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[-1]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[-1]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[1]) + abs(sy - v[1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[1]) + abs(sy - v[1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[2]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[2]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[0]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[0]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[0]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[0]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[1]):",
      "mutated_line": "if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[-1]):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def D(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def XY(V, S):\n        x = 0\n        y = 0\n        for (s, v) in zip(S, V):\n            x += s * v[0]\n            y += s * v[1]\n        return (x, y)\n    V1 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] > 0]\n    V2 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] * v[1] < 0]\n    V3 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] == 0]\n    V4 = [[*v, i, 1] for (i, v) in enumerate(vectors) if v[0] != 0 and v[1] == 0]\n    V1.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V2.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V3.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n    V4.sort(reverse=True, key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def f(V):\n        (sx, sy) = (0, 0)\n        for (i, v) in enumerate(V):\n            if abs(sx + v[0]) + abs(sy + v[1]) < abs(sx - v[0]) + abs(sy - v[-1]):\n                v[3] = 1\n            else:\n                v[3] = -1\n            sx += v[3] * v[0]\n            sy += v[3] * v[1]\n        return (sx, sy)\n    SV = [f(V_) for V_ in [V1, V2, V3, V4]]\n    S = min([(D(SV, s), s) for s in product([-1, 1], repeat=4)])\n    for (s, V_) in zip(S[1], [V1, V2, V3, V4]):\n        for v in V_:\n            v[3] *= s\n    V1.extend(V2)\n    V1.extend(V3)\n    V1.extend(V4)\n    V1.sort(key=lambda x: x[2])\n    ans = [v[3] for v in V1]\n    return ans"
    }
  ]
}