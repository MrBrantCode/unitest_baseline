{
  "task_id": "taco_7262",
  "entry_point": "find_largest_survivor",
  "mutant_count": 76,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 and reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 and reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[0] != 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] != 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return max(__residue_table(numbers)) - numbers[0]",
      "mutated_line": "return max(__residue_table(numbers)) + numbers[0]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) + numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return max(__residue_table(numbers)) - numbers[0]",
      "mutated_line": "return max(__residue_table(numbers)) * numbers[0]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) * numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] - [None] * (a[0] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] - [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] * ([None] * (a[0] - 1))",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] * ([None] * (a[0] - 1))\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) <= 1 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) <= 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) >= 1 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) >= 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) != 1 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) != 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) >= 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) >= 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) <= 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) <= 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) != 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) != 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return +1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[0] == 2:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 2:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[0] == 0:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 0:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[0] == 0:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 0:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[0] == -1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == -1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 1\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return -1\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 1\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] / (a[0] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] / (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + ([None] + (a[0] - 1))",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + ([None] + (a[0] - 1))\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] ** (a[0] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] ** (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(2, len(a)):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(2, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(0, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(0, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(-1, len(a)):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(-1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 2 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 2 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 0 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 0 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 0 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 0 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < -1 or reduce(gcd, numbers) > 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < -1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 2:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 2:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 0:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 0:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 0:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 0:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(numbers) < 1 or reduce(gcd, numbers) > 1:",
      "mutated_line": "if len(numbers) < 1 or reduce(gcd, numbers) > -1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > -1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -2\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -0\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -0\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return --1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[1] == 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[1] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[-1] == 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[-1] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if numbers[0] == 1:",
      "mutated_line": "if numbers[1] == 1:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[1] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return max(__residue_table(numbers)) - numbers[0]",
      "mutated_line": "return max(__residue_table(numbers)) - numbers[1]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return max(__residue_table(numbers)) - numbers[0]",
      "mutated_line": "return max(__residue_table(numbers)) - numbers[-1]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return max(__residue_table(numbers)) - numbers[0]",
      "mutated_line": "return max(__residue_table(numbers)) - numbers[1]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [1] + [None] * (a[0] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [1] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [-1] + [None] * (a[0] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [-1] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [1] + [None] * (a[0] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [1] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[0] + 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] + 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[0] * 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] * 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "nn += a[i]",
      "mutated_line": "nn -= a[i]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn -= a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[0] - 2)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 2)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[0] - 0)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 0)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[0] - 0)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 0)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[0] - -1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - -1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d = gcd(a[0], a[i])",
      "mutated_line": "d = gcd(a[1], a[i])",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[1], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d = gcd(a[0], a[i])",
      "mutated_line": "d = gcd(a[-1], a[i])",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[-1], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d = gcd(a[0], a[i])",
      "mutated_line": "d = gcd(a[1], a[i])",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[1], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for _ in range(a[0] // d):",
      "mutated_line": "for _ in range(a[0] / d):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] / d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for _ in range(a[0] // d):",
      "mutated_line": "for _ in range(a[0] * d):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] * d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = nn % a[0]",
      "mutated_line": "p = nn * a[0]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn * a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = nn % a[0]",
      "mutated_line": "p = nn + a[0]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn + a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if n[p] is not None:",
      "mutated_line": "if n[p] is None:",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[1] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[1] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[-1] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[-1] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = [0] + [None] * (a[0] - 1)",
      "mutated_line": "n = [0] + [None] * (a[1] - 1)",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[1] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for _ in range(a[0] // d):",
      "mutated_line": "for _ in range(a[1] // d):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[1] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for _ in range(a[0] // d):",
      "mutated_line": "for _ in range(a[-1] // d):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[-1] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for _ in range(a[0] // d):",
      "mutated_line": "for _ in range(a[1] // d):",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[1] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = nn % a[0]",
      "mutated_line": "p = nn % a[1]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[1]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = nn % a[0]",
      "mutated_line": "p = nn % a[-1]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[-1]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = nn % a[0]",
      "mutated_line": "p = nn % a[1]",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[1]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))",
      "mutated_line": "nn = min((n[q] for q in range(r, a[0], d) if n[q] is None))",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[0], d) if n[q] is None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))",
      "mutated_line": "nn = min((n[q] for q in range(r, a[1], d) if n[q] is not None))",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[1], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))",
      "mutated_line": "nn = min((n[q] for q in range(r, a[-1], d) if n[q] is not None))",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[-1], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "nn = min((n[q] for q in range(r, a[0], d) if n[q] is not None))",
      "mutated_line": "nn = min((n[q] for q in range(r, a[1], d) if n[q] is not None))",
      "code": "from functools import reduce\nfrom math import gcd\n\ndef find_largest_survivor(numbers):\n\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min((n[q] for q in range(r, a[1], d) if n[q] is not None))\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None:\n                        nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n    numbers.sort()\n    if len(numbers) < 1 or reduce(gcd, numbers) > 1:\n        return -1\n    if numbers[0] == 1:\n        return 0\n    return max(__residue_table(numbers)) - numbers[0]"
    }
  ]
}