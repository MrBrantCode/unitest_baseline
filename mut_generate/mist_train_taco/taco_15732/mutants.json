{
  "task_id": "taco_15732",
  "entry_point": "min_distance_to_cross_bridge",
  "mutant_count": 99,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dist = [float('inf')] * n",
      "mutated_line": "dist = [float('inf')] / n",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] / n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dist = [float('inf')] * n",
      "mutated_line": "dist = [float('inf')] + n",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] + n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dist = [float('inf')] * n",
      "mutated_line": "dist = [float('inf')] ** n",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] ** n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 1\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = -1\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 1\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if w_max > v:",
      "mutated_line": "if w_max >= v:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max >= v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if w_max > v:",
      "mutated_line": "if w_max <= v:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max <= v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if w_max > v:",
      "mutated_line": "if w_max != v:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max != v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P = [0]",
      "mutated_line": "for (l, v) in bridge_parts:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [1]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P = [0]",
      "mutated_line": "for (l, v) in bridge_parts:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [-1]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P = [0]",
      "mutated_line": "for (l, v) in bridge_parts:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [1]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[-1] <= l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] <= l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[-1] >= l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] >= l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[-1] != l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] != l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return +dijkstra(N - 1, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return +dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = float('inf')",
      "mutated_line": "ans = float('')",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if dist[v] < d:",
      "mutated_line": "if dist[v] <= d:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] <= d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if dist[v] < d:",
      "mutated_line": "if dist[v] >= d:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] >= d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if dist[v] < d:",
      "mutated_line": "if dist[v] != d:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] != d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return +1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N + 1):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N + 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N * 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N + 1):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N + 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N * 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "que = [(0, start)]",
      "mutated_line": "que = [(1, start)]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(1, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "que = [(0, start)]",
      "mutated_line": "que = [(-1, start)]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(-1, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "que = [(0, start)]",
      "mutated_line": "que = [(1, start)]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(1, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dist[nv] > d + nd:",
      "mutated_line": "if dist[nv] >= d + nd:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] >= d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dist[nv] > d + nd:",
      "mutated_line": "if dist[nv] <= d + nd:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] <= d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dist[nv] > d + nd:",
      "mutated_line": "if dist[nv] != d + nd:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] != d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bridge_parts.sort(key=itemgetter(1))",
      "mutated_line": "(L, V) = zip(*bridge_parts)",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(2))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bridge_parts.sort(key=itemgetter(1))",
      "mutated_line": "(L, V) = zip(*bridge_parts)",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(0))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bridge_parts.sort(key=itemgetter(1))",
      "mutated_line": "(L, V) = zip(*bridge_parts)",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(0))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bridge_parts.sort(key=itemgetter(1))",
      "mutated_line": "(L, V) = zip(*bridge_parts)",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(-1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -2\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -0\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -0\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return --1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[+1] < l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[+1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 2):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 2):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 0):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 0):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - -1):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - -1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 2):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 2):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 0):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 0):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - -1):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - -1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i - 1, N):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i - 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i * 1, N):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i * 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i != 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - 1, edge)[1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[1]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - 1, edge)[-1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[-1]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - 1, edge)[1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[1]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist = [float('inf')] * n",
      "mutated_line": "dist = [float('')] * n",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dist[nv] > d + nd:",
      "mutated_line": "if dist[nv] > d - nd:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d - nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dist[nv] > d + nd:",
      "mutated_line": "if dist[nv] > d * nd:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d * nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist[nv] = d + nd",
      "mutated_line": "dist[nv] = d - nd",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d - nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist[nv] = d + nd",
      "mutated_line": "dist[nv] = d * nd",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d * nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[-2] < l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-2] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[-0] < l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-0] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[-0] < l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-0] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if P[-1] < l:",
      "mutated_line": "if P[--1] < l:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[--1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "P.append(P[-1])",
      "mutated_line": "P.append(P[+1])",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[+1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + 1].append((i, 1))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 1))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + 1].append((i, -1))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, -1))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + 1].append((i, 1))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 1))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 2, N):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 2, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 0, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 0, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + -1, N):",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + -1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 1:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == -1:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 1:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] + S[i - 1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] + S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] * S[i - 1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] * S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N + 1, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N + 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N * 1, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N * 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "P.append(P[-1])",
      "mutated_line": "P.append(P[-2])",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-2])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "P.append(P[-1])",
      "mutated_line": "P.append(P[-0])",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-0])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "P.append(P[-1])",
      "mutated_line": "P.append(P[-0])",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-0])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "P.append(P[-1])",
      "mutated_line": "P.append(P[--1])",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[--1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i - 1].append((i, 0))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i - 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i * 1].append((i, 0))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i * 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "edge[j].append((i, -p))",
      "mutated_line": "edge[j].append((i, +p))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, +p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - 2, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 2, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - 0, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 0, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - 0, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 0, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -dijkstra(N - 1, edge)[0]",
      "mutated_line": "return -dijkstra(N - -1, edge)[0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - -1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + 2].append((i, 0))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 2].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + 0].append((i, 0))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 0].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + 0].append((i, 0))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 0].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "edge[i + 1].append((i, 0))",
      "mutated_line": "edge[i + -1].append((i, 0))",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + -1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] - S[i + 1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i + 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] - S[i * 1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i * 1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] - S[i - 2]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 2]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] - S[i - 0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 0]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] - S[i - 0]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - 0]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "t = S[j] - S[i - 1]",
      "mutated_line": "t = S[j] - S[i - -1]",
      "code": "from itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef min_distance_to_cross_bridge(N, M, weights, bridge_parts):\n\n    def dijkstra(start, edge):\n        n = len(edge)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        que = [(0, start)]\n        while que:\n            (d, v) = heapq.heappop(que)\n            if dist[v] < d:\n                continue\n            for (nv, nd) in edge[v]:\n                if dist[nv] > d + nd:\n                    dist[nv] = d + nd\n                    heapq.heappush(que, (dist[nv], nv))\n        return dist\n    bridge_parts.sort(key=itemgetter(1))\n    (L, V) = zip(*bridge_parts)\n    w_max = max(weights)\n    for v in V:\n        if w_max > v:\n            return -1\n    P = [0]\n    for (l, v) in bridge_parts:\n        if P[-1] < l:\n            P.append(l)\n        else:\n            P.append(P[-1])\n\n    def f(K):\n        S = list(accumulate((weights[k] for k in K)))\n        edge = [[] for _ in range(N)]\n        for i in range(N - 1):\n            edge[i + 1].append((i, 0))\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if i == 0:\n                    t = S[j]\n                else:\n                    t = S[j] - S[i - -1]\n                p = P[bisect.bisect_left(V, t)]\n                edge[j].append((i, -p))\n        return -dijkstra(N - 1, edge)[0]\n    ans = float('inf')\n    for K in permutations(range(N)):\n        ans = min(ans, f(K))\n    return ans"
    }
  ]
}