{
  "task_id": "taco_8296",
  "entry_point": "minimum_travel_time",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX_AG = 2500",
      "mutated_line": "MX_AG = 2501",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2501\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX_AG = 2500",
      "mutated_line": "MX_AG = 2499",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2499\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX_AG = 2500",
      "mutated_line": "MX_AG = 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 0\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX_AG = 2500",
      "mutated_line": "MX_AG = 1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 1\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX_AG = 2500",
      "mutated_line": "MX_AG = -2500",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = -2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u += 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v += 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "time[0][S] = 0",
      "mutated_line": "time[0][S] = 1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 1\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "time[0][S] = 0",
      "mutated_line": "time[0][S] = -1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = -1\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "time[0][S] = 0",
      "mutated_line": "time[0][S] = 1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 1\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 2 << 60",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 2 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 0 << 60",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 0 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 0 << 60",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 0 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = -1 << 60",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = -1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 1 << 61",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 61\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 1 << 59",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 59\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 1 << 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 0\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 1 << 1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 1\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 1 << 60",
      "mutated_line": "INF = 1 << -60",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << -60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 2\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 0\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 0\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= -1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 2\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 0\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 0\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= -1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] / (MX_AG + 1) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] / (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] + (MX_AG + 1) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] + (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] ** (MX_AG + 1) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] ** (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "e_time = t + exchanges[loc][1]",
      "mutated_line": "e_time = t - exchanges[loc][1]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t - exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "e_time = t + exchanges[loc][1]",
      "mutated_line": "e_time = t * exchanges[loc][1]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t * exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "e_Ag = ag + exchanges[loc][0]",
      "mutated_line": "e_Ag = ag - exchanges[loc][0]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag - exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "e_Ag = ag + exchanges[loc][0]",
      "mutated_line": "e_Ag = ag * exchanges[loc][0]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag * exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if e_Ag > MX_AG:",
      "mutated_line": "if e_Ag >= MX_AG:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag >= MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if e_Ag > MX_AG:",
      "mutated_line": "if e_Ag <= MX_AG:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag <= MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if e_Ag > MX_AG:",
      "mutated_line": "if e_Ag != MX_AG:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag != MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if cf <= e_time:",
      "mutated_line": "if cf < e_time:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf < e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if cf <= e_time:",
      "mutated_line": "if cf > e_time:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf > e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if cf <= e_time:",
      "mutated_line": "if cf == e_time:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf == e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "h = [(0, S, 0)]",
      "mutated_line": "h = [(1, S, 0)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(1, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "h = [(0, S, 0)]",
      "mutated_line": "h = [(-1, S, 0)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(-1, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "h = [(0, S, 0)]",
      "mutated_line": "h = [(1, S, 0)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(1, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "h = [(0, S, 0)]",
      "mutated_line": "h = [(0, S, 1)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 1)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "h = [(0, S, 0)]",
      "mutated_line": "h = [(0, S, -1)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, -1)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "h = [(0, S, 0)]",
      "mutated_line": "h = [(0, S, 1)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 1)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] * (MX_AG - 1) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG - 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] * (MX_AG * 1) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG * 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "time[0][S] = 0",
      "mutated_line": "time[1][S] = 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[1][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "time[0][S] = 0",
      "mutated_line": "time[-1][S] = 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[-1][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "time[0][S] = 0",
      "mutated_line": "time[1][S] = 0",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[1][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "n_Ag = ag - fare",
      "mutated_line": "n_Ag = ag + fare",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag + fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "n_Ag = ag - fare",
      "mutated_line": "n_Ag = ag * fare",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag * fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n_Ag < 0:",
      "mutated_line": "if n_Ag <= 0:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag <= 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n_Ag < 0:",
      "mutated_line": "if n_Ag >= 0:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag >= 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if n_Ag < 0:",
      "mutated_line": "if n_Ag != 0:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag != 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "n_time = t + dt",
      "mutated_line": "n_time = t - dt",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t - dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "n_time = t + dt",
      "mutated_line": "n_time = t * dt",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t * dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if cf <= n_time:",
      "mutated_line": "if cf < n_time:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf < n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if cf <= n_time:",
      "mutated_line": "if cf > n_time:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf > n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if cf <= n_time:",
      "mutated_line": "if cf == n_time:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf == n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] * (MX_AG + 2) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 2) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] * (MX_AG + 0) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 0) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] * (MX_AG + 0) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 0) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time = [[INF] * (MX_AG + 1) for _ in range(N)]",
      "mutated_line": "time = [[INF] * (MX_AG + -1) for _ in range(N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + -1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n_Ag < 0:",
      "mutated_line": "if n_Ag < 1:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 1:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n_Ag < 0:",
      "mutated_line": "if n_Ag < -1:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < -1:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if n_Ag < 0:",
      "mutated_line": "if n_Ag < 1:",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 1:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "e_time = t + exchanges[loc][1]",
      "mutated_line": "e_time = t + exchanges[loc][2]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][2]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "e_time = t + exchanges[loc][1]",
      "mutated_line": "e_time = t + exchanges[loc][0]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][0]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "e_time = t + exchanges[loc][1]",
      "mutated_line": "e_time = t + exchanges[loc][0]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][0]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "e_time = t + exchanges[loc][1]",
      "mutated_line": "e_time = t + exchanges[loc][-1]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][-1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "e_Ag = ag + exchanges[loc][0]",
      "mutated_line": "e_Ag = ag + exchanges[loc][1]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][1]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "e_Ag = ag + exchanges[loc][0]",
      "mutated_line": "e_Ag = ag + exchanges[loc][-1]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][-1]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "e_Ag = ag + exchanges[loc][0]",
      "mutated_line": "e_Ag = ag + exchanges[loc][1]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][1]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(1, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [min(time[to]) for to in range(1, N)]",
      "mutated_line": "return [min(time[to]) for to in range(2, N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(2, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [min(time[to]) for to in range(1, N)]",
      "mutated_line": "return [min(time[to]) for to in range(0, N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(0, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [min(time[to]) for to in range(1, N)]",
      "mutated_line": "return [min(time[to]) for to in range(0, N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(0, N)]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [min(time[to]) for to in range(1, N)]",
      "mutated_line": "return [min(time[to]) for to in range(-1, N)]",
      "code": "def minimum_travel_time(N, M, S, railroads, exchanges):\n    from heapq import heappush, heappop\n    INF = 1 << 60\n    MX_AG = 2500\n    S = min(S, MX_AG)\n    g = [set() for _ in range(N)]\n    for (u, v, a, b) in railroads:\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n    h = [(0, S, 0)]\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    while h:\n        (t, ag, loc) = heappop(h)\n        for (to, fare, dt) in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0:\n                continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time:\n                continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n        e_time = t + exchanges[loc][1]\n        e_Ag = ag + exchanges[loc][0]\n        if e_Ag > MX_AG:\n            continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time:\n            continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n    return [min(time[to]) for to in range(-1, N)]"
    }
  ]
}