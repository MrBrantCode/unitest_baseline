{
  "task_id": "taco_19357",
  "entry_point": "count_reachable_black_tiles",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [+1, 0, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [+1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 1, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 1, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, -1, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, -1, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 1, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 1, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, 2, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 2, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, 0, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 0, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, 0, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 0, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, -1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, -1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, 1, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 1]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, 1, -1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, -1]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-1, 0, 1, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 1]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [1, -1, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [1, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [-1, -1, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [-1, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [1, -1, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [1, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, +1, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, +1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, 1, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 1, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, -1, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, -1, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, 1, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 1, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, 0, 2]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 2]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, 0, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 0]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, 0, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 0]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -1, 0, -1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, -1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) or 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) or 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 1\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = -1\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 1\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "res += 1",
      "mutated_line": "res -= 1",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res -= 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-2, 0, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-2, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-0, 0, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-0, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [-0, 0, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-0, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "y = [-1, 0, 1, 0]",
      "mutated_line": "y = [--1, 0, 1, 0]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [--1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -2, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -2, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -0, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -0, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, -0, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -0, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [0, -1, 0, 1]",
      "mutated_line": "x = [0, --1, 0, 1]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, --1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 < i < len(grid) and 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 < i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 > i < len(grid) and 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 > i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 == i < len(grid) and 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 == i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 0 < j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 < j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 0 > j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 > j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 0 == j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 == j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[False] / len(grid[0]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] / len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[False] + len(grid[0]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] + len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[False] ** len(grid[0]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] ** len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if grid[i][j] == '#':",
      "mutated_line": "if grid[i][j] != '#':",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] != '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res += 1",
      "mutated_line": "res += 2",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 2\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res += 1",
      "mutated_line": "res += 0",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 0\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res += 1",
      "mutated_line": "res += 0",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 0\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res += 1",
      "mutated_line": "res += -1",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += -1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "f[i][j] = True",
      "mutated_line": "f[i][j] = False",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = False\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[1], start_pos[1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[1], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[-1], start_pos[1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[-1], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[1], start_pos[1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[1], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[0], start_pos[2])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[0], start_pos[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[0])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[0], start_pos[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[0])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return bfs(start_pos[0], start_pos[1])",
      "mutated_line": "return bfs(start_pos[0], start_pos[-1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 1 <= i < len(grid) and 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 1 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return -1 <= i < len(grid) and 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return -1 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 1 <= i < len(grid) and 0 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 1 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 1 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 1 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and -1 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and -1 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 1 <= j < len(grid[0])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 1 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[i][j] == '#':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(5):",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(5):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(3):",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(3):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(0):",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(0):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(1):",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(1):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(-4):",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(-4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[True] * len(grid[0]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[True] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[1])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[-1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[-1])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[0])",
      "mutated_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[1])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[1])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[False] * len(grid[1]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[1]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[False] * len(grid[-1]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[-1]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f = [[False] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "f = [[False] * len(grid[1]) for _ in range(len(grid))]",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[1]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d.append([i + y[k], j + x[k]])",
      "mutated_line": "d.append([i - y[k], j + x[k]])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i - y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d.append([i + y[k], j + x[k]])",
      "mutated_line": "d.append([i * y[k], j + x[k]])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i * y[k], j + x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d.append([i + y[k], j + x[k]])",
      "mutated_line": "d.append([i + y[k], j - x[k]])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j - x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "d.append([i + y[k], j + x[k]])",
      "mutated_line": "d.append([i + y[k], j * x[k]])",
      "code": "from collections import deque\n\ndef count_reachable_black_tiles(grid, start_pos):\n    y = [-1, 0, 1, 0]\n    x = [0, -1, 0, 1]\n\n    def check(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs(a, b):\n        res = 0\n        d = deque()\n        d.append([a, b])\n        f = [[False] * len(grid[0]) for _ in range(len(grid))]\n        while d:\n            (i, j) = d.popleft()\n            if not check(i, j):\n                continue\n            if grid[i][j] == '#':\n                continue\n            if f[i][j]:\n                continue\n            res += 1\n            f[i][j] = True\n            for k in range(4):\n                d.append([i + y[k], j * x[k]])\n        return res\n    return bfs(start_pos[0], start_pos[1])"
    }
  ]
}