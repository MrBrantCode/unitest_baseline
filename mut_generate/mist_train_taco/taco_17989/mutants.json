{
  "task_id": "taco_17989",
  "entry_point": "count_exciting_orders",
  "mutant_count": 163,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "from collections import Counter\nmod = 10 ** 9 - 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "from collections import Counter\nmod = 10 ** 9 * 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f -= (f[-1] * i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f -= (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "from collections import Counter\nmod = 10 * 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "from collections import Counter\nmod = 10 + 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "from collections import Counter\nmod = 10 ** 9 + 8\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "from collections import Counter\nmod = 10 ** 9 + 6\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "from collections import Counter\nmod = 10 ** 9 + 0\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "from collections import Counter\nmod = 10 ** 9 + 1\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "from collections import Counter\nmod = 10 ** 9 + -7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1]",
      "mutated_line": "f = [2]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [2]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1]",
      "mutated_line": "f = [0]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [0]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1]",
      "mutated_line": "f = [0]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [0]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1]",
      "mutated_line": "f = [-1]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [-1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(2, 2001):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(2, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(0, 2001):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(0, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(0, 2001):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(0, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(-1, 2001):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(-1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(1, 2002):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2002):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(1, 2000):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2000):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(1, 0):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 0):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(1, 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 1):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 2001):",
      "mutated_line": "for i in range(1, -2001):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, -2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: f[n] * inv[n - k] * mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] * mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: f[n] * inv[n - k] + mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] + mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] / (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] / (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] + (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] + (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] ** (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] ** (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "size += cnt[values[i]]",
      "mutated_line": "size -= cnt[values[i]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size -= cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return sum(dp[1:]) % mod",
      "mutated_line": "return sum(dp[1:]) * mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) * mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return sum(dp[1:]) % mod",
      "mutated_line": "return sum(dp[1:]) + mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) + mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "from collections import Counter\nmod = 11 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "from collections import Counter\nmod = 9 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "from collections import Counter\nmod = 0 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "from collections import Counter\nmod = 1 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "from collections import Counter\nmod = -10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "from collections import Counter\nmod = 10 ** 10 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "from collections import Counter\nmod = 10 ** 8 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "from collections import Counter\nmod = 10 ** 0 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "from collections import Counter\nmod = 10 ** 1 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "from collections import Counter\nmod = 10 ** -9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-1] * i * mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i * mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-1] * i + mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i + mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod + 2, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod + 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod * 2, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod * 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: f[n] / inv[n - k] % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] / inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: (f[n] + inv[n - k]) % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: (f[n] + inv[n - k]) % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: f[n] ** inv[n - k] % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] ** inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] * (K - 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K - 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] * (K * 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K * 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[2] = f[cnt[values[0]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[2] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[0] = f[cnt[values[0]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[0] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[0] = f[cnt[values[0]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[0] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[-1] = f[cnt[values[0]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[-1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, len(values)):",
      "mutated_line": "for i in range(2, len(values)):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(2, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, len(values)):",
      "mutated_line": "for i in range(0, len(values)):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(0, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, len(values)):",
      "mutated_line": "for i in range(0, len(values)):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(0, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, len(values)):",
      "mutated_line": "for i in range(-1, len(values)):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(-1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] / (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] / (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] + (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] + (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] ** (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] ** (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] -= dp[k] * A(cnt[values[i]], size - 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] -= dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-1] / i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] / i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += ((f[-1] + i) % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += ((f[-1] + i) % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-1] ** i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] ** i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod - 3, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 3, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod - 1, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 1, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod - 0, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 0, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod - 1, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 1, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "inv = [pow(i, mod - 2, mod) for i in f]",
      "mutated_line": "inv = [pow(i, mod - -2, mod) for i in f]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - -2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [1] * (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [1] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [-1] * (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [-1] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [1] * (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [1] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] * (K + 2)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 2)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] * (K + 0)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 0)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] * (K + 0)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 0)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [0] * (K + 1)",
      "mutated_line": "dp = [0] * (K + -1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + -1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "values = sorted(cnt, reverse=True)",
      "mutated_line": "values = sorted(cnt, reverse=False)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=False)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "size = cnt[values[0]]",
      "mutated_line": "size = cnt[values[1]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[1]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "size = cnt[values[0]]",
      "mutated_line": "size = cnt[values[-1]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[-1]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "size = cnt[values[0]]",
      "mutated_line": "size = cnt[values[1]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[1]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] * (K - 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K - 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] * (K * 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K * 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(2, K + 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(2, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(0, K + 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(0, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(0, K + 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(0, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(-1, K + 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(-1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K - 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K - 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K * 1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K * 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] / A(cnt[values[i]], size - 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] / A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] + A(cnt[values[i]], size - 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] + A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] ** A(cnt[values[i]], size - 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] ** A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + 1 < K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 < K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + 1 > K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 > K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + 1 == K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 == K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] -= cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] -= cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: f[n] * inv[n + k] % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n + k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "A = lambda k, n: f[n] * inv[n - k] % mod",
      "mutated_line": "A = lambda k, n: f[n] * inv[n * k] % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n * k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[1] = f[cnt[values[1]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[1]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[1] = f[cnt[values[-1]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[-1]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[1] = f[cnt[values[0]]]",
      "mutated_line": "dp[1] = f[cnt[values[1]]]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[1]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [1] * (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [1] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [-1] * (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [-1] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [1] * (K + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [1] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] * (K + 2)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 2)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] * (K + 0)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 0)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] * (K + 0)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 0)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new = [0] * (K + 1)",
      "mutated_line": "new = [0] * (K + -1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + -1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 2):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 2):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 0):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 0):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 0):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 0):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + -1):",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + -1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k - 1 <= K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k - 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k * 1 <= K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k * 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) / dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) / dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) + dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) + dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += (cnt[values[i]] * A(cnt[values[i]] - 1, size - 1)) ** dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += (cnt[values[i]] * A(cnt[values[i]] - 1, size - 1)) ** dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[+1] * i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[+1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] * A(cnt[values[i]], size + 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size + 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] * A(cnt[values[i]], size * 1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size * 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + 2 <= K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 2 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + 0 <= K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 0 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + 0 <= K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 0 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k + 1 <= K:",
      "mutated_line": "if k + -1 <= K:",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + -1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k - 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k - 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k * 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k * 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] / A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] / A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += (cnt[values[i]] + A(cnt[values[i]] - 1, size - 1)) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += (cnt[values[i]] + A(cnt[values[i]] - 1, size - 1)) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] ** A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] ** A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new[k + 1] %= mod",
      "mutated_line": "new[k - 1] %= mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k - 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new[k + 1] %= mod",
      "mutated_line": "new[k * 1] %= mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k * 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return sum(dp[1:]) % mod",
      "mutated_line": "return sum(dp[2:]) % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[2:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return sum(dp[1:]) % mod",
      "mutated_line": "return sum(dp[0:]) % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[0:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return sum(dp[1:]) % mod",
      "mutated_line": "return sum(dp[0:]) % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[0:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return sum(dp[1:]) % mod",
      "mutated_line": "return sum(dp[-1:]) % mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[-1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-2] * i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-2] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-0] * i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-0] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[-0] * i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-0] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "f += (f[-1] * i % mod,)",
      "mutated_line": "f += (f[--1] * i % mod,)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[--1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] * A(cnt[values[i]], size - 2)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 2)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] * A(cnt[values[i]], size - 0)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 0)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] * A(cnt[values[i]], size - 0)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 0)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new[k] += dp[k] * A(cnt[values[i]], size - 1)",
      "mutated_line": "new[k] += dp[k] * A(cnt[values[i]], size - -1)",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - -1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 2] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 2] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 0] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 0] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 0] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 0] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + -1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + -1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new[k + 1] %= mod",
      "mutated_line": "new[k + 2] %= mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 2] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new[k + 1] %= mod",
      "mutated_line": "new[k + 0] %= mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 0] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new[k + 1] %= mod",
      "mutated_line": "new[k + 0] %= mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 0] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new[k + 1] %= mod",
      "mutated_line": "new[k + -1] %= mod",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + -1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] + 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] + 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] * 1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] * 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size + 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size + 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size * 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size * 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 2, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 2, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 0, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 0, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 0, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 0, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - -1, size - 1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - -1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 2) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 2) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 0) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 0) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 0) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 0) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]",
      "mutated_line": "new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - -1) * dp[k]",
      "code": "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef count_exciting_orders(N, K, P):\n    cnt = Counter(P)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - -1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod"
    }
  ]
}