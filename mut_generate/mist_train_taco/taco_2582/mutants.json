{
  "task_id": "taco_2582",
  "entry_point": "calculate_polygon_area",
  "mutant_count": 235,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 2000",
      "mutated_line": "L = 2001",
      "code": "def calculate_polygon_area(vertices):\n    L = 2001\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 2000",
      "mutated_line": "L = 1999",
      "code": "def calculate_polygon_area(vertices):\n    L = 1999\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 2000",
      "mutated_line": "L = 0",
      "code": "def calculate_polygon_area(vertices):\n    L = 0\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 2000",
      "mutated_line": "L = 1",
      "code": "def calculate_polygon_area(vertices):\n    L = 1\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "L = 2000",
      "mutated_line": "L = -2000",
      "code": "def calculate_polygon_area(vertices):\n    L = -2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] / N",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] / N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] + N",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] + N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] ** N",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] ** N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 1\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = -1\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 1\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 57,
      "original_line": "ans += r - l",
      "mutated_line": "ans -= r - l",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans -= r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if y0 != y1:",
      "mutated_line": "if y0 == y1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 == y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for y in range(-L, L):",
      "mutated_line": "for y in range(+L, L):",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(+L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "l = r = -5000",
      "mutated_line": "l = r = +5000",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = +5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "ans += r - l",
      "mutated_line": "ans += r + l",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r + l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "ans += r - l",
      "mutated_line": "ans += r * l",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r * l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x0, y0 = vertices[i - 1]",
      "mutated_line": "(x0, y0) = vertices[i + 1]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i + 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x0, y0 = vertices[i - 1]",
      "mutated_line": "(x0, y0) = vertices[i * 1]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i * 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [1] * N",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [1] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [-1] * N",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [-1] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [1] * N",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [1] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in Q[y + L]:",
      "mutated_line": "for i in Q[y - L]:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y - L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in Q[y + L]:",
      "mutated_line": "for i in Q[y * L]:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y * L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dx = x1 - x0",
      "mutated_line": "dx = x1 + x0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 + x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dx = x1 - x0",
      "mutated_line": "dx = x1 * x0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 * x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dy = y1 - y0",
      "mutated_line": "dy = y1 + y0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 + y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dy = y1 - y0",
      "mutated_line": "dy = y1 * y0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 * y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dx < 0:",
      "mutated_line": "if dx <= 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx <= 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dx < 0:",
      "mutated_line": "if dx >= 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx >= 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dx < 0:",
      "mutated_line": "if dx != 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx != 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = r = -5000",
      "mutated_line": "l = r = -5001",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5001\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = r = -5000",
      "mutated_line": "l = r = -4999",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -4999\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = r = -5000",
      "mutated_line": "l = r = -0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -0\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = r = -5000",
      "mutated_line": "l = r = -1",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -1\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = r = -5000",
      "mutated_line": "l = r = --5000",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = --5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dx = x1 - x0",
      "mutated_line": "dx = x1 + x0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 + x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dx = x1 - x0",
      "mutated_line": "dx = x1 * x0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 * x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dy = y1 - y0",
      "mutated_line": "dy = y1 + y0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 + y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dy = y1 - y0",
      "mutated_line": "dy = y1 * y0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 * y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if k & 1:",
      "mutated_line": "if k | 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k | 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 * L - 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L - 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 * L * 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L * 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x0, y0 = vertices[i - 1]",
      "mutated_line": "(x0, y0) = vertices[i - 2]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 2]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x0, y0 = vertices[i - 1]",
      "mutated_line": "(x0, y0) = vertices[i - 0]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 0]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x0, y0 = vertices[i - 1]",
      "mutated_line": "(x0, y0) = vertices[i - 0]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 0]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x0, y0 = vertices[i - 1]",
      "mutated_line": "(x0, y0) = vertices[i - -1]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - -1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 <= y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 <= y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 >= y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 >= y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 != y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 != y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = 2",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 2\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = 0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 0\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = 0",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 0\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[i] = 1",
      "mutated_line": "U[i] = -1",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = -1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx < 0:",
      "mutated_line": "if dx < 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 1:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx < 0:",
      "mutated_line": "if dx < -1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < -1:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx < 0:",
      "mutated_line": "if dx < 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 1:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 - dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 - dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 * (dx * (y - y0) / dy), x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 * (dx * (y - y0) / dy), x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 - (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 - (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 * ((dx * (y + 1 - y0) + dy - 1) // dy))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 * ((dx * (y + 1 - y0) + dy - 1) // dy))\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k & 1:",
      "mutated_line": "if k & 2:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 2:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k & 1:",
      "mutated_line": "if k & 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 0:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k & 1:",
      "mutated_line": "if k & 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 0:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k & 1:",
      "mutated_line": "if k & -1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & -1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx > 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx > 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx < 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx < 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx == 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx == 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx > 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx > 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx < 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx < 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx == 0:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx == 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if r < x:",
      "mutated_line": "if r <= x:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r <= x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if r < x:",
      "mutated_line": "if r >= x:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r >= x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if r < x:",
      "mutated_line": "if r != x:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r != x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ans += r - l",
      "mutated_line": "ans -= r - l",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans -= r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 / L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 / L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 + L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 + L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 ** L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 ** L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 * L + 2)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 2)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 * L + 0)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 0)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 * L + 0)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 0)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(2 * L + -1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + -1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 - dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 - dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 * (dx * (y + 1 - y0) / dy), x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 * (dx * (y + 1 - y0) / dy), x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 - (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 - (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 * ((dx * (y - y0) + dy - 1) // dy))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 * ((dx * (y - y0) + dy - 1) // dy))\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) * dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) * dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) // dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) // dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) / dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) / dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) * dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) * dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx >= 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 1:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx >= -1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= -1:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx >= 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 1:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 - (dx * (y + 1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 - (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 * ((dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 * ((dx * (y + 1 - y0) + dy - 1) // dy)\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 - (dx * (y - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 - (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 * ((dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 * ((dx * (y - y0) + dy - 1) // dy)\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx >= 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 1:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx >= -1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= -1:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if dx >= 0:",
      "mutated_line": "if dx >= 1:",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 1:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 - dx * (y - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 - dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 * (dx * (y - y0) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 * (dx * (y - y0) // dy)\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 - dx * (y + 1 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 - dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 * (dx * (y + 1 - y0) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 * (dx * (y + 1 - y0) // dy)\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += r - l",
      "mutated_line": "ans += r + l",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r + l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += r - l",
      "mutated_line": "ans += r * l",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r * l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(3 * L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(3 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(1 * L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(1 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(0 * L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(0 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(1 * L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(1 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Q = [[] for _ in range(2 * L + 1)]",
      "mutated_line": "Q = [[] for _ in range(-2 * L + 1)]",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(-2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Q[y0 + L].append(i)",
      "mutated_line": "Q[y0 - L].append(i)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 - L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Q[y0 + L].append(i)",
      "mutated_line": "Q[y0 * L].append(i)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 * L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q[y1 + L].append(i)",
      "mutated_line": "Q[y1 - L].append(i)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 - L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Q[y1 + L].append(i)",
      "mutated_line": "Q[y1 * L].append(i)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 * L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i + 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i + 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i * 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i * 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i + 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i + 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i * 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i * 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) * dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) * dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) // dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) // dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) / dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) / dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) * dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) * dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx / (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx / (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + (dx + (y - y0)) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + (dx + (y - y0)) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx ** (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx ** (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy + 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy + 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy) * 1 // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy) * 1 // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) / dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) / dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) * dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) * dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy - 1) / dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) / dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy - 1) * dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) * dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + dx * (y - y0) / dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) / dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + dx * (y - y0) * dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) * dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + 1 - y0) / dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) / dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + 1 - y0) * dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) * dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 2], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 2], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 0], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 0], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 0], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 0], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - -1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - -1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 2]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 2]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 0]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 0]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 0]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 0]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))",
      "mutated_line": "LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - -1]))",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - -1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx / (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx / (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + (dx + (y + 1 - y0)) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + (dx + (y + 1 - y0)) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx ** (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx ** (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy + 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy + 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy) * 1 // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy) * 1 // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y + y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y * y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y * y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) - dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) - dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) * dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) * dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 2) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 2) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 0) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 0) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 0) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 0) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - -1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - -1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy + 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy + 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy) * 1 // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy) * 1 // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy + 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy + 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy) * 1 // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy) * 1 // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + dx / (y - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx / (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + (dx + (y - y0)) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + (dx + (y - y0)) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + dx ** (y - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx ** (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx / (y + 1 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx / (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + (dx + (y + 1 - y0)) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + (dx + (y + 1 - y0)) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx ** (y + 1 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx ** (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 + y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 + y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * ((y + 1) * y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * ((y + 1) * y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) - dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) - dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) * dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) * dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 2) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 2) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 0) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 0) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 0) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 0) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - -1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - -1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx / (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx / (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx + (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx + (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx ** (y + 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx ** (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) - dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) - dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) * dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) * dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy - 2) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 2) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy - 0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 0) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy - 0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 0) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 - y0) + dy - -1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - -1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) - dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) - dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) * dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) * dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy - 2) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 2) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy - 0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 0) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy - 0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 0) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - y0) + dy - -1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - -1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y + y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "x = x0 + dx * (y - y0) // dy",
      "mutated_line": "x = x0 + dx * (y * y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y * y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + 1 + y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 + y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * ((y + 1) * y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * ((y + 1) * y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y - 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y * 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y * 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx / (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx / (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx + (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx + (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx ** (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx ** (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 + y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 + y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * ((y + 1) * y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * ((y + 1) * y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx / (y + 1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx / (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx + (y + 1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx + (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx ** (y + 1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx ** (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx / (y - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx / (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx + (y - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx + (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx ** (y - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx ** (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y - 1 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y - 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y * 1 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y * 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 2 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 2 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 0 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 0 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 0 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 0 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + -1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + -1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y + y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y + y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y * y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y * y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y - 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y - 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y * 1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y * 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 1 + y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 + y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * ((y + 1) * y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * ((y + 1) * y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y + y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "x = x0 + (dx * (y - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y * y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y * y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + 2 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 2 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + 0 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 0 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + 0 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 0 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "x = x0 + dx * (y + 1 - y0) // dy",
      "mutated_line": "x = x0 + dx * (y + -1 - y0) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + -1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 2 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 2 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 0 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 0 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 0 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 0 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)",
      "mutated_line": "return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + -1 - y0) + dy - 1) // dy)",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + -1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y - 1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y - 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y * 1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y * 1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 2 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 2 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 0 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 0 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + 0 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + 0 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x = x0 + (dx * (y + 1 - y0) + dy - 1) // dy",
      "mutated_line": "x = x0 + (dx * (y + -1 - y0) + dy - 1) // dy",
      "code": "def calculate_polygon_area(vertices):\n    L = 2000\n    N = len(vertices)\n    Q = [[] for _ in range(2 * L + 1)]\n    LS = []\n    for i in range(N):\n        (x0, y0) = vertices[i - 1]\n        (x1, y1) = vertices[i]\n        if y0 != y1:\n            Q[y0 + L].append(i)\n            Q[y1 + L].append(i)\n        LS.append((vertices[i - 1], vertices[i]) if y0 < y1 else (vertices[i], vertices[i - 1]))\n    U = [0] * N\n    s = set()\n    ans = 0\n    for y in range(-L, L):\n        for i in Q[y + L]:\n            if U[i]:\n                s.remove(i)\n            else:\n                s.add(i)\n                U[i] = 1\n        js = list(s)\n\n        def f(i):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx < 0:\n                return (x0 + dx * (y + 1 - y0) / dy, x0 + (dx * (y - y0) + dy - 1) // dy)\n            return (x0 + dx * (y - y0) / dy, x0 + (dx * (y + 1 - y0) + dy - 1) // dy)\n        js.sort(key=f)\n        l = r = -5000\n        for (k, i) in enumerate(js):\n            ((x0, y0), (x1, y1)) = LS[i]\n            dx = x1 - x0\n            dy = y1 - y0\n            if k & 1:\n                if dx >= 0:\n                    x = x0 + (dx * (y + -1 - y0) + dy - 1) // dy\n                else:\n                    x = x0 + (dx * (y - y0) + dy - 1) // dy\n                r = x\n            else:\n                if dx >= 0:\n                    x = x0 + dx * (y - y0) // dy\n                else:\n                    x = x0 + dx * (y + 1 - y0) // dy\n                if r < x:\n                    ans += r - l\n                    l = x\n        ans += r - l\n    return ans"
    }
  ]
}